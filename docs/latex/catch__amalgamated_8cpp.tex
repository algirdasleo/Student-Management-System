\doxysection{catch\+\_\+amalgamated.\+cpp File Reference}
\hypertarget{catch__amalgamated_8cpp}{}\label{catch__amalgamated_8cpp}\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
{\ttfamily \#include "{}catch\+\_\+amalgamated.\+hpp"{}}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include $<$limits$>$}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include $<$cassert$>$}\newline
{\ttfamily \#include $<$stack$>$}\newline
{\ttfamily \#include $<$exception$>$}\newline
{\ttfamily \#include $<$algorithm$>$}\newline
{\ttfamily \#include $<$iomanip$>$}\newline
{\ttfamily \#include $<$set$>$}\newline
{\ttfamily \#include $<$cctype$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$ostream$>$}\newline
{\ttfamily \#include $<$chrono$>$}\newline
{\ttfamily \#include $<$random$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$stdexcept$>$}\newline
{\ttfamily \#include $<$cerrno$>$}\newline
{\ttfamily \#include $<$signal.\+h$>$}\newline
{\ttfamily \#include $<$cstring$>$}\newline
{\ttfamily \#include $<$cstdlib$>$}\newline
{\ttfamily \#include $<$cstdio$>$}\newline
{\ttfamily \#include $<$sstream$>$}\newline
{\ttfamily \#include $<$ctime$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$iterator$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$regex$>$}\newline
{\ttfamily \#include $<$cfloat$>$}\newline
{\ttfamily \#include $<$map$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_catch_1_1_generators_1_1_random_floating_generator_1_1_p_impl}{Catch\+::\+Generators\+::\+Random\+Floating\+Generator\+::\+PImpl}}
\item 
struct \mbox{\hyperlink{struct_catch_1_1_signal_defs}{Catch\+::\+Signal\+Defs}}
\item 
struct \mbox{\hyperlink{struct_catch_1_1_reporter_registry_1_1_reporter_registry_impl}{Catch\+::\+Reporter\+Registry\+::\+Reporter\+Registry\+Impl}}
\item 
struct \mbox{\hyperlink{struct_catch_1_1_string_streams}{Catch\+::\+String\+Streams}}
\item 
struct \mbox{\hyperlink{struct_catch_1_1_column_info}{Catch\+::\+Column\+Info}}
\item 
class \mbox{\hyperlink{class_catch_1_1_table_printer}{Catch\+::\+Table\+Printer}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespace_catch}{Catch}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_benchmark}{Catch\+::\+Benchmark}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail}{Catch\+::\+Benchmark\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1literals}{Catch\+::literals}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_detail}{Catch\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_generators}{Catch\+::\+Generators}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_generators_1_1_detail}{Catch\+::\+Generators\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_clara}{Catch\+::\+Clara}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_clara_1_1_detail}{Catch\+::\+Clara\+::\+Detail}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_test_case_tracking}{Catch\+::\+Test\+Case\+Tracking}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_text_flow}{Catch\+::\+Text\+Flow}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_matchers}{Catch\+::\+Matchers}}
\item 
namespace \mbox{\hyperlink{namespace_catch_1_1_matchers_1_1_detail}{Catch\+::\+Matchers\+::\+Detail}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}{Digits}}(\mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}})~( \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} \& 0x\+FF\textquotesingle{}FF\textquotesingle{}FF\textquotesingle{}FF )            std\+::uint64\+\_\+t lhs\+\_\+low = Digits( lhs );            std\+::uint64\+\_\+t rhs\+\_\+low = Digits( rhs );            std\+::uint64\+\_\+t low\+\_\+low = ( lhs\+\_\+low \texorpdfstring{$\ast$}{*} rhs\+\_\+low );            std\+::uint64\+\_\+t high\+\_\+high = \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( lhs ) \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( rhs );                        std\+::uint64\+\_\+t high\+\_\+low =                ( \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( lhs ) \texorpdfstring{$\ast$}{*} rhs\+\_\+low ) + \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( low\+\_\+low );                                    std\+::uint64\+\_\+t low\+\_\+high =                ( lhs\+\_\+low \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( rhs ) ) + Digits( high\+\_\+low );            return \{ high\+\_\+high + \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( high\+\_\+low ) + \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( low\+\_\+high ),                     ( low\+\_\+high $<$$<$ 32 ) \texorpdfstring{$\vert$}{|} Digits( low\+\_\+low ) \};\#undef \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}\#undef Digits        \}                inline Extended\+Mult\+Result$<$std\+::uint64\+\_\+t$>$        extended\+Mult( std\+::uint64\+\_\+t lhs, std\+::uint64\+\_\+t rhs ) \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( CATCH\+\_\+\+CONFIG\+\_\+\+UINT128 )            auto \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} = \+\_\+\+\_\+uint128\+\_\+t( lhs ) \texorpdfstring{$\ast$}{*} \+\_\+\+\_\+uint128\+\_\+t( rhs );            return \{ static\+\_\+cast$<$std\+::uint64\+\_\+t$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} $>$$>$ 64 ),                     static\+\_\+cast$<$std\+::uint64\+\_\+t$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} ) \};\#elif defined( CATCH\+\_\+\+CONFIG\+\_\+\+MSVC\+\_\+\+UMUL128 )            std\+::uint64\+\_\+t high;            std\+::uint64\+\_\+t low = \+\_\+umul128( lhs, rhs, \&high );            return \{ high, low \};\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}            return extended\+Mult\+Portable( lhs, rhs );\#endif        \}        template $<$typename UInt$>$        constexpr Extended\+Mult\+Result$<$UInt$>$ extended\+Mult( UInt lhs, UInt rhs ) \{            static\+\_\+assert( std\+::is\+\_\+unsigned$<$UInt$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}extended\+Mult can only handle unsigned integers"{} );            static\+\_\+assert( sizeof( UInt ) $<$ sizeof( std\+::uint64\+\_\+t ),                           "{}Generic extended\+Mult can only handle types smaller "{}                           "{}than uint64\+\_\+t"{} );            using Wide\+Type = Double\+Width\+Unsigned\+Type\+\_\+t$<$UInt$>$;            auto \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} = Wide\+Type( lhs ) \texorpdfstring{$\ast$}{*} Wide\+Type( rhs );            return \{                static\+\_\+cast$<$UInt$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} $>$$>$ ( CHAR\+\_\+\+BIT \texorpdfstring{$\ast$}{*} sizeof( UInt ) ) ),                static\+\_\+cast$<$UInt$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} \& UInt( -\/1 ) ) \};        \}        template $<$typename Target\+Type,                  typename Generator$>$            std\+::enable\+\_\+if\+\_\+t$<$sizeof(typename Generator\+::result\+\_\+type) $>$= sizeof(Target\+Type),            Target\+Type$>$ fill\+Bits\+From(Generator\& gen) \{            using gresult\+\_\+type = typename Generator\+::result\+\_\+type;            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Target\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Only unsigned integers are supported"{} );            static\+\_\+assert( Generator\+::min() == 0 \&\&                           Generator\+::max() == static\+\_\+cast$<$gresult\+\_\+type$>$( -\/1 ),                           "{}Generator must be able to output all numbers in its \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} type (effectively it must be a random bit generator)"{} );                                    constexpr auto generated\+\_\+bits = sizeof( gresult\+\_\+type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            constexpr auto return\+\_\+bits = sizeof( Target\+Type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            return static\+\_\+cast$<$Target\+Type$>$( gen() $>$$>$                                            ( generated\+\_\+bits -\/ return\+\_\+bits) );        \}        template $<$typename Target\+Type,                  typename Generator$>$            std\+::enable\+\_\+if\+\_\+t$<$sizeof(typename Generator\+::result\+\_\+type) $<$ sizeof(Target\+Type),            Target\+Type$>$ fill\+Bits\+From(Generator\& gen) \{            using gresult\+\_\+type = typename Generator\+::result\+\_\+type;            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Target\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}Only unsigned integers are supported"{} );            static\+\_\+assert( Generator\+::min() == 0 \&\&                           Generator\+::max() == static\+\_\+cast$<$gresult\+\_\+type$>$( -\/1 ),                           "{}Generator must be able to output all numbers in its \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} type (effectively it must be a random bit generator)"{} );            constexpr auto generated\+\_\+bits = sizeof( gresult\+\_\+type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            constexpr auto return\+\_\+bits = sizeof( Target\+Type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            std\+::size\+\_\+t filled\+\_\+bits = 0;            Target\+Type ret = 0;            do \{                ret $<$$<$= generated\+\_\+bits;                ret \texorpdfstring{$\vert$}{|}= gen();                filled\+\_\+bits += generated\+\_\+bits;            \} while ( filled\+\_\+bits $<$ return\+\_\+bits );            return ret;        \}                template $<$typename Original\+Type, typename Unsigned\+Type$>$        std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+signed$<$Original\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Unsigned\+Type$>$        transpose\+To\+Natural\+Order( Unsigned\+Type in ) \{            static\+\_\+assert(                sizeof( Original\+Type ) == sizeof( Unsigned\+Type ),                "{}reordering requires the same sized types on both sides"{} );            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Unsigned\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}Input type must be unsigned"{} );                                                            constexpr auto highest\+\_\+bit =                Unsigned\+Type( 1 ) $<$$<$ ( sizeof( Unsigned\+Type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT -\/ 1 );            return static\+\_\+cast$<$Unsigned\+Type$>$( in \texorpdfstring{$^\wedge$}{\string^} highest\+\_\+bit );        \}        template $<$typename Original\+Type,                  typename Unsigned\+Type$>$        std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+unsigned$<$Original\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Unsigned\+Type$>$            transpose\+To\+Natural\+Order(Unsigned\+Type in) \{            static\+\_\+assert(                sizeof( Original\+Type ) == sizeof( Unsigned\+Type ),                "{}reordering requires the same sized types on both sides"{} );            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Unsigned\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Input type must be unsigned"{} );                        return in;        \}    \} \} \#endif namespace Catch \{template $<$typename Integer\+Type$>$class uniform\+\_\+integer\+\_\+distribution \{    static\+\_\+assert(std\+::is\+\_\+integral$<$Integer\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}..."{});    using Unsigned\+Integer\+Type = Detail\+::\+Sized\+Unsigned\+Type\+\_\+t$<$sizeof(Integer\+Type)$>$;                        Unsigned\+Integer\+Type m\+\_\+a;        Unsigned\+Integer\+Type m\+\_\+ab\+\_\+distance;                            Unsigned\+Integer\+Type m\+\_\+rejection\+\_\+threshold = 0;    Unsigned\+Integer\+Type compute\+Distance(Integer\+Type a, Integer\+Type b) const \{                        return transpose\+To(b) -\/ transpose\+To(a) + 1;    \}    static Unsigned\+Integer\+Type compute\+Rejection\+Threshold(Unsigned\+Integer\+Type ab\+\_\+distance) \{                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( ab\+\_\+distance == 0 ) \{ return 0; \}        return ( \texorpdfstring{$\sim$}{\string~}ab\+\_\+distance + 1 ) \% ab\+\_\+distance;    \}    static Unsigned\+Integer\+Type transpose\+To(Integer\+Type in) \{        return Detail\+::transpose\+To\+Natural\+Order$<$Integer\+Type$>$(            static\+\_\+cast$<$Unsigned\+Integer\+Type$>$( in ) );    \}    static Integer\+Type transpose\+Back(Unsigned\+Integer\+Type in) \{        return static\+\_\+cast$<$Integer\+Type$>$(            Detail\+::transpose\+To\+Natural\+Order$<$Integer\+Type$>$(in) );    \}public\+:    using result\+\_\+type = Integer\+Type;    uniform\+\_\+integer\+\_\+distribution( Integer\+Type a, Integer\+Type b )\+:        m\+\_\+a( transpose\+To(a) ),        m\+\_\+ab\+\_\+distance( compute\+Distance(a, b) ),        m\+\_\+rejection\+\_\+threshold( compute\+Rejection\+Threshold(m\+\_\+ab\+\_\+distance) ) \{        assert( a $<$= b );    \}    template $<$typename Generator$>$    result\+\_\+type operator()( Generator\& g ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+ab\+\_\+distance == 0 ) \{            return transpose\+Back( Detail\+::fill\+Bits\+From$<$Unsigned\+Integer\+Type$>$( g ) );        \}        auto random\+\_\+number = Detail\+::fill\+Bits\+From$<$Unsigned\+Integer\+Type$>$( g );        auto emul = Detail\+::extended\+Mult( random\+\_\+number, m\+\_\+ab\+\_\+distance );                        while (emul.\+lower $<$ m\+\_\+rejection\+\_\+threshold) \{            random\+\_\+number = Detail\+::fill\+Bits\+From$<$Unsigned\+Integer\+Type$>$( g );            emul = Detail\+::extended\+Mult( random\+\_\+number, m\+\_\+ab\+\_\+distance );        \}        return transpose\+Back(m\+\_\+a + emul.\+upper);    \}    result\+\_\+type a() const \{ return transpose\+Back(m\+\_\+a); \}    result\+\_\+type b() const \{ return transpose\+Back(m\+\_\+ab\+\_\+distance + m\+\_\+a -\/ 1); \}\};\} \#endif \#ifndef CATCH\+\_\+\+UNIFORM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+DISTRIBUTION\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+UNIFORM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+DISTRIBUTION\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+RANDOM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+RANDOM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+POLYFILLS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+POLYFILLS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    bool isnan(float f);    bool isnan(double d);    float nextafter(float \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, float y);    double nextafter(double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, double y);\}\#endif \#include $<$cassert$>$\#include $<$cmath$>$\#include $<$cstdint$>$\#include $<$limits$>$\#include $<$type\+\_\+traits$>$namespace Catch \{    namespace Detail \{                template $<$typename Float\+Type$>$        Float\+Type gamma(Float\+Type a, Float\+Type b) \{            static\+\_\+assert( std\+::is\+\_\+floating\+\_\+point$<$Float\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}gamma returns the largest ULP magnitude within "{}                           "{}floating point range \mbox{[}a, b\mbox{]}. This only makes sense "{}                           "{}for floating point types"{} );            assert( a $<$= b );            const auto gamma\+\_\+up = \mbox{\hyperlink{namespace_catch_ae65d074e6c60320640a500d302b83bb2}{Catch\+::nextafter}}( a, std\+::numeric\+\_\+limits$<$Float\+Type$>$\+::infinity() ) -\/ a;            const auto gamma\+\_\+down = b -\/ \mbox{\hyperlink{namespace_catch_ae65d074e6c60320640a500d302b83bb2}{Catch\+::nextafter}}( b, -\/std\+::numeric\+\_\+limits$<$Float\+Type$>$\+::infinity() );            return gamma\+\_\+up $<$ gamma\+\_\+down ? gamma\+\_\+down \+: gamma\+\_\+up;        \}        template $<$typename Floating\+Point$>$        struct Distance\+Type\+Picker;        template $<$$>$        struct Distance\+Type\+Picker$<$float$>$ \{            using type = std\+::uint32\+\_\+t;        \};        template $<$$>$        struct Distance\+Type\+Picker$<$double$>$ \{            using type = std\+::uint64\+\_\+t;        \};        template $<$typename T$>$        using Distance\+Type = typename Distance\+Type\+Picker$<$T$>$\+::type;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic push\#    pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}\#endif                template $<$typename Float\+Type$>$        Distance\+Type$<$Float\+Type$>$        count\+\_\+equidistant\+\_\+floats( Float\+Type a, Float\+Type b, Float\+Type distance ) \{            assert( a $<$= b );                                    const auto ag = a / distance;            const auto bg = b / distance;            const auto s = bg -\/ ag;            const auto err = ( std\+::fabs( a ) $<$= std\+::fabs( b ) )                                 ? -\/ag -\/ ( s -\/ bg )                                 \+: bg -\/ ( s + ag );            const auto ceil\+\_\+s = static\+\_\+cast$<$Distance\+Type$<$Float\+Type$>$$>$( std\+::ceil( s ) );            return ( ceil\+\_\+s != s ) ? ceil\+\_\+s \+: ceil\+\_\+s + ( err $>$ 0 );        \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic pop\#endif    \}\} \#endif \#include $<$cmath$>$\#include $<$type\+\_\+traits$>$namespace Catch \{    namespace Detail \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic push\#    pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}\#endif                                        constexpr std\+::uint64\+\_\+t calculate\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go(double gamma) \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( gamma == 1.\+99584030953472e+292 ) \{ return 9007199254740991; \}            return static\+\_\+cast$<$std\+::uint64\+\_\+t$>$( -\/1 );        \}        constexpr std\+::uint32\+\_\+t calculate\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go(float gamma) \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( gamma == 2.\+028241e+31f ) \{ return 16777215; \}            return static\+\_\+cast$<$std\+::uint32\+\_\+t$>$( -\/1 );        \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic pop\#endif    \}template $<$typename Float\+Type$>$class uniform\+\_\+floating\+\_\+point\+\_\+distribution \{    static\+\_\+assert(std\+::is\+\_\+floating\+\_\+point$<$Float\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}..."{});    static\+\_\+assert(!std\+::is\+\_\+same$<$Float\+Type, long double$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                  "{}We do not support long double due to inconsistent behaviour between platforms"{});    using Width\+Type = Detail\+::\+Distance\+Type$<$Float\+Type$>$;    Float\+Type m\+\_\+a, m\+\_\+b;    Float\+Type m\+\_\+ulp\+\_\+magnitude;    Width\+Type m\+\_\+floats\+\_\+in\+\_\+range;    uniform\+\_\+integer\+\_\+distribution$<$Width\+Type$>$ m\+\_\+int\+\_\+dist;                Width\+Type m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go;        bool m\+\_\+a\+\_\+has\+\_\+leq\+\_\+magnitude;public\+:    using result\+\_\+type = Float\+Type;    uniform\+\_\+floating\+\_\+point\+\_\+distribution( Float\+Type a, Float\+Type b )\+:        m\+\_\+a( a ),        m\+\_\+b( b ),        m\+\_\+ulp\+\_\+magnitude( Detail\+::gamma( m\+\_\+a, m\+\_\+b ) ),        m\+\_\+floats\+\_\+in\+\_\+range( Detail\+::count\+\_\+equidistant\+\_\+floats( m\+\_\+a, m\+\_\+b, m\+\_\+ulp\+\_\+magnitude ) ),        m\+\_\+int\+\_\+dist(0, m\+\_\+floats\+\_\+in\+\_\+range),        m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go( Detail\+::calculate\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go(m\+\_\+ulp\+\_\+magnitude)),        m\+\_\+a\+\_\+has\+\_\+leq\+\_\+magnitude(std\+::fabs(m\+\_\+a) $<$= std\+::fabs(m\+\_\+b))    \{        assert( a $<$= b );    \}    template $<$typename Generator$>$    result\+\_\+type operator()( Generator\& g ) \{        Width\+Type steps = m\+\_\+int\+\_\+dist( g );        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+a\+\_\+has\+\_\+leq\+\_\+magnitude ) \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( steps == m\+\_\+floats\+\_\+in\+\_\+range ) \{ return m\+\_\+a; \}            auto b = m\+\_\+b;            while (steps $>$ m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go) \{                b -\/= m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;                steps -\/= m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go;            \}            return b -\/ steps \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;        \} \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( steps == m\+\_\+floats\+\_\+in\+\_\+range ) \{ return m\+\_\+b; \}            auto a = m\+\_\+a;            while (steps $>$ m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go) \{                a += m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;                steps -\/= m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go;            \}            return a + steps \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;        \}    \}    result\+\_\+type a() const \{ return m\+\_\+a; \}    result\+\_\+type b() const \{ return m\+\_\+b; \}\};\} \#endif namespace Catch \{namespace Generators \{namespace Detail \{                std\+::uint32\+\_\+t get\+Seed();\}template $<$typename Float$>$class Random\+Floating\+Generator final \+: public IGenerator$<$Float$>$ \{    \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch\+::\+Simple\+Pcg32}} m\+\_\+rng;    Catch\+::uniform\+\_\+floating\+\_\+point\+\_\+distribution$<$Float$>$ m\+\_\+dist;    Float m\+\_\+current\+\_\+number;public\+:    Random\+Floating\+Generator( Float a, Float b, std\+::uint32\+\_\+t seed )\+:        m\+\_\+rng(seed),        m\+\_\+dist(a, b) \{        static\+\_\+cast$<$void$>$(next());    \}    Float const\& get() const override \{        return m\+\_\+current\+\_\+number;    \}    bool next() override \{        m\+\_\+current\+\_\+number = m\+\_\+dist(m\+\_\+rng);        return true;    \}\};template $<$$>$class Random\+Floating\+Generator$<$long double$>$ final \+: public IGenerator$<$long double$>$ \{            struct PImpl;    \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$PImpl$>$ m\+\_\+pimpl;    long double m\+\_\+current\+\_\+number;public\+:    Random\+Floating\+Generator( long double a, long double b, std\+::uint32\+\_\+t seed );    long double const\& get() const override \{ return m\+\_\+current\+\_\+number; \}    bool next() override;    \texorpdfstring{$\sim$}{\string~}Random\+Floating\+Generator() override; \};template $<$typename Integer$>$class Random\+Integer\+Generator final \+: public IGenerator$<$Integer$>$ \{    \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch\+::\+Simple\+Pcg32}} m\+\_\+rng;    Catch\+::uniform\+\_\+integer\+\_\+distribution$<$Integer$>$ m\+\_\+dist;    Integer m\+\_\+current\+\_\+number;public\+:    Random\+Integer\+Generator( Integer a, Integer b, std\+::uint32\+\_\+t seed )\+:        m\+\_\+rng(seed),        m\+\_\+dist(a, b) \{        static\+\_\+cast$<$void$>$(next());    \}    Integer const\& get() const override \{        return m\+\_\+current\+\_\+number;    \}    bool next() override \{        m\+\_\+current\+\_\+number = m\+\_\+dist(m\+\_\+rng);        return true;    \}\};template $<$typename T$>$std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+integral$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Generator\+Wrapper$<$T$>$$>$random(T a, T b) \{    return Generator\+Wrapper$<$T$>$(        \mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Random\+Integer\+Generator$<$T$>$$>$(a, b, Detail\+::get\+Seed())    );\}template $<$typename T$>$std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+floating\+\_\+point$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},Generator\+Wrapper$<$T$>$$>$random(T a, T b) \{    return Generator\+Wrapper$<$T$>$(        \mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Random\+Floating\+Generator$<$T$>$$>$(a, b, Detail\+::get\+Seed())    );\}\} \} \#endif \#ifndef CATCH\+\_\+\+GENERATORS\+\_\+\+RANGE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+GENERATORS\+\_\+\+RANGE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iterator$>$\#include $<$type\+\_\+traits$>$namespace Catch \{namespace Generators \{template $<$typename T$>$class Range\+Generator final \+: public IGenerator$<$T$>$ \{    T m\+\_\+current;    T m\+\_\+end;    T m\+\_\+step;    bool m\+\_\+positive;public\+:    Range\+Generator(T const\& start, T const\& end, T const\& step)\+:        m\+\_\+current(start),        m\+\_\+end(end),        m\+\_\+step(step),        m\+\_\+positive(m\+\_\+step $>$ T(0))    \{        assert(m\+\_\+current != m\+\_\+end \&\& "{}Range start and end cannot be equal"{});        assert(m\+\_\+step != T(0) \&\& "{}Step size cannot be zero"{});        assert(((m\+\_\+positive \&\& m\+\_\+current $<$= m\+\_\+end) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (!m\+\_\+positive \&\& m\+\_\+current $>$= m\+\_\+end)) \&\& "{}Step moves away from end"{});    \}    Range\+Generator(T const\& start, T const\& end)\+:        Range\+Generator(start, end, (start $<$ end) ? T(1) \+: T(-\/1))    \{\}    T const\& get() const override \{        return m\+\_\+current;    \}    bool next() override \{        m\+\_\+current += m\+\_\+step;        return (m\+\_\+positive) ? (m\+\_\+current $<$ m\+\_\+end) \+: (m\+\_\+current $>$ m\+\_\+end);    \}\};template $<$typename T$>$Generator\+Wrapper$<$T$>$ range(T const\& start, T const\& end, T const\& step) \{    static\+\_\+assert(std\+::is\+\_\+arithmetic$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}} \&\& !std\+::is\+\_\+same$<$T, bool$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Type must be numeric"{});    return Generator\+Wrapper$<$T$>$(\mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Range\+Generator$<$T$>$$>$(start, end, step));\}template $<$typename T$>$Generator\+Wrapper$<$T$>$ range(T const\& start, T const\& end) \{    static\+\_\+assert(std\+::is\+\_\+integral$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}} \&\& !std\+::is\+\_\+same$<$T, bool$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Type must be an integer"{});    return Generator\+Wrapper$<$T$>$(\mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Range\+Generator$<$T$>$$>$(start, end));\}template $<$typename T$>$class Iterator\+Generator final \+: public IGenerator$<$T$>$ \{    static\+\_\+assert(!std\+::is\+\_\+same$<$T, bool$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        "{}Iterator\+Generator currently does not support bools"{}        "{}because of std\+::vector$<$bool$>$ specialization"{});    std\+::vector$<$T$>$ m\+\_\+elems;    size\+\_\+t m\+\_\+current = 0;public\+:    template $<$typename Input\+Iterator, typename Input\+Sentinel$>$    Iterator\+Generator(Input\+Iterator first, Input\+Sentinel last)\+:m\+\_\+elems(first, last) \{        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+elems.\+empty()) \{            Detail\+::throw\+\_\+generator\+\_\+exception("{}Iterator\+Generator received no valid values"{});        \}    \}    T const\& get() const override \{        return m\+\_\+elems\mbox{[}m\+\_\+current\mbox{]};    \}    bool next() override \{        ++m\+\_\+current;        return m\+\_\+current != m\+\_\+elems.\+size();    \}\};template $<$typename Input\+Iterator,          typename Input\+Sentinel,          typename Result\+Type = typename std\+::iterator\+\_\+traits$<$Input\+Iterator$>$\+::value\+\_\+type$>$Generator\+Wrapper$<$Result\+Type$>$ from\+\_\+range(Input\+Iterator from, Input\+Sentinel to) \{    return Generator\+Wrapper$<$Result\+Type$>$(\mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Iterator\+Generator$<$Result\+Type$>$$>$(from, to));\}template $<$typename Container$>$auto from\+\_\+range(Container const\& cnt) \{    using std\+::begin;    using std\+::end;    return from\+\_\+range( begin( cnt ), end( cnt ) );\}\} \} \#endif \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+TEST\+\_\+\+RUN\+\_\+\+INFO\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+RUN\+\_\+\+INFO\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    struct Test\+Run\+Info \{        constexpr Test\+Run\+Info(String\+Ref \+\_\+name) \+: name(\+\_\+name) \{\}        String\+Ref name;    \};\} \#endif \#include $<$map$>$\#include $<$string$>$\#include $<$vector$>$\#include $<$iosfwd$>$namespace Catch \{    struct Reporter\+Description;    struct Listener\+Description;    struct Tag\+Info;    struct Test\+Case\+Info;    class Test\+Case\+Handle;    class IConfig;    class IStream;    enum class Colour\+Mode \+: std\+::uint8\+\_\+t;    struct Reporter\+Config \{        Reporter\+Config( IConfig const\texorpdfstring{$\ast$}{*} \+\_\+full\+Config,                        Detail\+::unique\+\_\+ptr$<$IStream$>$ \+\_\+stream,                        Colour\+Mode colour\+Mode,                        std\+::map$<$std\+::string, std\+::string$>$ custom\+Options );        Reporter\+Config( Reporter\+Config\&\& ) = default;        Reporter\+Config\& operator=( Reporter\+Config\&\& ) = default;        \texorpdfstring{$\sim$}{\string~}Reporter\+Config();         Detail\+::unique\+\_\+ptr$<$IStream$>$ take\+Stream() \&\&;        IConfig const\texorpdfstring{$\ast$}{*} full\+Config() const;        Colour\+Mode colour\+Mode() const;        std\+::map$<$std\+::string, std\+::string$>$ const\& custom\+Options() const;    private\+:        Detail\+::unique\+\_\+ptr$<$IStream$>$ m\+\_\+stream;        IConfig const\texorpdfstring{$\ast$}{*} m\+\_\+full\+Config;        Colour\+Mode m\+\_\+colour\+Mode;        std\+::map$<$std\+::string, std\+::string$>$ m\+\_\+custom\+Options;    \};    struct Assertion\+Stats \{        Assertion\+Stats( Assertion\+Result const\& \+\_\+assertion\+Result,                        std\+::vector$<$Message\+Info$>$ const\& \+\_\+info\+Messages,                        Totals const\& \+\_\+totals );        Assertion\+Stats( Assertion\+Stats const\& )              = default;        Assertion\+Stats( Assertion\+Stats \&\& )                  = default;        Assertion\+Stats\& operator = ( Assertion\+Stats const\& ) = delete;        Assertion\+Stats\& operator = ( Assertion\+Stats \&\& )     = delete;        Assertion\+Result assertion\+Result;        std\+::vector$<$Message\+Info$>$ info\+Messages;        Totals totals;    \};    struct Section\+Stats \{        Section\+Stats(   Section\+Info\&\& \+\_\+section\+Info,                        Counts const\& \+\_\+assertions,                        double \+\_\+duration\+In\+Seconds,                        bool \+\_\+missing\+Assertions );        Section\+Info section\+Info;        Counts assertions;        double duration\+In\+Seconds;        bool missing\+Assertions;    \};    struct Test\+Case\+Stats \{        Test\+Case\+Stats(  Test\+Case\+Info const\& \+\_\+test\+Info,                        Totals const\& \+\_\+totals,                        std\+::string\&\& \+\_\+std\+Out,                        std\+::string\&\& \+\_\+std\+Err,                        bool \+\_\+aborting );        Test\+Case\+Info const \texorpdfstring{$\ast$}{*} test\+Info;        Totals totals;        std\+::string std\+Out;        std\+::string std\+Err;        bool aborting;    \};    struct Test\+Run\+Stats \{        Test\+Run\+Stats(   Test\+Run\+Info const\& \+\_\+run\+Info,                        Totals const\& \+\_\+totals,                        bool \+\_\+aborting );        Test\+Run\+Info run\+Info;        Totals totals;        bool aborting;    \};                struct Reporter\+Preferences \{                        bool should\+Redirect\+Std\+Out = false;                        bool should\+Report\+All\+Assertions = false;    \};        class IEvent\+Listener \{    protected\+:                Reporter\+Preferences m\+\_\+preferences;                IConfig const\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}{m\+\_\+config}};    public\+:        IEvent\+Listener( IConfig const\texorpdfstring{$\ast$}{*} config )\+: \mbox{\hyperlink{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}{m\+\_\+config}}( config ) \{\}        virtual \texorpdfstring{$\sim$}{\string~}IEvent\+Listener();                         Reporter\+Preferences const\& get\+Preferences() const \{            return m\+\_\+preferences;        \}                virtual void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) = 0;                virtual void report\+Invalid\+Test\+Spec( String\+Ref invalid\+Argument ) = 0;                virtual void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) = 0;                virtual void test\+Case\+Starting( Test\+Case\+Info const\& test\+Info ) = 0;                virtual void test\+Case\+Partial\+Starting( Test\+Case\+Info const\& test\+Info, uint64\+\_\+t part\+Number ) = 0;                virtual void section\+Starting( Section\+Info const\& section\+Info ) = 0;                virtual void benchmark\+Preparing( String\+Ref benchmark\+Name ) = 0;                virtual void benchmark\+Starting( Benchmark\+Info const\& benchmark\+Info ) = 0;                virtual void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) = 0;                virtual void benchmark\+Failed( String\+Ref benchmark\+Name ) = 0;                virtual void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) = 0;                virtual void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) = 0;                virtual void section\+Ended( Section\+Stats const\& section\+Stats ) = 0;                virtual void test\+Case\+Partial\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats, uint64\+\_\+t part\+Number ) = 0;                virtual void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) = 0;                virtual void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) = 0;                virtual void skip\+Test( Test\+Case\+Info const\& test\+Info ) = 0;                virtual void fatal\+Error\+Encountered( String\+Ref error ) = 0;                virtual void list\+Reporters(std\+::vector$<$Reporter\+Description$>$ const\& descriptions) = 0;                virtual void list\+Listeners(std\+::vector$<$Listener\+Description$>$ const\& descriptions) = 0;                virtual void list\+Tests(std\+::vector$<$Test\+Case\+Handle$>$ const\& tests) = 0;                virtual void list\+Tags(std\+::vector$<$Tag\+Info$>$ const\& tags) = 0;    \};    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;\} \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+FACTORY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+FACTORY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    struct Reporter\+Config;    class IConfig;    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;    class IReporter\+Factory \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}IReporter\+Factory();         virtual IEvent\+Listener\+Ptr        create( Reporter\+Config\&\& config ) const = 0;        virtual std\+::string get\+Description() const = 0;    \};    using IReporter\+Factory\+Ptr = Detail\+::unique\+\_\+ptr$<$IReporter\+Factory$>$;    class Event\+Listener\+Factory \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}Event\+Listener\+Factory();         virtual IEvent\+Listener\+Ptr create( IConfig const\texorpdfstring{$\ast$}{*} config ) const = 0;                virtual String\+Ref get\+Name() const = 0;                virtual std\+::string get\+Description() const = 0;    \};\} \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    struct Tag\+Alias;    class ITag\+Alias\+Registry \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}ITag\+Alias\+Registry();                 virtual Tag\+Alias const\texorpdfstring{$\ast$}{*} find( std\+::string const\& alias ) const = 0;        virtual std\+::string expand\+Aliases( std\+::string const\& unexpanded\+Test\+Spec ) const = 0;        static ITag\+Alias\+Registry const\& get();    \};\} \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+TESTCASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+TESTCASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    struct Test\+Case\+Info;    class Test\+Case\+Handle;    class IConfig;    class ITest\+Case\+Registry \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}ITest\+Case\+Registry();                 virtual std\+::vector$<$Test\+Case\+Info\texorpdfstring{$\ast$}{*} $>$ const\& get\+All\+Infos() const = 0;        virtual std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests() const = 0;        virtual std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests\+Sorted( IConfig const\& config ) const = 0;    \};\}\#endif \#endif \#ifndef CATCH\+\_\+\+CASE\+\_\+\+INSENSITIVE\+\_\+\+COMPARISONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CASE\+\_\+\+INSENSITIVE\+\_\+\+COMPARISONS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    namespace Detail \{                struct Case\+Insensitive\+Less \{            bool operator()( String\+Ref lhs,                             String\+Ref rhs ) const;        \};                struct Case\+Insensitive\+Equal\+To \{            bool operator()( String\+Ref lhs,                             String\+Ref rhs ) const;        \};    \} \} \#endif \#ifndef CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\+\_\+\+HPP\+\_\+\+INCLUDED\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+\+ANDROID\+\_\+\+\_\+)\#    define CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\#endif\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE ) \&\& \textbackslash{}    !defined( CATCH\+\_\+\+CONFIG\+\_\+\+NO\+\_\+\+ANDROID\+\_\+\+LOGWRITE ) \&\&      \textbackslash{}    !defined( CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE )\#    define CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\#endif\#endif \#ifndef CATCH\+\_\+\+CONFIG\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONFIG\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDED\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+MSC\+\_\+\+VER)\#  \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} \+\_\+\+MSC\+\_\+\+VER $>$= 1900 \#    define CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\#  endif\#endif\#include $<$exception$>$\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+cpp\+\_\+lib\+\_\+uncaught\+\_\+exceptions) \textbackslash{}    \&\& !defined(CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS)\#  define CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\#endif \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS) \textbackslash{}    \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+NO\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS) \textbackslash{}    \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS)\#  define CATCH\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\#endif\#endif \#ifndef CATCH\+\_\+\+CONSOLE\+\_\+\+COLOUR\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONSOLE\+\_\+\+COLOUR\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$cstdint$>$namespace Catch \{    enum class Colour\+Mode \+: std\+::uint8\+\_\+t;    class IStream;    struct Colour \{        enum Code \{            None = 0,            White,            Red,            Green,            Blue,            Cyan,            Yellow,            Grey,            Bright = 0x10,            Bright\+Red = Bright \texorpdfstring{$\vert$}{|} Red,            Bright\+Green = Bright \texorpdfstring{$\vert$}{|} Green,            Light\+Grey = Bright \texorpdfstring{$\vert$}{|} Grey,            Bright\+White = Bright \texorpdfstring{$\vert$}{|} White,            Bright\+Yellow = Bright \texorpdfstring{$\vert$}{|} Yellow,                        File\+Name = Light\+Grey,            Warning = Bright\+Yellow,            Result\+Error = Bright\+Red,            Result\+Success = Bright\+Green,            Result\+Expected\+Failure = Warning,            Error = Bright\+Red,            Success = Green,            Skip = Light\+Grey,            Original\+Expression = Cyan,            Reconstructed\+Expression = Bright\+Yellow,            Secondary\+Text = Light\+Grey,            Headers = White        \};    \};    class Colour\+Impl \{    protected\+:                IStream\texorpdfstring{$\ast$}{*} m\+\_\+stream;    public\+:        Colour\+Impl( IStream\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} )\+: m\+\_\+stream( \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} ) \{\}                        class Colour\+Guard \{            Colour\+Impl const\texorpdfstring{$\ast$}{*} m\+\_\+colour\+Impl;            Colour\+::\+Code m\+\_\+code;            bool m\+\_\+engaged = false;        public\+:                        Colour\+Guard( Colour\+::\+Code code,                         Colour\+Impl const\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_a5f5de53ffd2c7aad35b1140210ffe6cf}{colour}} );            Colour\+Guard( Colour\+Guard const\& rhs ) = delete;            Colour\+Guard\& operator=( Colour\+Guard const\& rhs ) = delete;            Colour\+Guard( Colour\+Guard\&\& rhs ) noexcept;            Colour\+Guard\& operator=( Colour\+Guard\&\& rhs ) noexcept;                        \texorpdfstring{$\sim$}{\string~}Colour\+Guard();                        Colour\+Guard\& engage( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} ) \&;                        Colour\+Guard\&\& engage( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} ) \&\&;        private\+:                        friend std\+::ostream\& operator$<$$<$( std\+::ostream\& lhs,                                             Colour\+Guard\& guard ) \{                guard.\+engage\+Impl( lhs );                return lhs;            \}                        friend std\+::ostream\& operator$<$$<$( std\+::ostream\& lhs,                                            Colour\+Guard\&\& guard) \{                guard.\+engage\+Impl( lhs );                return lhs;            \}            void engage\+Impl( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} );        \};        virtual \texorpdfstring{$\sim$}{\string~}Colour\+Impl();                 Colour\+Guard guard\+Colour( Colour\+::\+Code colour\+Code );    private\+:        virtual void use( Colour\+::\+Code colour\+Code ) const = 0;    \};        Detail\+::unique\+\_\+ptr$<$Colour\+Impl$>$ make\+Colour\+Impl( Colour\+Mode colour\+Selection,                                                   IStream\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} );        bool is\+Colour\+Impl\+Available( Colour\+Mode colour\+Selection );\} \#endif \#ifndef CATCH\+\_\+\+CONSOLE\+\_\+\+WIDTH\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONSOLE\+\_\+\+WIDTH\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+CONFIG\+\_\+\+CONSOLE\+\_\+\+WIDTH\#define CATCH\+\_\+\+CONFIG\+\_\+\+CONSOLE\+\_\+\+WIDTH 80\#endif\#endif \#ifndef CATCH\+\_\+\+CONTAINER\+\_\+\+NONMEMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONTAINER\+\_\+\+NONMEMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstddef$>$\#include $<$initializer\+\_\+list$>$\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CPP17\+\_\+\+OR\+\_\+\+GREATER) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+MSC\+\_\+\+VER)\#include $<$string$>$\#  \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(\+\_\+\+\_\+cpp\+\_\+lib\+\_\+nonmember\+\_\+container\+\_\+access)\#      define CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS\#  endif\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}\#define CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS\#endifnamespace Catch \{namespace Detail \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)    template $<$typename Container$>$    constexpr auto empty(Container const\& cont) -\/$>$ decltype(cont.\+empty()) \{        return cont.\+empty();    \}    template $<$typename T, std\+::size\+\_\+t N$>$    constexpr bool empty(const T (\&)\mbox{[}N\mbox{]}) noexcept \{                        (void)N;        return false;    \}    template $<$typename T$>$    constexpr bool empty(std\+::initializer\+\_\+list$<$T$>$ list) noexcept \{        return list.\+size() $>$ 0;    \}    template $<$typename Container$>$    constexpr auto size(Container const\& cont) -\/$>$ decltype(cont.\+size()) \{        return cont.\+size();    \}    template $<$typename T, std\+::size\+\_\+t N$>$    constexpr std\+::size\+\_\+t size(const T(\&)\mbox{[}N\mbox{]}) noexcept \{        return N;    \}\#endif \} \} \#endif \#ifndef CATCH\+\_\+\+DEBUG\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+DEBUG\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    void write\+To\+Debug\+Console( std\+::string const\& text );\}\#endif \#ifndef CATCH\+\_\+\+DEBUGGER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+DEBUGGER\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    bool is\+Debugger\+Active();\}\#ifdef CATCH\+\_\+\+PLATFORM\+\_\+\+MAC    \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+i386\+\_\+\+\_\+) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+\_\+x86\+\_\+64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+asm\+\_\+\+\_\+("{}int \$3\textbackslash{}n"{} \+: \+: )     \#elif defined(\+\_\+\+\_\+aarch64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xd43e0000"{})    \#elif defined(\+\_\+\+\_\+\+POWERPC\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+asm\+\_\+\+\_\+("{}li r0, 20\textbackslash{}nsc\textbackslash{}nnop\textbackslash{}nli r0, 37\textbackslash{}nli r4, 2\textbackslash{}nsc\textbackslash{}nnop\textbackslash{}n"{} \textbackslash{}        \+: \+: \+: "{}memory"{},"{}r0"{},"{}r3"{},"{}r4"{} )     \#endif\#elif defined(CATCH\+\_\+\+PLATFORM\+\_\+\+IPHONE)        \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+i386\+\_\+\+\_\+) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+\_\+x86\+\_\+64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}int \$3"{})    \#elif defined(\+\_\+\+\_\+aarch64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xd4200000"{})    \#elif defined(\+\_\+\+\_\+arm\+\_\+\+\_\+) \&\& !defined(\+\_\+\+\_\+thumb\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xe7f001f0"{})    \#elif defined(\+\_\+\+\_\+arm\+\_\+\+\_\+) \&\&  defined(\+\_\+\+\_\+thumb\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xde01"{})    \#endif\#elif defined(CATCH\+\_\+\+PLATFORM\+\_\+\+LINUX)                \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+\+GNUC\+\_\+\+\_\+) \&\& (defined(\+\_\+\+\_\+i386) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+\_\+x86\+\_\+64))        \#define CATCH\+\_\+\+TRAP() asm volatile ("{}int \$3"{})     \#else         \#include $<$signal.\+h$>$        \#define CATCH\+\_\+\+TRAP() raise(SIGTRAP)    \#endif\#elif defined(\+\_\+\+MSC\+\_\+\+VER)    \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+debugbreak()\#elif defined(\+\_\+\+\_\+\+MINGW32\+\_\+\+\_\+)    extern "{}C"{} \+\_\+\+\_\+declspec(dllimport) void \+\_\+\+\_\+stdcall Debug\+Break();    \#define CATCH\+\_\+\+TRAP() Debug\+Break()\#endif\#ifndef CATCH\+\_\+\+BREAK\+\_\+\+INTO\+\_\+\+DEBUGGER    \#ifdef CATCH\+\_\+\+TRAP        \#define CATCH\+\_\+\+BREAK\+\_\+\+INTO\+\_\+\+DEBUGGER() \mbox{[}$\,$\mbox{]}\{ \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( \mbox{\hyperlink{namespace_catch_ab079497368fb1df25af39ad494d2a241}{Catch\+::is\+Debugger\+Active}}() ) \{ CATCH\+\_\+\+TRAP(); \} \}()    \#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}        \#define CATCH\+\_\+\+BREAK\+\_\+\+INTO\+\_\+\+DEBUGGER() \mbox{[}$\,$\mbox{]}\{\}()    \#endif\#endif\#endif \#ifndef CATCH\+\_\+\+ENFORCE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ENFORCE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$exception$>$namespace Catch \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(\mbox{\hyperlink{catch__amalgamated_8hpp_a893712b2ba6e7400136a0a023b12e9db}{CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\+\_\+\+EXCEPTIONS}})    template $<$typename Ex$>$    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+exception(Ex const\& e) \{        throw e;    \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}     \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+exception(std\+::exception const\& e);\#endif    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+logic\+\_\+error(std\+::string const\& msg);    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+domain\+\_\+error(std\+::string const\& msg);    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+runtime\+\_\+error(std\+::string const\& msg);\} \#define CATCH\+\_\+\+MAKE\+\_\+\+MSG(...) \textbackslash{}    (\mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{Catch\+::\+Reusable\+String\+Stream}}() $<$$<$ \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+).str()\#define CATCH\+\_\+\+INTERNAL\+\_\+\+ERROR(...) \textbackslash{}    \mbox{\hyperlink{namespace_catch_a707884e681203fef6bf7dbf752532fa5}{Catch\+::throw\+\_\+logic\+\_\+error}}(CATCH\+\_\+\+MAKE\+\_\+\+MSG( \mbox{\hyperlink{catch__amalgamated_8hpp_abc0b2405454c51748a31e0393d9ad5d1}{CATCH\+\_\+\+INTERNAL\+\_\+\+LINEINFO}} $<$$<$ "{}\+: Internal Catch2 error\+: "{} $<$$<$ \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+))\#define CATCH\+\_\+\+ERROR(...) \textbackslash{}    \mbox{\hyperlink{namespace_catch_ae67297c3e265b0fcd55de371bf408e4e}{Catch\+::throw\+\_\+domain\+\_\+error}}(CATCH\+\_\+\+MAKE\+\_\+\+MSG( \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ))\#define CATCH\+\_\+\+RUNTIME\+\_\+\+ERROR(...) \textbackslash{}    \mbox{\hyperlink{namespace_catch_a48d2c35022dd9d56a1b7ee78ad581eea}{Catch\+::throw\+\_\+runtime\+\_\+error}}(CATCH\+\_\+\+MAKE\+\_\+\+MSG( \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ))\#define CATCH\+\_\+\+ENFORCE( condition, ... ) \textbackslash{}    do\{ \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( !(condition) ) CATCH\+\_\+\+ERROR( \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ); \} while(false)\#endif \#ifndef CATCH\+\_\+\+ENUM\+\_\+\+VALUES\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ENUM\+\_\+\+VALUES\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    namespace Detail \{        \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$Enum\+Info$>$ make\+Enum\+Info( String\+Ref enum\+Name, String\+Ref all\+Value\+Names, std\+::vector$<$int$>$ const\& values );        class Enum\+Values\+Registry \+: public IMutable\+Enum\+Values\+Registry \{            std\+::vector$<$\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$Enum\+Info$>$$>$ m\+\_\+enum\+Infos;            Enum\+Info const\& register\+Enum( String\+Ref enum\+Name, String\+Ref all\+Value\+Names, std\+::vector$<$int$>$ const\& values) override;        \};        std\+::vector$<$String\+Ref$>$ parse\+Enums( String\+Ref enums );    \} \} \#endif \#ifndef CATCH\+\_\+\+ERRNO\+\_\+\+GUARD\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ERRNO\+\_\+\+GUARD\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{            class Errno\+Guard \{    public\+:                Errno\+Guard();        \texorpdfstring{$\sim$}{\string~}Errno\+Guard();    private\+:        int m\+\_\+old\+Errno;    \};\}\#endif \#ifndef CATCH\+\_\+\+EXCEPTION\+\_\+\+TRANSLATOR\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+EXCEPTION\+\_\+\+TRANSLATOR\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$\#include $<$string$>$namespace Catch \{    class Exception\+Translator\+Registry \+: public IException\+Translator\+Registry \{    public\+:        \texorpdfstring{$\sim$}{\string~}Exception\+Translator\+Registry() override;        void register\+Translator( Detail\+::unique\+\_\+ptr$<$IException\+Translator$>$\&\& translator );        std\+::string translate\+Active\+Exception() const override;    private\+:        Exception\+Translators m\+\_\+translators;    \};\}\#endif \#ifndef CATCH\+\_\+\+FATAL\+\_\+\+CONDITION\+\_\+\+HANDLER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+FATAL\+\_\+\+CONDITION\+\_\+\+HANDLER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$namespace Catch \{        class Fatal\+Condition\+Handler \{        bool m\+\_\+started = false;                                void engage\+\_\+platform();        void disengage\+\_\+platform() noexcept;    public\+:                Fatal\+Condition\+Handler();        \texorpdfstring{$\sim$}{\string~}Fatal\+Condition\+Handler();        void engage() \{            assert(!m\+\_\+started \&\& "{}Handler cannot be installed twice."{});            m\+\_\+started = true;            engage\+\_\+platform();        \}        void disengage() noexcept \{            assert(m\+\_\+started \&\& "{}Handler cannot be uninstalled without being installed first"{});            m\+\_\+started = false;            disengage\+\_\+platform();        \}    \};        class Fatal\+Condition\+Handler\+Guard \{        Fatal\+Condition\+Handler\texorpdfstring{$\ast$}{*} m\+\_\+handler;    public\+:        Fatal\+Condition\+Handler\+Guard(Fatal\+Condition\+Handler\texorpdfstring{$\ast$}{*} handler)\+:            m\+\_\+handler(handler) \{            m\+\_\+handler-\/$>$engage();        \}        \texorpdfstring{$\sim$}{\string~}Fatal\+Condition\+Handler\+Guard() \{            m\+\_\+handler-\/$>$disengage();        \}    \};\} \#endif \#ifndef CATCH\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$\#include $<$cmath$>$\#include $<$cstdint$>$\#include $<$utility$>$\#include $<$limits$>$namespace Catch \{    namespace Detail \{        uint32\+\_\+t convert\+To\+Bits(float f);        uint64\+\_\+t convert\+To\+Bits(double d);                        bool direct\+Compare( float lhs, float rhs );        bool direct\+Compare( double lhs, double rhs );    \} \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic push            \#    pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}\#endif        template $<$typename FP$>$    uint64\+\_\+t ulp\+Distance( FP lhs, FP rhs ) \{        assert( std\+::numeric\+\_\+limits$<$FP$>$\+::is\+\_\+iec559 \&\&            "{}ulp\+Distance assumes IEEE-\/754 format for floating point types"{} );        assert( !\mbox{\hyperlink{namespace_catch_aff37796f0f578c2816f74267e641c5f7}{Catch\+::isnan}}( lhs ) \&\&                "{}Distance between NaN and number is not meaningful"{} );        assert( !\mbox{\hyperlink{namespace_catch_aff37796f0f578c2816f74267e641c5f7}{Catch\+::isnan}}( rhs ) \&\&                "{}Distance between NaN and number is not meaningful"{} );                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs == rhs ) \{ return 0; \}                static constexpr FP positive\+\_\+zero\{\};                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs == positive\+\_\+zero ) \{ lhs = positive\+\_\+zero; \}        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( rhs == positive\+\_\+zero ) \{ rhs = positive\+\_\+zero; \}                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( std\+::signbit( lhs ) != std\+::signbit( rhs ) ) \{            return ulp\+Distance( std\+::abs( lhs ), positive\+\_\+zero ) +                   ulp\+Distance( std\+::abs( rhs ), positive\+\_\+zero );        \}                                uint64\+\_\+t lc = Detail\+::convert\+To\+Bits( lhs );        uint64\+\_\+t rc = Detail\+::convert\+To\+Bits( rhs );                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lc $<$ rc ) \{            std\+::swap( lc, rc );        \}        return lc -\/ rc;    \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic pop\#endif\} \#endif \#ifndef CATCH\+\_\+\+GETENV\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+GETENV\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{namespace Detail \{        char const\texorpdfstring{$\ast$}{*} get\+Env(char const\texorpdfstring{$\ast$}{*} var\+Name);\}\}\#endif \#ifndef CATCH\+\_\+\+IS\+\_\+\+PERMUTATION\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+IS\+\_\+\+PERMUTATION\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$\#include $<$iterator$>$namespace Catch \{    namespace Detail \{        template $<$typename Forward\+Iter,                  typename Sentinel,                  typename T,                  typename Comparator$>$        Forward\+Iter find\+\_\+sentinel( Forward\+Iter start,                                   Sentinel sentinel,                                   T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}},                                   Comparator cmp ) \{            while ( start != sentinel ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( cmp( \texorpdfstring{$\ast$}{*}start, \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) ) \{ break; \}                ++start;            \}            return start;        \}        template $<$typename Forward\+Iter,                  typename Sentinel,                  typename T,                  typename Comparator$>$        std\+::ptrdiff\+\_\+t count\+\_\+sentinel( Forward\+Iter start,                                       Sentinel sentinel,                                       T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}},                                       Comparator cmp ) \{            std\+::ptrdiff\+\_\+t count = 0;            while ( start != sentinel ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( cmp( \texorpdfstring{$\ast$}{*}start, \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) ) \{ ++count; \}                ++start;            \}            return count;        \}        template $<$typename Forward\+Iter, typename Sentinel$>$        std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same$<$Forward\+Iter, Sentinel$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                         std\+::ptrdiff\+\_\+t$>$        sentinel\+\_\+distance( Forward\+Iter iter, const Sentinel sentinel ) \{            std\+::ptrdiff\+\_\+t dist = 0;            while ( iter != sentinel ) \{                ++iter;                ++dist;            \}            return dist;        \}        template $<$typename Forward\+Iter$>$        std\+::ptrdiff\+\_\+t sentinel\+\_\+distance( Forward\+Iter first,                                          Forward\+Iter last ) \{            return std\+::distance( first, last );        \}        template $<$typename Forward\+Iter1,                  typename Sentinel1,                  typename Forward\+Iter2,                  typename Sentinel2,                  typename Comparator$>$        bool check\+\_\+element\+\_\+counts( Forward\+Iter1 first\+\_\+1,                                   const Sentinel1 end\+\_\+1,                                   Forward\+Iter2 first\+\_\+2,                                   const Sentinel2 end\+\_\+2,                                   Comparator cmp ) \{            auto cursor = first\+\_\+1;            while ( cursor != end\+\_\+1 ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( find\+\_\+sentinel( first\+\_\+1, cursor, \texorpdfstring{$\ast$}{*}cursor, cmp ) ==                     cursor ) \{                                        const auto count\+\_\+in\+\_\+range\+\_\+2 =                        count\+\_\+sentinel( first\+\_\+2, end\+\_\+2, \texorpdfstring{$\ast$}{*}cursor, cmp );                                                            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( count\+\_\+in\+\_\+range\+\_\+2 == 0 ) \{ return false; \}                    const auto count\+\_\+in\+\_\+range\+\_\+1 =                        count\+\_\+sentinel( cursor, end\+\_\+1, \texorpdfstring{$\ast$}{*}cursor, cmp );                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( count\+\_\+in\+\_\+range\+\_\+1 != count\+\_\+in\+\_\+range\+\_\+2 ) \{                        return false;                    \}                \}                ++cursor;            \}            return true;        \}        template $<$typename Forward\+Iter1,                  typename Sentinel1,                  typename Forward\+Iter2,                  typename Sentinel2,                  typename Comparator$>$        bool is\+\_\+permutation( Forward\+Iter1 first\+\_\+1,                             const Sentinel1 end\+\_\+1,                             Forward\+Iter2 first\+\_\+2,                             const Sentinel2 end\+\_\+2,                             Comparator cmp ) \{                                                while (first\+\_\+1 != end\+\_\+1 \&\& first\+\_\+2 != end\+\_\+2 \&\& cmp(\texorpdfstring{$\ast$}{*}first\+\_\+1, \texorpdfstring{$\ast$}{*}first\+\_\+2)) \{                ++first\+\_\+1;                ++first\+\_\+2;            \}                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (first\+\_\+1 == end\+\_\+1 \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} first\+\_\+2 == end\+\_\+2) \{                return first\+\_\+1 == end\+\_\+1 \&\& first\+\_\+2 == end\+\_\+2;            \}                        auto dist\+\_\+1 = sentinel\+\_\+distance( first\+\_\+1, end\+\_\+1 );            auto dist\+\_\+2 = sentinel\+\_\+distance( first\+\_\+2, end\+\_\+2 );            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (dist\+\_\+1 != dist\+\_\+2) \{ return false; \}                                                return check\+\_\+element\+\_\+counts( first\+\_\+1, end\+\_\+1, first\+\_\+2, end\+\_\+2, cmp );        \}    \} \} \#endif \#ifndef CATCH\+\_\+\+ISTREAM\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ISTREAM\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$cstddef$>$\#include $<$ostream$>$\#include $<$string$>$namespace Catch \{    class IStream \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}IStream();         virtual std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}}() = 0;                virtual bool is\+Console() const \{ return false; \}    \};        auto make\+Stream( std\+::string const\& filename ) -\/$>$ Detail\+::unique\+\_\+ptr$<$IStream$>$;\}\#endif \#ifndef CATCH\+\_\+\+JSONWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+JSONWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdint$>$\#include $<$sstream$>$namespace Catch \{    class Json\+Object\+Writer;    class Json\+Array\+Writer;    struct Json\+Utils \{        static void indent( std\+::ostream\& os, std\+::uint64\+\_\+t level );        static void append\+Comma\+Newline( std\+::ostream\& os,                                        bool\& should\+\_\+comma,                                        std\+::uint64\+\_\+t level );    \};    class Json\+Value\+Writer \{    public\+:        Json\+Value\+Writer( std\+::ostream\& os );        Json\+Value\+Writer( std\+::ostream\& os, std\+::uint64\+\_\+t indent\+\_\+level );        Json\+Object\+Writer write\+Object() \&\&;        Json\+Array\+Writer write\+Array() \&\&;        template $<$typename T$>$        void write( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \&\& \{            write\+Impl( \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}, !std\+::is\+\_\+arithmetic$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}} );        \}        void write( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \&\&;        void write( bool \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \&\&;    private\+:        void write\+Impl( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}, bool quote );                                        template $<$typename T,                  typename = typename std\+::enable\+\_\+if\+\_\+t$<$                      !std\+::is\+\_\+convertible$<$T, String\+Ref$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        void write\+Impl( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}, bool quote\+\_\+value ) \{            m\+\_\+sstream $<$$<$ \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}};            write\+Impl( m\+\_\+sstream.\+str(), quote\+\_\+value );        \}        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};        std\+::stringstream m\+\_\+sstream;        std\+::uint64\+\_\+t m\+\_\+indent\+\_\+level;    \};    class Json\+Object\+Writer \{    public\+:        Json\+Object\+Writer( std\+::ostream\& os );        Json\+Object\+Writer( std\+::ostream\& os, std\+::uint64\+\_\+t indent\+\_\+level );        Json\+Object\+Writer( Json\+Object\+Writer\&\& source ) noexcept;        Json\+Object\+Writer\& operator=( Json\+Object\+Writer\&\& source ) = delete;        \texorpdfstring{$\sim$}{\string~}Json\+Object\+Writer();        Json\+Value\+Writer write( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}{key}} );    private\+:        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};        std\+::uint64\+\_\+t m\+\_\+indent\+\_\+level;        bool m\+\_\+should\+\_\+comma = false;        bool m\+\_\+active = true;    \};    class Json\+Array\+Writer \{    public\+:        Json\+Array\+Writer( std\+::ostream\& os );        Json\+Array\+Writer( std\+::ostream\& os, std\+::uint64\+\_\+t indent\+\_\+level );        Json\+Array\+Writer( Json\+Array\+Writer\&\& source ) noexcept;        Json\+Array\+Writer\& operator=( Json\+Array\+Writer\&\& source ) = delete;        \texorpdfstring{$\sim$}{\string~}Json\+Array\+Writer();        Json\+Object\+Writer write\+Object();        Json\+Array\+Writer write\+Array();        template $<$typename T$>$        Json\+Array\+Writer\& write( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \{            return write\+Impl( \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );        \}        Json\+Array\+Writer\& write( bool \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );    private\+:        template $<$typename T$>$        Json\+Array\+Writer\& write\+Impl( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \{            Json\+Utils\+::append\+Comma\+Newline(                \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}}, m\+\_\+should\+\_\+comma, m\+\_\+indent\+\_\+level + 1 );            Json\+Value\+Writer\{ \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}} \}.write( \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );            return \texorpdfstring{$\ast$}{*}this;        \}        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};        std\+::uint64\+\_\+t m\+\_\+indent\+\_\+level;        bool m\+\_\+should\+\_\+comma = false;        bool m\+\_\+active = true;    \};\} \#endif \#ifndef CATCH\+\_\+\+LEAK\+\_\+\+DETECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+LEAK\+\_\+\+DETECTOR\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    struct Leak\+Detector \{        Leak\+Detector();        \texorpdfstring{$\sim$}{\string~}Leak\+Detector();    \};\}\#endif \#ifndef CATCH\+\_\+\+LIST\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+LIST\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$set$>$\#include $<$string$>$namespace Catch \{    class IEvent\+Listener;    class Config;    struct Reporter\+Description \{        std\+::string name, description;    \};    struct Listener\+Description \{        String\+Ref name;        std\+::string description;    \};    struct Tag\+Info \{        void add(String\+Ref spelling);        std\+::string all() const;        std\+::set$<$String\+Ref$>$ spellings;        std\+::size\+\_\+t count = 0;    \};    bool list( IEvent\+Listener\& reporter, Config const\& config );\} \#endif \#ifndef CATCH\+\_\+\+OUTPUT\+\_\+\+REDIRECT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+OUTPUT\+\_\+\+REDIRECT\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdio$>$\#include $<$iosfwd$>$\#include $<$string$>$namespace Catch \{    class Redirected\+Stream \{        std\+::ostream\& m\+\_\+original\+Stream;        std\+::ostream\& m\+\_\+redirection\+Stream;        std\+::streambuf\texorpdfstring{$\ast$}{*} m\+\_\+prev\+Buf;    public\+:        Redirected\+Stream( std\+::ostream\& original\+Stream, std\+::ostream\& redirection\+Stream );        \texorpdfstring{$\sim$}{\string~}Redirected\+Stream();    \};    class Redirected\+Std\+Out \{        Reusable\+String\+Stream m\+\_\+rss;        Redirected\+Stream m\+\_\+cout;    public\+:        Redirected\+Std\+Out();        auto str() const -\/$>$ std\+::string;    \};                class Redirected\+Std\+Err \{        Reusable\+String\+Stream m\+\_\+rss;        Redirected\+Stream m\+\_\+cerr;        Redirected\+Stream m\+\_\+clog;    public\+:        Redirected\+Std\+Err();        auto str() const -\/$>$ std\+::string;    \};    class Redirected\+Streams \{    public\+:        Redirected\+Streams(Redirected\+Streams const\&) = delete;        Redirected\+Streams\& operator=(Redirected\+Streams const\&) = delete;        Redirected\+Streams(Redirected\+Streams\&\&) = delete;        Redirected\+Streams\& operator=(Redirected\+Streams\&\&) = delete;        Redirected\+Streams(std\+::string\& redirected\+Cout, std\+::string\& redirected\+Cerr);        \texorpdfstring{$\sim$}{\string~}Redirected\+Streams();    private\+:        std\+::string\& m\+\_\+redirected\+Cout;        std\+::string\& m\+\_\+redirected\+Cerr;        Redirected\+Std\+Out m\+\_\+redirected\+Std\+Out;        Redirected\+Std\+Err m\+\_\+redirected\+Std\+Err;    \};\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+NEW\+\_\+\+CAPTURE)                    class Temp\+File \{    public\+:        Temp\+File(Temp\+File const\&) = delete;        Temp\+File\& operator=(Temp\+File const\&) = delete;        Temp\+File(Temp\+File\&\&) = delete;        Temp\+File\& operator=(Temp\+File\&\&) = delete;        Temp\+File();        \texorpdfstring{$\sim$}{\string~}Temp\+File();        std\+::\+FILE\texorpdfstring{$\ast$}{*} get\+File();        std\+::string get\+Contents();    private\+:        std\+::\+FILE\texorpdfstring{$\ast$}{*} m\+\_\+file = nullptr;    \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+MSC\+\_\+\+VER)        char m\+\_\+buffer\mbox{[}L\+\_\+tmpnam\mbox{]} = \{ 0 \};    \#endif    \};    class Output\+Redirect \{    public\+:        Output\+Redirect(Output\+Redirect const\&) = delete;        Output\+Redirect\& operator=(Output\+Redirect const\&) = delete;        Output\+Redirect(Output\+Redirect\&\&) = delete;        Output\+Redirect\& operator=(Output\+Redirect\&\&) = delete;        Output\+Redirect(std\+::string\& stdout\+\_\+dest, std\+::string\& stderr\+\_\+dest);        \texorpdfstring{$\sim$}{\string~}Output\+Redirect();    private\+:        int m\+\_\+original\+Stdout = -\/1;        int m\+\_\+original\+Stderr = -\/1;        Temp\+File m\+\_\+stdout\+File;        Temp\+File m\+\_\+stderr\+File;        std\+::string\& m\+\_\+stdout\+Dest;        std\+::string\& m\+\_\+stderr\+Dest;    \};\#endif\} \#endif \#ifndef CATCH\+\_\+\+PARSE\+\_\+\+NUMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+PARSE\+\_\+\+NUMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{        Optional$<$unsigned int$>$ parse\+UInt(std\+::string const\& input, int base = 10);\}\#endif \#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$map$>$\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;    class IReporter\+Factory;    using IReporter\+Factory\+Ptr = Detail\+::unique\+\_\+ptr$<$IReporter\+Factory$>$;    struct Reporter\+Config;    class Event\+Listener\+Factory;    class Reporter\+Registry \{        struct Reporter\+Registry\+Impl;        Detail\+::unique\+\_\+ptr$<$Reporter\+Registry\+Impl$>$ m\+\_\+impl;    public\+:        Reporter\+Registry();        \texorpdfstring{$\sim$}{\string~}Reporter\+Registry();         IEvent\+Listener\+Ptr create( std\+::string const\& name,                                  Reporter\+Config\&\& config ) const;        void register\+Reporter( std\+::string const\& name,                               IReporter\+Factory\+Ptr factory );        void        register\+Listener( Detail\+::unique\+\_\+ptr$<$Event\+Listener\+Factory$>$ factory );        std\+::map$<$std\+::string,                 IReporter\+Factory\+Ptr,                 Detail\+::\+Case\+Insensitive\+Less$>$ const\&        get\+Factories() const;        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Event\+Listener\+Factory$>$$>$ const\&        get\+Listeners() const;    \};\} \#endif \#ifndef CATCH\+\_\+\+RUN\+\_\+\+CONTEXT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+RUN\+\_\+\+CONTEXT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+TRACKER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+TRACKER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$\#include $<$vector$>$namespace Catch \{namespace Test\+Case\+Tracking \{    struct Name\+And\+Location \{        std\+::string name;        Source\+Line\+Info location;        Name\+And\+Location( std\+::string\&\& \+\_\+name, Source\+Line\+Info const\& \+\_\+location );        friend bool operator==(Name\+And\+Location const\& lhs, Name\+And\+Location const\& rhs) \{                                                            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs.\+location.\+line != rhs.\+location.\+line ) \{ return false; \}            return lhs.\+name == rhs.\+name \&\& lhs.\+location == rhs.\+location;        \}        friend bool operator!=(Name\+And\+Location const\& lhs,                               Name\+And\+Location const\& rhs) \{            return !( lhs == rhs );        \}    \};        struct Name\+And\+Location\+Ref \{        String\+Ref name;        Source\+Line\+Info location;        constexpr Name\+And\+Location\+Ref( String\+Ref name\+\_\+,                                      Source\+Line\+Info location\+\_\+ )\+:            name( name\+\_\+ ), location( location\+\_\+ ) \{\}        friend bool operator==( Name\+And\+Location const\& lhs,                                Name\+And\+Location\+Ref const\& rhs ) \{                                                            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs.\+location.\+line != rhs.\+location.\+line ) \{ return false; \}            return String\+Ref( lhs.\+name ) == rhs.\+name \&\&                   lhs.\+location == rhs.\+location;        \}        friend bool operator==( Name\+And\+Location\+Ref const\& lhs,                                Name\+And\+Location const\& rhs ) \{            return rhs == lhs;        \}    \};    class ITracker;    using ITracker\+Ptr = \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$ITracker$>$;    class ITracker \{        Name\+And\+Location m\+\_\+name\+And\+Location;        using Children = std\+::vector$<$ITracker\+Ptr$>$;    protected\+:        enum Cycle\+State \{            Not\+Started,            Executing,            Executing\+Children,            Needs\+Another\+Run,            Completed\+Successfully,            Failed        \};        ITracker\texorpdfstring{$\ast$}{*} m\+\_\+parent = nullptr;        Children m\+\_\+children;        Cycle\+State m\+\_\+run\+State = Not\+Started;    public\+:        ITracker( Name\+And\+Location\&\& name\+And\+Loc, ITracker\texorpdfstring{$\ast$}{*} parent )\+:            m\+\_\+name\+And\+Location( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(name\+And\+Loc) ),            m\+\_\+parent( parent )        \{\}                Name\+And\+Location const\& name\+And\+Location() const \{            return m\+\_\+name\+And\+Location;        \}        ITracker\texorpdfstring{$\ast$}{*} parent() const \{            return m\+\_\+parent;        \}        virtual \texorpdfstring{$\sim$}{\string~}ITracker();                         virtual bool is\+Complete() const = 0;                bool is\+Successfully\+Completed() const \{            return m\+\_\+run\+State == Completed\+Successfully;        \}                bool is\+Open() const;                bool has\+Started() const;                virtual void close() = 0;         virtual void fail() = 0;        void mark\+As\+Needing\+Another\+Run();                void add\+Child( ITracker\+Ptr\&\& child );                ITracker\texorpdfstring{$\ast$}{*} find\+Child( Name\+And\+Location\+Ref const\& name\+And\+Location );                bool has\+Children() const \{            return !m\+\_\+children.\+empty();        \}                void open\+Child();                virtual bool is\+Section\+Tracker() const;                virtual bool is\+Generator\+Tracker() const;    \};    class Tracker\+Context \{        enum Run\+State \{            Not\+Started,            Executing,            Completed\+Cycle        \};        ITracker\+Ptr m\+\_\+root\+Tracker;        ITracker\texorpdfstring{$\ast$}{*} m\+\_\+current\+Tracker = nullptr;        Run\+State m\+\_\+run\+State = Not\+Started;    public\+:        ITracker\& start\+Run();        void start\+Cycle() \{            m\+\_\+current\+Tracker = m\+\_\+root\+Tracker.\+get();            m\+\_\+run\+State = Executing;        \}        void complete\+Cycle();        bool completed\+Cycle() const;        ITracker\& current\+Tracker() \{ return \texorpdfstring{$\ast$}{*}m\+\_\+current\+Tracker; \}        void set\+Current\+Tracker( ITracker\texorpdfstring{$\ast$}{*} tracker );    \};    class Tracker\+Base \+: public ITracker \{    protected\+:        Tracker\+Context\& m\+\_\+ctx;    public\+:        Tracker\+Base( Name\+And\+Location\&\& name\+And\+Location, Tracker\+Context\& ctx, ITracker\texorpdfstring{$\ast$}{*} parent );        bool is\+Complete() const override;        void open();        void close() override;        void fail() override;    private\+:        void move\+To\+Parent();        void move\+To\+This();    \};    class Section\+Tracker \+: public Tracker\+Base \{        std\+::vector$<$String\+Ref$>$ m\+\_\+filters;                                        String\+Ref m\+\_\+trimmed\+\_\+name;    public\+:        Section\+Tracker( Name\+And\+Location\&\& name\+And\+Location, Tracker\+Context\& ctx, ITracker\texorpdfstring{$\ast$}{*} parent );        bool is\+Section\+Tracker() const override;        bool is\+Complete() const override;        static Section\+Tracker\& acquire( Tracker\+Context\& ctx, Name\+And\+Location\+Ref const\& name\+And\+Location );        void try\+Open();        void add\+Initial\+Filters( std\+::vector$<$std\+::string$>$ const\& filters );        void add\+Next\+Filters( std\+::vector$<$String\+Ref$>$ const\& filters );                std\+::vector$<$String\+Ref$>$ const\& get\+Filters() const \{ return m\+\_\+filters; \}                String\+Ref trimmed\+Name() const;    \};\} using Test\+Case\+Tracking\+::\+ITracker;using Test\+Case\+Tracking\+::\+Tracker\+Context;using Test\+Case\+Tracking\+::\+Section\+Tracker;\} \#endif \#include $<$string$>$namespace Catch \{    class IGenerator\+Tracker;    class IConfig;    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;        class Run\+Context final \+: public IResult\+Capture \{    public\+:        Run\+Context( Run\+Context const\& ) = delete;        Run\+Context\& operator =( Run\+Context const\& ) = delete;        explicit Run\+Context( IConfig const\texorpdfstring{$\ast$}{*} \+\_\+config, IEvent\+Listener\+Ptr\&\& reporter );        \texorpdfstring{$\sim$}{\string~}Run\+Context() override;        Totals run\+Test(Test\+Case\+Handle const\& test\+Case);    public\+:                 void handle\+Expr                (   Assertion\+Info const\& info,                    ITransient\+Expression const\& expr,                    Assertion\+Reaction\& reaction ) override;        void handle\+Message                (   Assertion\+Info const\& info,                    Result\+Was\+::\+Of\+Type result\+Type,                    String\+Ref message,                    Assertion\+Reaction\& reaction ) override;        void handle\+Unexpected\+Exception\+Not\+Thrown                (   Assertion\+Info const\& info,                    Assertion\+Reaction\& reaction ) override;        void handle\+Unexpected\+Inflight\+Exception                (   Assertion\+Info const\& info,                    std\+::string\&\& message,                    Assertion\+Reaction\& reaction ) override;        void handle\+Incomplete                (   Assertion\+Info const\& info ) override;        void handle\+Non\+Expr                (   Assertion\+Info const \&info,                    Result\+Was\+::\+Of\+Type result\+Type,                    Assertion\+Reaction \&reaction ) override;        void notify\+Assertion\+Started( Assertion\+Info const\& info ) override;        bool section\+Started( String\+Ref section\+Name,                             Source\+Line\+Info const\& section\+Line\+Info,                             Counts\& assertions ) override;        void section\+Ended( Section\+End\+Info\&\& end\+Info ) override;        void section\+Ended\+Early( Section\+End\+Info\&\& end\+Info ) override;        IGenerator\+Tracker\texorpdfstring{$\ast$}{*}        acquire\+Generator\+Tracker( String\+Ref generator\+Name,                                 Source\+Line\+Info const\& line\+Info ) override;        IGenerator\+Tracker\texorpdfstring{$\ast$}{*} create\+Generator\+Tracker(            String\+Ref generator\+Name,            Source\+Line\+Info line\+Info,            Generators\+::\+Generator\+Base\+Ptr\&\& generator ) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& info ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}} ) override;        void benchmark\+Failed( String\+Ref error ) override;        void push\+Scoped\+Message( Message\+Info const\& message ) override;        void pop\+Scoped\+Message( Message\+Info const\& message ) override;        void emplace\+Unscoped\+Message( Message\+Builder\&\& builder ) override;        std\+::string get\+Current\+Test\+Name() const override;        const Assertion\+Result\texorpdfstring{$\ast$}{*} get\+Last\+Result() const override;        void exception\+Early\+Reported() override;        void handle\+Fatal\+Error\+Condition( String\+Ref message ) override;        bool last\+Assertion\+Passed() override;        void assertion\+Passed() override;    public\+:                bool aborting() const;    private\+:        void run\+Current\+Test( std\+::string\& redirected\+Cout, std\+::string\& redirected\+Cerr );        void invoke\+Active\+Test\+Case();        void reset\+Assertion\+Info();        bool test\+For\+Missing\+Assertions( Counts\& assertions );        void assertion\+Ended( Assertion\+Result\&\& \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} );        void report\+Expr                (   Assertion\+Info const \&info,                    Result\+Was\+::\+Of\+Type result\+Type,                    ITransient\+Expression const \texorpdfstring{$\ast$}{*}expr,                    bool negated );        void populate\+Reaction( Assertion\+Reaction\& reaction );    private\+:        void handle\+Unfinished\+Sections();        Test\+Run\+Info m\+\_\+run\+Info;        Test\+Case\+Handle const\texorpdfstring{$\ast$}{*} m\+\_\+active\+Test\+Case = nullptr;        ITracker\texorpdfstring{$\ast$}{*} m\+\_\+test\+Case\+Tracker = nullptr;        Optional$<$Assertion\+Result$>$ m\+\_\+last\+Result;        IConfig const\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}{m\+\_\+config}};        Totals m\+\_\+totals;        IEvent\+Listener\+Ptr \mbox{\hyperlink{catch__amalgamated_8cpp_aee7954c057251292dd81c24e2931c774}{m\+\_\+reporter}};        std\+::vector$<$Message\+Info$>$ m\+\_\+messages;        std\+::vector$<$Scoped\+Message$>$ m\+\_\+message\+Scopes;         Assertion\+Info m\+\_\+last\+Assertion\+Info;        std\+::vector$<$Section\+End\+Info$>$ m\+\_\+unfinished\+Sections;        std\+::vector$<$ITracker\texorpdfstring{$\ast$}{*}$>$ m\+\_\+active\+Sections;        Tracker\+Context m\+\_\+tracker\+Context;        Fatal\+Condition\+Handler m\+\_\+fatal\+Conditionhandler;        bool m\+\_\+last\+Assertion\+Passed = false;        bool m\+\_\+should\+Report\+Unexpected = true;        bool m\+\_\+include\+Successful\+Results;    \};    void seed\+Rng(IConfig const\& config);    unsigned int rng\+Seed();\} \#endif \#ifndef CATCH\+\_\+\+SHARDING\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+SHARDING\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$\#include $<$cmath$>$\#include $<$algorithm$>$namespace Catch \{    template$<$typename Container$>$    Container create\+Shard(Container const\& container, std\+::size\+\_\+t const \mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}}, std\+::size\+\_\+t const \mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}}) \{        assert(\mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}} $>$ \mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}});        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (\mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}} == 1) \{            return container;        \}        const std\+::size\+\_\+t total\+Test\+Count = container.\+size();        const std\+::size\+\_\+t shard\+Size = total\+Test\+Count / \mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}};        const std\+::size\+\_\+t leftover\+Tests = total\+Test\+Count \% \mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}};        const std\+::size\+\_\+t start\+Index = \mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}} \texorpdfstring{$\ast$}{*} shard\+Size + (std\+::min)(\mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}}, leftover\+Tests);        const std\+::size\+\_\+t end\+Index = (\mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}} + 1) \texorpdfstring{$\ast$}{*} shard\+Size + (std\+::min)(\mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}} + 1, leftover\+Tests);        auto start\+Iterator = std\+::next(container.\+begin(), static\+\_\+cast$<$std\+::ptrdiff\+\_\+t$>$(start\+Index));        auto end\+Iterator = std\+::next(container.\+begin(), static\+\_\+cast$<$std\+::ptrdiff\+\_\+t$>$(end\+Index));        return Container(start\+Iterator, end\+Iterator);    \}\}\#endif \#ifndef CATCH\+\_\+\+SINGLETONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+SINGLETONS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    struct ISingleton \{        virtual \texorpdfstring{$\sim$}{\string~}ISingleton();     \};    void add\+Singleton( ISingleton\texorpdfstring{$\ast$}{*} singleton );    void cleanup\+Singletons();    template$<$typename Singleton\+ImplT, typename InterfaceT = Singleton\+ImplT, typename Mutable\+InterfaceT = InterfaceT$>$    class Singleton \+: Singleton\+ImplT, public ISingleton \{        static auto get\+Internal() -\/$>$ Singleton\texorpdfstring{$\ast$}{*} \{            static Singleton\texorpdfstring{$\ast$}{*} s\+\_\+instance = nullptr;            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( !s\+\_\+instance ) \{                s\+\_\+instance = new Singleton;                add\+Singleton( s\+\_\+instance );            \}            return s\+\_\+instance;        \}    public\+:        static auto get() -\/$>$ InterfaceT const\& \{            return \texorpdfstring{$\ast$}{*}get\+Internal();        \}        static auto get\+Mutable() -\/$>$ Mutable\+InterfaceT\& \{            return \texorpdfstring{$\ast$}{*}get\+Internal();        \}    \};\} \#endif \#ifndef CATCH\+\_\+\+STARTUP\+\_\+\+EXCEPTION\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+STARTUP\+\_\+\+EXCEPTION\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$\#include $<$exception$>$namespace Catch \{    class Startup\+Exception\+Registry \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(\mbox{\hyperlink{catch__amalgamated_8hpp_a893712b2ba6e7400136a0a023b12e9db}{CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\+\_\+\+EXCEPTIONS}})    public\+:        void add(std\+::exception\+\_\+ptr const\& exception) noexcept;        std\+::vector$<$std\+::exception\+\_\+ptr$>$ const\& get\+Exceptions() const noexcept;    private\+:        std\+::vector$<$std\+::exception\+\_\+ptr$>$ m\+\_\+exceptions;\#endif    \};\} \#endif \#ifndef CATCH\+\_\+\+STDSTREAMS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+STDSTREAMS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$namespace Catch \{    std\+::ostream\& cout();    std\+::ostream\& cerr();    std\+::ostream\& clog();\} \#endif\#ifndef CATCH\+\_\+\+STRING\+\_\+\+MANIP\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+STRING\+\_\+\+MANIP\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdint$>$\#include $<$string$>$\#include $<$iosfwd$>$\#include $<$vector$>$namespace Catch \{    bool starts\+With( std\+::string const\& s, std\+::string const\& prefix );    bool starts\+With( String\+Ref s, char prefix );    bool ends\+With( std\+::string const\& s, std\+::string const\& suffix );    bool ends\+With( std\+::string const\& s, char suffix );    bool contains( std\+::string const\& s, std\+::string const\& infix );    void to\+Lower\+In\+Place( std\+::string\& s );    std\+::string to\+Lower( std\+::string const\& s );    char to\+Lower( char c );        std\+::string trim( std\+::string const\& str );        String\+Ref trim(String\+Ref ref);        std\+::vector$<$String\+Ref$>$ split\+String\+Ref( String\+Ref str, char delimiter );    bool replace\+In\+Place( std\+::string\& str, std\+::string const\& replace\+This, std\+::string const\& with\+This );        class pluralise \{        std\+::uint64\+\_\+t m\+\_\+count;        String\+Ref m\+\_\+label;    public\+:        constexpr pluralise(std\+::uint64\+\_\+t count, String\+Ref label)\+:            m\+\_\+count(count),            m\+\_\+label(label)        \{\}        friend std\+::ostream\& operator $<$$<$ ( std\+::ostream\& os, pluralise const\& pluraliser );    \};\}\#endif \#ifndef CATCH\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$map$>$\#include $<$string$>$namespace Catch \{    struct Source\+Line\+Info;    class Tag\+Alias\+Registry \+: public ITag\+Alias\+Registry \{    public\+:        \texorpdfstring{$\sim$}{\string~}Tag\+Alias\+Registry() override;        Tag\+Alias const\texorpdfstring{$\ast$}{*} find( std\+::string const\& alias ) const override;        std\+::string expand\+Aliases( std\+::string const\& unexpanded\+Test\+Spec ) const override;        void add( std\+::string const\& alias, std\+::string const\& tag, Source\+Line\+Info const\& line\+Info );    private\+:        std\+::map$<$std\+::string, Tag\+Alias$>$ m\+\_\+registry;    \};\} \#endif \#ifndef CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+INFO\+\_\+\+HASHER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+INFO\+\_\+\+HASHER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdint$>$namespace Catch \{    struct Test\+Case\+Info;    class Test\+Case\+Info\+Hasher \{    public\+:        using hash\+\_\+t = std\+::uint64\+\_\+t;        Test\+Case\+Info\+Hasher( hash\+\_\+t seed );        uint32\+\_\+t operator()( Test\+Case\+Info const\& t ) const;    private\+:        hash\+\_\+t m\+\_\+seed;    \};\} \#endif \#ifndef CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+REGISTRY\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+REGISTRY\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    class IConfig;    class ITest\+Invoker;    class Test\+Case\+Handle;    class Test\+Spec;    std\+::vector$<$Test\+Case\+Handle$>$ sort\+Tests( IConfig const\& config, std\+::vector$<$Test\+Case\+Handle$>$ const\& unsorted\+Test\+Cases );    bool is\+Throw\+Safe( Test\+Case\+Handle const\& test\+Case, IConfig const\& config );    std\+::vector$<$Test\+Case\+Handle$>$ filter\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& test\+Cases, Test\+Spec const\& test\+Spec, IConfig const\& config );    std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Test\+Cases\+Sorted( IConfig const\& config );    class Test\+Registry \+: public ITest\+Case\+Registry \{    public\+:        void register\+Test( Detail\+::unique\+\_\+ptr$<$Test\+Case\+Info$>$ test\+Info, Detail\+::unique\+\_\+ptr$<$ITest\+Invoker$>$ test\+Invoker );        std\+::vector$<$Test\+Case\+Info\texorpdfstring{$\ast$}{*}$>$ const\& get\+All\+Infos() const override;        std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests() const override;        std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests\+Sorted( IConfig const\& config ) const override;        \texorpdfstring{$\sim$}{\string~}Test\+Registry() override;     private\+:        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Test\+Case\+Info$>$$>$ m\+\_\+owned\+\_\+test\+\_\+infos;                        std\+::vector$<$Test\+Case\+Info\texorpdfstring{$\ast$}{*}$>$ m\+\_\+viewed\+\_\+test\+\_\+infos;        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$ITest\+Invoker$>$$>$ m\+\_\+invokers;        std\+::vector$<$Test\+Case\+Handle$>$ m\+\_\+handles;        mutable Test\+Run\+Order m\+\_\+current\+Sort\+Order = Test\+Run\+Order\+::\+Declared;        mutable std\+::vector$<$Test\+Case\+Handle$>$ m\+\_\+sorted\+Functions;    \};    \} \#endif \#ifndef CATCH\+\_\+\+TEST\+\_\+\+SPEC\+\_\+\+PARSER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+SPEC\+\_\+\+PARSER\+\_\+\+HPP\+\_\+\+INCLUDED\#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#pragma clang diagnostic push\#pragma clang diagnostic ignored "{}-\/Wpadded"{}\#endif\#include $<$vector$>$\#include $<$string$>$namespace Catch \{    class ITag\+Alias\+Registry;    class Test\+Spec\+Parser \{        enum Mode\{ None, Name, Quoted\+Name, Tag, Escaped\+Name \};        Mode m\+\_\+mode = None;        Mode last\+Mode = None;        bool m\+\_\+exclusion = false;        std\+::size\+\_\+t m\+\_\+pos = 0;        std\+::size\+\_\+t m\+\_\+real\+Pattern\+Pos = 0;        std\+::string m\+\_\+arg;        std\+::string m\+\_\+substring;        std\+::string m\+\_\+pattern\+Name;        std\+::vector$<$std\+::size\+\_\+t$>$ m\+\_\+escape\+Chars;        Test\+Spec\+::\+Filter m\+\_\+current\+Filter;        Test\+Spec m\+\_\+test\+Spec;        ITag\+Alias\+Registry const\texorpdfstring{$\ast$}{*} m\+\_\+tag\+Aliases = nullptr;    public\+:        Test\+Spec\+Parser( ITag\+Alias\+Registry const\& tag\+Aliases );        Test\+Spec\+Parser\& parse( std\+::string const\& arg );        Test\+Spec test\+Spec();    private\+:        bool visit\+Char( char c );        void start\+New\+Mode( Mode mode );        bool process\+None\+Char( char c );        void process\+Name\+Char( char c );        bool process\+Other\+Char( char c );        void end\+Mode();        void escape();        bool is\+Control\+Char( char c ) const;        void save\+Last\+Mode();        void revert\+Back\+To\+Last\+Mode();        void add\+Filter();        bool separate();                std\+::string preprocess\+Pattern();                void add\+Name\+Pattern();                void add\+Tag\+Pattern();        inline void add\+Char\+To\+Pattern(char c) \{            m\+\_\+substring += c;            m\+\_\+pattern\+Name += c;            m\+\_\+real\+Pattern\+Pos++;        \}    \};\} \#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#pragma clang diagnostic pop\#endif\#endif \#ifndef CATCH\+\_\+\+TEXTFLOW\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEXTFLOW\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    namespace Text\+Flow \{        class Columns;                class Column \{                        std\+::string m\+\_\+string;                        size\+\_\+t \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}} = CATCH\+\_\+\+CONFIG\+\_\+\+CONSOLE\+\_\+\+WIDTH -\/ 1;                        size\+\_\+t m\+\_\+indent = 0;                        size\+\_\+t m\+\_\+initial\+Indent = std\+::string\+::npos;        public\+:                        class const\+\_\+iterator \{                friend Column;                struct End\+Tag \{\};                Column const\& m\+\_\+column;                                size\+\_\+t m\+\_\+line\+Start = 0;                                size\+\_\+t m\+\_\+line\+Length = 0;                                size\+\_\+t m\+\_\+parsed\+To = 0;                                bool m\+\_\+add\+Hyphen = false;                const\+\_\+iterator( Column const\& column, End\+Tag )\+:                    m\+\_\+column( column ), m\+\_\+line\+Start( m\+\_\+column.\+m\+\_\+string.\+size() ) \{\}                                void calc\+Length();                                size\+\_\+t indent\+Size() const;                                                std\+::string add\+Indent\+And\+Suffix( size\+\_\+t position,                                                size\+\_\+t length ) const;            public\+:                using difference\+\_\+type = std\+::ptrdiff\+\_\+t;                using value\+\_\+type = std\+::string;                using pointer = value\+\_\+type\texorpdfstring{$\ast$}{*};                using reference = value\+\_\+type\&;                using iterator\+\_\+category = std\+::forward\+\_\+iterator\+\_\+tag;                explicit const\+\_\+iterator( Column const\& column );                std\+::string operator\texorpdfstring{$\ast$}{*}() const;                const\+\_\+iterator\& operator++();                const\+\_\+iterator operator++( int );                bool operator==( const\+\_\+iterator const\& other ) const \{                    return m\+\_\+line\+Start == other.\+m\+\_\+line\+Start \&\& \&m\+\_\+column == \&other.\+m\+\_\+column;                \}                bool operator!=( const\+\_\+iterator const\& other ) const \{                    return !operator==( other );                \}            \};            using iterator = const\+\_\+iterator;            explicit Column( std\+::string const\& text )\+: m\+\_\+string( text ) \{\}            explicit Column( std\+::string\&\& text )\+:                m\+\_\+string( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(text)) \{\}            Column\& width( size\+\_\+t new\+Width ) \& \{                assert( new\+Width $>$ 0 );                \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}} = new\+Width;                return \texorpdfstring{$\ast$}{*}this;            \}            Column\&\& width( size\+\_\+t new\+Width ) \&\& \{                assert( new\+Width $>$ 0 );                \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}} = new\+Width;                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( \texorpdfstring{$\ast$}{*}this );            \}            Column\& indent( size\+\_\+t new\+Indent ) \& \{                m\+\_\+indent = new\+Indent;                return \texorpdfstring{$\ast$}{*}this;            \}            Column\&\& indent( size\+\_\+t new\+Indent ) \&\& \{                m\+\_\+indent = new\+Indent;                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( \texorpdfstring{$\ast$}{*}this );            \}            Column\& initial\+Indent( size\+\_\+t new\+Indent ) \& \{                m\+\_\+initial\+Indent = new\+Indent;                return \texorpdfstring{$\ast$}{*}this;            \}            Column\&\& initial\+Indent( size\+\_\+t new\+Indent ) \&\& \{                m\+\_\+initial\+Indent = new\+Indent;                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( \texorpdfstring{$\ast$}{*}this );            \}            size\+\_\+t width() const \{ return \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}}; \}            const\+\_\+iterator begin() const \{ return const\+\_\+iterator( \texorpdfstring{$\ast$}{*}this ); \}            const\+\_\+iterator end() const \{ return \{ \texorpdfstring{$\ast$}{*}this, const\+\_\+iterator\+::\+End\+Tag\{\} \}; \}            friend std\+::ostream\& operator$<$$<$( std\+::ostream\& os,                                             Column const\& col );            friend Columns operator+( Column const\& lhs, Column const\& rhs );            friend Columns operator+( Column\&\& lhs, Column\&\& rhs );        \};                Column Spacer( size\+\_\+t space\+Width );        class Columns \{            std\+::vector$<$Column$>$ m\+\_\+columns;        public\+:            class iterator \{                friend Columns;                struct End\+Tag \{\};                std\+::vector$<$Column$>$ const\& m\+\_\+columns;                std\+::vector$<$Column\+::const\+\_\+iterator$>$ m\+\_\+iterators;                size\+\_\+t m\+\_\+active\+Iterators;                iterator( Columns const\& columns, End\+Tag );            public\+:                using difference\+\_\+type = std\+::ptrdiff\+\_\+t;                using value\+\_\+type = std\+::string;                using pointer = value\+\_\+type\texorpdfstring{$\ast$}{*};                using reference = value\+\_\+type\&;                using iterator\+\_\+category = std\+::forward\+\_\+iterator\+\_\+tag;                explicit iterator( Columns const\& columns );                auto operator==( iterator const\& other ) const -\/$>$ bool \{                    return m\+\_\+iterators == other.\+m\+\_\+iterators;                \}                auto operator!=( iterator const\& other ) const -\/$>$ bool \{                    return m\+\_\+iterators != other.\+m\+\_\+iterators;                \}                std\+::string operator\texorpdfstring{$\ast$}{*}() const;                iterator\& operator++();                iterator operator++( int );            \};            using const\+\_\+iterator = iterator;            iterator begin() const \{ return iterator( \texorpdfstring{$\ast$}{*}this ); \}            iterator end() const \{ return \{ \texorpdfstring{$\ast$}{*}this, iterator\+::\+End\+Tag() \}; \}            friend Columns\& operator+=( Columns\& lhs, Column const\& rhs );            friend Columns\& operator+=( Columns\& lhs, Column\&\& rhs );            friend Columns operator+( Columns const\& lhs, Column const\& rhs );            friend Columns operator+( Columns\&\& lhs, Column\&\& rhs );            friend std\+::ostream\& operator$<$$<$( std\+::ostream\& os,                                             Columns const\& cols );        \};    \} \} \#endif \#ifndef CATCH\+\_\+\+TO\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TO\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    template $<$typename T$>$    std\+::string to\+\_\+string(T const\& t) \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\mbox{\hyperlink{catch__amalgamated_8hpp_a5e8669f07e3db1e9e1604508689bc28a}{CATCH\+\_\+\+CONFIG\+\_\+\+CPP11\+\_\+\+TO\+\_\+\+STRING}})        return std\+::to\+\_\+string(t);\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}        Reusable\+String\+Stream rss;        rss $<$$<$ t;        return rss.\+str();\#endif    \}\} \#endif \#ifndef CATCH\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    bool uncaught\+\_\+exceptions();\} \#endif \#ifndef CATCH\+\_\+\+XMLWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+XMLWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$vector$>$namespace Catch \{    enum class Xml\+Formatting \{        None = 0x00,        Indent = 0x01,        Newline = 0x02,    \};    Xml\+Formatting operator \texorpdfstring{$\vert$}{|} (Xml\+Formatting lhs, Xml\+Formatting rhs);    Xml\+Formatting operator \& (Xml\+Formatting lhs, Xml\+Formatting rhs);        class Xml\+Encode \{    public\+:        enum For\+What \{ For\+Text\+Nodes, For\+Attributes \};        Xml\+Encode( String\+Ref str, For\+What for\+What = For\+Text\+Nodes );        void encode\+To( std\+::ostream\& os ) const;        friend std\+::ostream\& operator $<$$<$ ( std\+::ostream\& os, Xml\+Encode const\& xml\+Encode );    private\+:        String\+Ref m\+\_\+str;        For\+What m\+\_\+for\+What;    \};    class Xml\+Writer \{    public\+:        class Scoped\+Element \{        public\+:            Scoped\+Element( Xml\+Writer\texorpdfstring{$\ast$}{*} writer, Xml\+Formatting fmt );            Scoped\+Element( Scoped\+Element\&\& other ) noexcept;            Scoped\+Element\& operator=( Scoped\+Element\&\& other ) noexcept;            \texorpdfstring{$\sim$}{\string~}Scoped\+Element();            Scoped\+Element\&            write\+Text( String\+Ref text,                       Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|}                                           Xml\+Formatting\+::\+Indent );            Scoped\+Element\& write\+Attribute( String\+Ref name,                                           String\+Ref attribute );            template $<$typename T,                                                                                                              typename = typename std\+::enable\+\_\+if\+\_\+t$<$                          !std\+::is\+\_\+convertible$<$T, String\+Ref$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$            Scoped\+Element\& write\+Attribute( String\+Ref name,                                           T const\& attribute ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_ab448bd968db5f560dde343c3bee4df2b}{m\+\_\+writer}}-\/$>$write\+Attribute( name, attribute );                return \texorpdfstring{$\ast$}{*}this;            \}        private\+:            Xml\+Writer\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_ab448bd968db5f560dde343c3bee4df2b}{m\+\_\+writer}} = nullptr;            Xml\+Formatting m\+\_\+fmt;        \};        Xml\+Writer( std\+::ostream\& os );        \texorpdfstring{$\sim$}{\string~}Xml\+Writer();        Xml\+Writer( Xml\+Writer const\& ) = delete;        Xml\+Writer\& operator=( Xml\+Writer const\& ) = delete;        Xml\+Writer\& start\+Element( std\+::string const\& name, Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|} Xml\+Formatting\+::\+Indent);        Scoped\+Element scoped\+Element( std\+::string const\& name, Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|} Xml\+Formatting\+::\+Indent);        Xml\+Writer\& end\+Element(Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|} Xml\+Formatting\+::\+Indent);                Xml\+Writer\& write\+Attribute( String\+Ref name, String\+Ref attribute );                Xml\+Writer\& write\+Attribute( String\+Ref name, bool attribute );                Xml\+Writer\& write\+Attribute( String\+Ref name, char const\texorpdfstring{$\ast$}{*} attribute );                        template $<$typename T,                                                                                          typename = typename std\+::enable\+\_\+if\+\_\+t$<$                      !std\+::is\+\_\+convertible$<$T, String\+Ref$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Xml\+Writer\& write\+Attribute( String\+Ref name, T const\& attribute ) \{            Reusable\+String\+Stream rss;            rss $<$$<$ attribute;            return write\+Attribute( name, rss.\+str() );        \}                Xml\+Writer\& write\+Text( String\+Ref text,                              Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|}                                                  Xml\+Formatting\+::\+Indent );                Xml\+Writer\& write\+Comment( String\+Ref text,                                 Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|}                                                     Xml\+Formatting\+::\+Indent );        void write\+Stylesheet\+Ref( String\+Ref url );        void ensure\+Tag\+Closed();    private\+:        void apply\+Formatting(Xml\+Formatting fmt);        void write\+Declaration();        void newline\+If\+Necessary();        bool m\+\_\+tag\+Is\+Open = false;        bool m\+\_\+needs\+Newline = false;        std\+::vector$<$std\+::string$>$ m\+\_\+tags;        std\+::string m\+\_\+indent;        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};    \};\}\#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    template$<$typename ArgT, typename MatcherT$>$    class Match\+Expr \+: public ITransient\+Expression \{        ArgT \&\& m\+\_\+arg;        MatcherT const\& m\+\_\+matcher;    public\+:        Match\+Expr( ArgT \&\& arg, MatcherT const\& matcher )        \+:   ITransient\+Expression\{ true, matcher.\+match( arg ) \},             m\+\_\+arg( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(arg) ),            m\+\_\+matcher( matcher )        \{\}        void stream\+Reconstructed\+Expression( std\+::ostream\& os ) const override \{            os $<$$<$ \mbox{\hyperlink{namespace_catch_1_1_detail_af0ad48344ffd3f92f3568465248a9880}{Catch\+::\+Detail\+::stringify}}( m\+\_\+arg )               $<$$<$ \textquotesingle{} \textquotesingle{}               $<$$<$ m\+\_\+matcher.\+to\+String();        \}    \};    namespace Matchers \{        template $<$typename ArgT$>$        class Matcher\+Base;    \}    using String\+Matcher = Matchers\+::\+Matcher\+Base$<$std\+::string$>$;    void handle\+Exception\+Match\+Expr( Assertion\+Handler\& handler, String\+Matcher const\& matcher );    template$<$typename ArgT, typename MatcherT$>$    auto make\+Match\+Expr( ArgT \&\& arg, MatcherT const\& matcher ) -\/$>$ Match\+Expr$<$ArgT, MatcherT$>$ \{        return Match\+Expr$<$ArgT, MatcherT$>$( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(arg), matcher );    \}\} \#define INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( macro\+Name, matcher, result\+Disposition, arg ) \textbackslash{}    do \{ \textbackslash{}        \mbox{\hyperlink{class_catch_1_1_assertion_handler}{Catch\+::\+Assertion\+Handler}} catch\+Assertion\+Handler( macro\+Name\#\#\+\_\+catch\+\_\+sr, \mbox{\hyperlink{catch__amalgamated_8hpp_abc0b2405454c51748a31e0393d9ad5d1}{CATCH\+\_\+\+INTERNAL\+\_\+\+LINEINFO}}, \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(arg) "{}, "{} \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(matcher), result\+Disposition ); \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_af21395add3cdee3109e0a2e7c15a54bc}{INTERNAL\+\_\+\+CATCH\+\_\+\+TRY}} \{ \textbackslash{}            catch\+Assertion\+Handler.\+handle\+Expr( Catch\+::make\+Match\+Expr( arg, matcher ) ); \textbackslash{}        \} \mbox{\hyperlink{catch__amalgamated_8hpp_a3ef8d1213eac4fd0e2fdb4e13bdb8070}{INTERNAL\+\_\+\+CATCH\+\_\+\+CATCH}}( catch\+Assertion\+Handler ) \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a87986fec7b6b65bdae29cd2fa62bec20}{INTERNAL\+\_\+\+CATCH\+\_\+\+REACT}}( catch\+Assertion\+Handler ) \textbackslash{}    \} while( false )\#define INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( macro\+Name, exception\+Type, result\+Disposition, matcher, ... ) \textbackslash{}    do \{ \textbackslash{}        \mbox{\hyperlink{class_catch_1_1_assertion_handler}{Catch\+::\+Assertion\+Handler}} catch\+Assertion\+Handler( macro\+Name\#\#\+\_\+catch\+\_\+sr, \mbox{\hyperlink{catch__amalgamated_8hpp_abc0b2405454c51748a31e0393d9ad5d1}{CATCH\+\_\+\+INTERNAL\+\_\+\+LINEINFO}}, \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(\+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+) "{}, "{} \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(exception\+Type) "{}, "{} \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(matcher), result\+Disposition ); \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( catch\+Assertion\+Handler.\+allow\+Throws() ) \textbackslash{}            try \{ \textbackslash{}                static\+\_\+cast$<$void$>$(\+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ); \textbackslash{}                catch\+Assertion\+Handler.\+handle\+Unexpected\+Exception\+Not\+Thrown(); \textbackslash{}            \} \textbackslash{}            catch( exception\+Type const\& ex ) \{ \textbackslash{}                catch\+Assertion\+Handler.\+handle\+Expr( Catch\+::make\+Match\+Expr( ex, matcher ) ); \textbackslash{}            \} \textbackslash{}            catch( ... ) \{ \textbackslash{}                catch\+Assertion\+Handler.\+handle\+Unexpected\+Inflight\+Exception(); \textbackslash{}            \} \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} \textbackslash{}            catch\+Assertion\+Handler.\+handle\+Throwing\+Call\+Skipped(); \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a87986fec7b6b65bdae29cd2fa62bec20}{INTERNAL\+\_\+\+CATCH\+\_\+\+REACT}}( catch\+Assertion\+Handler ) \textbackslash{}    \} while( false )\#endif \#include $<$string$>$\#include $<$vector$>$namespace Catch \{namespace Matchers \{    class Matcher\+Untyped\+Base \{    public\+:        Matcher\+Untyped\+Base() = default;        Matcher\+Untyped\+Base(Matcher\+Untyped\+Base const\&) = default;        Matcher\+Untyped\+Base(Matcher\+Untyped\+Base\&\&) = default;        Matcher\+Untyped\+Base\& operator = (Matcher\+Untyped\+Base const\&) = delete;        Matcher\+Untyped\+Base\& operator = (Matcher\+Untyped\+Base\&\&) = delete;        std\+::string to\+String() const;    protected\+:        virtual \texorpdfstring{$\sim$}{\string~}Matcher\+Untyped\+Base();         virtual std\+::string describe() const = 0;        mutable std\+::string m\+\_\+cached\+To\+String;    \};    template$<$typename T$>$    class Matcher\+Base \+: public Matcher\+Untyped\+Base \{    public\+:        virtual bool match( T const\& arg ) const = 0;    \};    namespace Detail \{        template$<$typename ArgT$>$        class Match\+All\+Of final \+: public Matcher\+Base$<$ArgT$>$ \{            std\+::vector$<$Matcher\+Base$<$ArgT$>$ const\texorpdfstring{$\ast$}{*}$>$ m\+\_\+matchers;        public\+:            Match\+All\+Of() = default;            Match\+All\+Of(Match\+All\+Of const\&) = delete;            Match\+All\+Of\& operator=(Match\+All\+Of const\&) = delete;            Match\+All\+Of(Match\+All\+Of\&\&) = default;            Match\+All\+Of\& operator=(Match\+All\+Of\&\&) = default;            bool match( ArgT const\& arg ) const override \{                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!matcher-\/$>$match(arg))                        return false;                \}                return true;            \}            std\+::string describe() const override \{                std\+::string description;                description.\+reserve( 4 + m\+\_\+matchers.\+size()\texorpdfstring{$\ast$}{*}32 );                description += "{}( "{};                bool first = true;                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( first )                        first = false;                    \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                        description += "{} and "{};                    description += matcher-\/$>$to\+String();                \}                description += "{} )"{};                return description;            \}            friend Match\+All\+Of operator\&\& (Match\+All\+Of\&\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) \{                lhs.\+m\+\_\+matchers.\+push\+\_\+back(\&rhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs);            \}            friend Match\+All\+Of operator\&\& (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+All\+Of\&\& rhs) \{                rhs.\+m\+\_\+matchers.\+insert(rhs.\+m\+\_\+matchers.\+begin(), \&lhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs);            \}        \};                        template$<$typename ArgT$>$        Match\+All\+Of$<$ArgT$>$ operator\&\& (Match\+All\+Of$<$ArgT$>$ const\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) = delete;                        template$<$typename ArgT$>$        Match\+All\+Of$<$ArgT$>$ operator\&\& (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+All\+Of$<$ArgT$>$ const\& rhs) = delete;        template$<$typename ArgT$>$        class Match\+Any\+Of final \+: public Matcher\+Base$<$ArgT$>$ \{            std\+::vector$<$Matcher\+Base$<$ArgT$>$ const\texorpdfstring{$\ast$}{*}$>$ m\+\_\+matchers;        public\+:            Match\+Any\+Of() = default;            Match\+Any\+Of(Match\+Any\+Of const\&) = delete;            Match\+Any\+Of\& operator=(Match\+Any\+Of const\&) = delete;            Match\+Any\+Of(Match\+Any\+Of\&\&) = default;            Match\+Any\+Of\& operator=(Match\+Any\+Of\&\&) = default;            bool match( ArgT const\& arg ) const override \{                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (matcher-\/$>$match(arg))                        return true;                \}                return false;            \}            std\+::string describe() const override \{                std\+::string description;                description.\+reserve( 4 + m\+\_\+matchers.\+size()\texorpdfstring{$\ast$}{*}32 );                description += "{}( "{};                bool first = true;                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( first )                        first = false;                    \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                        description += "{} or "{};                    description += matcher-\/$>$to\+String();                \}                description += "{} )"{};                return description;            \}            friend Match\+Any\+Of operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Match\+Any\+Of\&\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) \{                lhs.\+m\+\_\+matchers.\+push\+\_\+back(\&rhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs);            \}            friend Match\+Any\+Of operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+Any\+Of\&\& rhs) \{                rhs.\+m\+\_\+matchers.\+insert(rhs.\+m\+\_\+matchers.\+begin(), \&lhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs);            \}        \};                        template$<$typename ArgT$>$        Match\+Any\+Of$<$ArgT$>$ operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Match\+Any\+Of$<$ArgT$>$ const\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) = delete;                        template$<$typename ArgT$>$        Match\+Any\+Of$<$ArgT$>$ operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+Any\+Of$<$ArgT$>$ const\& rhs) = delete;        template$<$typename ArgT$>$        class Match\+Not\+Of final \+: public Matcher\+Base$<$ArgT$>$ \{            Matcher\+Base$<$ArgT$>$ const\& m\+\_\+underlying\+Matcher;        public\+:            explicit Match\+Not\+Of( Matcher\+Base$<$ArgT$>$ const\& underlying\+Matcher )\+:                m\+\_\+underlying\+Matcher( underlying\+Matcher )            \{\}            bool match( ArgT const\& arg ) const override \{                return !m\+\_\+underlying\+Matcher.\+match( arg );            \}            std\+::string describe() const override \{                return "{}not "{} + m\+\_\+underlying\+Matcher.\+to\+String();            \}        \};    \}     template $<$typename T$>$    Detail\+::\+Match\+All\+Of$<$T$>$ operator\&\& (Matcher\+Base$<$T$>$ const\& lhs, Matcher\+Base$<$T$>$ const\& rhs) \{        return Detail\+::\+Match\+All\+Of$<$T$>$\{\} \&\& lhs \&\& rhs;    \}    template $<$typename T$>$    Detail\+::\+Match\+Any\+Of$<$T$>$ operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$T$>$ const\& lhs, Matcher\+Base$<$T$>$ const\& rhs) \{        return Detail\+::\+Match\+Any\+Of$<$T$>$\{\} \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} lhs \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} rhs;    \}    template $<$typename T$>$    Detail\+::\+Match\+Not\+Of$<$T$>$ operator! (Matcher\+Base$<$T$>$ const\& matcher) \{        return Detail\+::\+Match\+Not\+Of$<$T$>$\{ matcher \};    \}\} \} \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CATCH\+\_\+\+CHECK\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}CATCH\+\_\+\+CHECK\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, arg )  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}CATCH\+\_\+\+REQUIRE\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, arg )\#elif defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                   (void)(0)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) (void)(0)  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                     (void)(0)  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher )   (void)(0)  \#define CATCH\+\_\+\+CHECK\+\_\+\+THAT( arg, matcher )                             (void)(0)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THAT( arg, matcher )                           (void)(0)\#elif !defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}REQUIRE\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}CHECK\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}CHECK\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CHECK\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}CHECK\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, arg )  \#define REQUIRE\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}REQUIRE\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, arg )\#elif !defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                   (void)(0)  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) (void)(0)  \#define CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                     (void)(0)  \#define CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher )   (void)(0)  \#define CHECK\+\_\+\+THAT( arg, matcher )                             (void)(0)  \#define REQUIRE\+\_\+\+THAT( arg, matcher )                           (void)(0)\#endif \#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINER\+\_\+\+PROPERTIES\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINER\+\_\+\+PROPERTIES\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+TEMPLATED\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+TEMPLATED\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$array$>$\#include $<$algorithm$>$\#include $<$string$>$\#include $<$type\+\_\+traits$>$namespace Catch \{namespace Matchers \{    class Matcher\+Generic\+Base \+: public Matcher\+Untyped\+Base \{    public\+:        Matcher\+Generic\+Base() = default;        \texorpdfstring{$\sim$}{\string~}Matcher\+Generic\+Base() override;         Matcher\+Generic\+Base(Matcher\+Generic\+Base const\&) = default;        Matcher\+Generic\+Base(Matcher\+Generic\+Base\&\&) = default;        Matcher\+Generic\+Base\& operator=(Matcher\+Generic\+Base const\&) = delete;        Matcher\+Generic\+Base\& operator=(Matcher\+Generic\+Base\&\&) = delete;    \};    namespace Detail \{        template$<$std\+::size\+\_\+t N, std\+::size\+\_\+t M$>$        std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N + M$>$ array\+\_\+cat(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ \&\& lhs, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, M$>$ \&\& rhs) \{            std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N + M$>$ arr\{\};            std\+::copy\+\_\+n(lhs.\+begin(), N, arr.\+begin());            std\+::copy\+\_\+n(rhs.\+begin(), M, arr.\+begin() + N);            return arr;        \}        template$<$std\+::size\+\_\+t N$>$        std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N+1$>$ array\+\_\+cat(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ \&\& lhs, void const\texorpdfstring{$\ast$}{*} rhs) \{            std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N+1$>$ arr\{\};            std\+::copy\+\_\+n(lhs.\+begin(), N, arr.\+begin());            arr\mbox{[}N\mbox{]} = rhs;            return arr;        \}        template$<$std\+::size\+\_\+t N$>$        std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N+1$>$ array\+\_\+cat(void const\texorpdfstring{$\ast$}{*} lhs, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ \&\& rhs) \{            std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N + 1$>$ arr\{ \{lhs\} \};            std\+::copy\+\_\+n(rhs.\+begin(), N, arr.\+begin() + 1);            return arr;        \}        template$<$typename T$>$        using is\+\_\+generic\+\_\+matcher = std\+::is\+\_\+base\+\_\+of$<$            Catch\+::\+Matchers\+::\+Matcher\+Generic\+Base,            std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$T$>$$>$        $>$;        template$<$typename... Ts$>$        using are\+\_\+generic\+\_\+matchers = \mbox{\hyperlink{struct_catch_1_1_detail_1_1conjunction}{Catch\+::\+Detail\+::conjunction}}$<$is\+\_\+generic\+\_\+matcher$<$Ts$>$...$>$;        template$<$typename T$>$        using is\+\_\+matcher = std\+::is\+\_\+base\+\_\+of$<$            Catch\+::\+Matchers\+::\+Matcher\+Untyped\+Base,            std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$T$>$$>$        $>$;        template$<$std\+::size\+\_\+t N, typename Arg$>$        bool match\+\_\+all\+\_\+of(Arg\&\&, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\&, std\+::index\+\_\+sequence$<$$>$) \{            return true;        \}        template$<$typename T, typename... Matcher\+Ts, std\+::size\+\_\+t N, typename Arg, std\+::size\+\_\+t Idx, std\+::size\+\_\+t... Indices$>$        bool match\+\_\+all\+\_\+of(Arg\&\& arg, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\& matchers, std\+::index\+\_\+sequence$<$Idx, Indices...$>$) \{            return static\+\_\+cast$<$T const\texorpdfstring{$\ast$}{*}$>$(matchers\mbox{[}Idx\mbox{]})-\/$>$match(arg) \&\& match\+\_\+all\+\_\+of$<$Matcher\+Ts...$>$(arg, matchers, std\+::index\+\_\+sequence$<$Indices...$>$\{\});        \}        template$<$std\+::size\+\_\+t N, typename Arg$>$        bool match\+\_\+any\+\_\+of(Arg\&\&, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\&, std\+::index\+\_\+sequence$<$$>$) \{            return false;        \}        template$<$typename T, typename... Matcher\+Ts, std\+::size\+\_\+t N, typename Arg, std\+::size\+\_\+t Idx, std\+::size\+\_\+t... Indices$>$        bool match\+\_\+any\+\_\+of(Arg\&\& arg, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\& matchers, std\+::index\+\_\+sequence$<$Idx, Indices...$>$) \{            return static\+\_\+cast$<$T const\texorpdfstring{$\ast$}{*}$>$(matchers\mbox{[}Idx\mbox{]})-\/$>$match(arg) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} match\+\_\+any\+\_\+of$<$Matcher\+Ts...$>$(arg, matchers, std\+::index\+\_\+sequence$<$Indices...$>$\{\});        \}        std\+::string describe\+\_\+multi\+\_\+matcher(String\+Ref combine, std\+::string const\texorpdfstring{$\ast$}{*} descriptions\+\_\+begin, std\+::string const\texorpdfstring{$\ast$}{*} descriptions\+\_\+end);        template$<$typename... Matcher\+Ts, std\+::size\+\_\+t... Idx$>$        std\+::string describe\+\_\+multi\+\_\+matcher(String\+Ref combine, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...(Matcher\+Ts)$>$ const\& matchers, std\+::index\+\_\+sequence$<$Idx...$>$) \{            std\+::array$<$std\+::string, sizeof...(Matcher\+Ts)$>$ descriptions \{\{                static\+\_\+cast$<$Matcher\+Ts const\texorpdfstring{$\ast$}{*}$>$(matchers\mbox{[}Idx\mbox{]})-\/$>$to\+String()...            \}\};            return describe\+\_\+multi\+\_\+matcher(combine, \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{descriptions.\+data}}(), \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{descriptions.\+data}}() + descriptions.\+size());        \}        template$<$typename... Matcher\+Ts$>$        class Match\+All\+Of\+Generic final \+: public Matcher\+Generic\+Base \{        public\+:            Match\+All\+Of\+Generic(Match\+All\+Of\+Generic const\&) = delete;            Match\+All\+Of\+Generic\& operator=(Match\+All\+Of\+Generic const\&) = delete;            Match\+All\+Of\+Generic(Match\+All\+Of\+Generic\&\&) = default;            Match\+All\+Of\+Generic\& operator=(Match\+All\+Of\+Generic\&\&) = default;            Match\+All\+Of\+Generic(Matcher\+Ts const\&... matchers) \+: m\+\_\+matchers\{ \{std\+::addressof(matchers)...\} \} \{\}            explicit Match\+All\+Of\+Generic(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...(Matcher\+Ts)$>$ matchers) \+: m\+\_\+matchers\{matchers\} \{\}            template$<$typename Arg$>$            bool match(Arg\&\& arg) const \{                return match\+\_\+all\+\_\+of$<$Matcher\+Ts...$>$(arg, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}            std\+::string describe() const override \{                return describe\+\_\+multi\+\_\+matcher$<$Matcher\+Ts...$>$("{} and "{}\+\_\+sr, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}                                                std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...( Matcher\+Ts )$>$ m\+\_\+matchers;                        template$<$typename... Matchers\+RHS$>$            friend            Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$ operator \&\& (                    Match\+All\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Match\+All\+Of\+Generic$<$Matchers\+RHS...$>$\&\& rhs) \{                return Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}                        template$<$typename Matcher\+RHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$$>$ operator \&\& (                    Match\+All\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Matcher\+RHS const\& rhs) \{                return Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(\&rhs))\};            \}                        template$<$typename Matcher\+LHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$$>$ operator \&\& (                    Matcher\+LHS const\& lhs,                    Match\+All\+Of\+Generic$<$Matcher\+Ts...$>$\&\& rhs) \{                return Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$\{array\+\_\+cat(static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(std\+::addressof(lhs)), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}        \};        template$<$typename... Matcher\+Ts$>$        class Match\+Any\+Of\+Generic final \+: public Matcher\+Generic\+Base \{        public\+:            Match\+Any\+Of\+Generic(Match\+Any\+Of\+Generic const\&) = delete;            Match\+Any\+Of\+Generic\& operator=(Match\+Any\+Of\+Generic const\&) = delete;            Match\+Any\+Of\+Generic(Match\+Any\+Of\+Generic\&\&) = default;            Match\+Any\+Of\+Generic\& operator=(Match\+Any\+Of\+Generic\&\&) = default;            Match\+Any\+Of\+Generic(Matcher\+Ts const\&... matchers) \+: m\+\_\+matchers\{ \{std\+::addressof(matchers)...\} \} \{\}            explicit Match\+Any\+Of\+Generic(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...(Matcher\+Ts)$>$ matchers) \+: m\+\_\+matchers\{matchers\} \{\}            template$<$typename Arg$>$            bool match(Arg\&\& arg) const \{                return match\+\_\+any\+\_\+of$<$Matcher\+Ts...$>$(arg, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}            std\+::string describe() const override \{                return describe\+\_\+multi\+\_\+matcher$<$Matcher\+Ts...$>$("{} or "{}\+\_\+sr, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}                                                std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...( Matcher\+Ts )$>$ m\+\_\+matchers;                        template$<$typename... Matchers\+RHS$>$            friend Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$ operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (                    Match\+Any\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Match\+Any\+Of\+Generic$<$Matchers\+RHS...$>$\&\& rhs) \{                return Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}                        template$<$typename Matcher\+RHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$$>$ operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (                    Match\+Any\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Matcher\+RHS const\& rhs) \{                return Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(std\+::addressof(rhs)))\};            \}                        template$<$typename Matcher\+LHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$$>$ operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (                Matcher\+LHS const\& lhs,                Match\+Any\+Of\+Generic$<$Matcher\+Ts...$>$\&\& rhs) \{                return Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$\{array\+\_\+cat(static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(std\+::addressof(lhs)), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}        \};        template$<$typename MatcherT$>$        class Match\+Not\+Of\+Generic final \+: public Matcher\+Generic\+Base \{            MatcherT const\& m\+\_\+matcher;        public\+:            Match\+Not\+Of\+Generic(Match\+Not\+Of\+Generic const\&) = delete;            Match\+Not\+Of\+Generic\& operator=(Match\+Not\+Of\+Generic const\&) = delete;            Match\+Not\+Of\+Generic(Match\+Not\+Of\+Generic\&\&) = default;            Match\+Not\+Of\+Generic\& operator=(Match\+Not\+Of\+Generic\&\&) = default;            explicit Match\+Not\+Of\+Generic(MatcherT const\& matcher) \+: m\+\_\+matcher\{matcher\} \{\}            template$<$typename Arg$>$            bool match(Arg\&\& arg) const \{                return !m\+\_\+matcher.\+match(arg);            \}            std\+::string describe() const override \{                return "{}not "{} + m\+\_\+matcher.\+to\+String();            \}                        friend MatcherT const\& operator ! (Match\+Not\+Of\+Generic$<$MatcherT$>$ const\& matcher) \{                return matcher.\+m\+\_\+matcher;            \}        \};    \}         template$<$typename Matcher\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::are\+\_\+generic\+\_\+matchers$<$Matcher\+LHS, Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+RHS$>$$>$        operator \&\& (Matcher\+LHS const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Matcher\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::are\+\_\+generic\+\_\+matchers$<$Matcher\+LHS, Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+RHS$>$$>$        operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+LHS const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}        template$<$typename MatcherT$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$MatcherT$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Not\+Of\+Generic$<$MatcherT$>$$>$        operator ! (MatcherT const\& matcher) \{        return Detail\+::\+Match\+Not\+Of\+Generic$<$MatcherT$>$\{matcher\};    \}        template$<$typename Matcher\+LHS, typename Arg\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+Base$<$Arg\+RHS$>$$>$$>$        operator \&\& (Matcher\+LHS const\& lhs, Matcher\+Base$<$Arg\+RHS$>$ const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Arg\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+All\+Of\+Generic$<$Matcher\+Base$<$Arg\+LHS$>$, Matcher\+RHS$>$$>$        operator \&\& (Matcher\+Base$<$Arg\+LHS$>$ const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Matcher\+LHS, typename Arg\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+Base$<$Arg\+RHS$>$$>$$>$        operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+LHS const\& lhs, Matcher\+Base$<$Arg\+RHS$>$ const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Arg\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Any\+Of\+Generic$<$Matcher\+Base$<$Arg\+LHS$>$, Matcher\+RHS$>$$>$        operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$Arg\+LHS$>$ const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}\} \} \#endif namespace Catch \{    namespace Matchers \{        class Is\+Empty\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)                using Catch\+::\+Detail\+::empty;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                using std\+::empty;\#endif                return empty(rng);            \}            std\+::string describe() const override;        \};        class Has\+Size\+Matcher final \+: public Matcher\+Generic\+Base \{            std\+::size\+\_\+t m\+\_\+target\+\_\+size;        public\+:            explicit Has\+Size\+Matcher(std\+::size\+\_\+t target\+\_\+size)\+:                m\+\_\+target\+\_\+size(target\+\_\+size)            \{\}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)                using Catch\+::\+Detail\+::size;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                using std\+::size;\#endif                return size(rng) == m\+\_\+target\+\_\+size;            \}            std\+::string describe() const override;        \};        template $<$typename Matcher$>$        class Size\+Matches\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            explicit Size\+Matches\+Matcher(Matcher m)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(m))            \{\}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)                using Catch\+::\+Detail\+::size;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                using std\+::size;\#endif                return m\+\_\+matcher.\+match(size(rng));            \}            std\+::string describe() const override \{                return "{}size matches "{} + m\+\_\+matcher.\+describe();            \}        \};                Is\+Empty\+Matcher Is\+Empty();                Has\+Size\+Matcher Size\+Is(std\+::size\+\_\+t sz);        template $<$typename Matcher$>$        std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+matcher$<$Matcher$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        Size\+Matches\+Matcher$<$Matcher$>$$>$ Size\+Is(Matcher\&\& m) \{            return Size\+Matches\+Matcher$<$Matcher$>$\{\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(m)\};        \}    \} \} \#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$\#include $<$functional$>$namespace Catch \{    namespace Matchers \{                template $<$typename T, typename Equality$>$        class Contains\+Element\+Matcher final \+: public Matcher\+Generic\+Base \{            T m\+\_\+desired;            Equality m\+\_\+eq;        public\+:            template $<$typename T2, typename Equality2$>$            Contains\+Element\+Matcher(T2\&\& target, Equality2\&\& predicate)\+:                m\+\_\+desired(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(target)),                m\+\_\+eq(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(predicate))            \{\}            std\+::string describe() const override \{                return "{}contains element "{} + Catch\+::\+Detail\+::stringify(m\+\_\+desired);            \}            template $<$typename Range\+Like$>$            bool match( Range\+Like\&\& rng ) const \{                for ( auto\&\& elem \+: rng ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+eq( elem, m\+\_\+desired ) ) \{ return true; \}                \}                return false;            \}        \};                template $<$typename Matcher$>$        class Contains\+Matcher\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:                                                Contains\+Matcher\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+matcher.\+match(elem)) \{                        return true;                    \}                \}                return false;            \}            std\+::string describe() const override \{                return "{}contains element matching "{} + m\+\_\+matcher.\+describe();            \}        \};                template $<$typename T$>$        std\+::enable\+\_\+if\+\_\+t$<$!Detail\+::is\+\_\+matcher$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        Contains\+Element\+Matcher$<$T, std\+::equal\+\_\+to$<$$>$$>$$>$ Contains(T\&\& elem) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(elem), std\+::equal\+\_\+to$<$$>$\{\} \};        \}                template $<$typename Matcher$>$        std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+matcher$<$Matcher$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        Contains\+Matcher\+Matcher$<$Matcher$>$$>$ Contains(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}                template $<$typename T, typename Equality$>$        Contains\+Element\+Matcher$<$T, Equality$>$ Contains(T\&\& elem, Equality\&\& eq) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(elem), \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(eq) \};        \}    \}\}\#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+EXCEPTION\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+EXCEPTION\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{namespace Matchers \{class Exception\+Message\+Matcher final \+: public Matcher\+Base$<$std\+::exception$>$ \{    std\+::string m\+\_\+message;public\+:    Exception\+Message\+Matcher(std\+::string const\& message)\+:        m\+\_\+message(message)    \{\}    bool match(std\+::exception const\& ex) const override;    std\+::string describe() const override;\};Exception\+Message\+Matcher Message(std\+::string const\& message);template $<$typename String\+Matcher\+Type$>$class Exception\+Message\+Matches\+Matcher final    \+: public Matcher\+Base$<$std\+::exception$>$ \{    String\+Matcher\+Type m\+\_\+matcher;public\+:    Exception\+Message\+Matches\+Matcher( String\+Matcher\+Type matcher )\+:        m\+\_\+matcher( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( matcher ) ) \{\}    bool match( std\+::exception const\& ex ) const override \{        return m\+\_\+matcher.\+match( ex.\+what() );    \}    std\+::string describe() const override \{        return "{} matches \textbackslash{}"{}"{} + m\+\_\+matcher.\+describe() + \textquotesingle{}"{}\textquotesingle{};    \}\};template $<$typename String\+Matcher\+Type$>$Exception\+Message\+Matches\+Matcher$<$String\+Matcher\+Type$>$Message\+Matches( String\+Matcher\+Type\&\& matcher ) \{    return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( matcher ) \};\}\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+EXCEPTION\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{namespace Matchers \{    namespace Detail \{        enum class Floating\+Point\+Kind \+: uint8\+\_\+t;    \}    class  Within\+Abs\+Matcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Within\+Abs\+Matcher(double target, double margin);        bool match(double const\& matchee) const override;        std\+::string describe() const override;    private\+:        double m\+\_\+target;        double m\+\_\+margin;    \};        Within\+Abs\+Matcher Within\+Abs( double target, double margin );    class Within\+Ulps\+Matcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Within\+Ulps\+Matcher( double target,                           uint64\+\_\+t ulps,                           Detail\+::\+Floating\+Point\+Kind base\+Type );        bool match(double const\& matchee) const override;        std\+::string describe() const override;    private\+:        double m\+\_\+target;        uint64\+\_\+t m\+\_\+ulps;        Detail\+::\+Floating\+Point\+Kind m\+\_\+type;    \};        Within\+Ulps\+Matcher Within\+ULP(double target, uint64\+\_\+t max\+Ulp\+Diff);        Within\+Ulps\+Matcher Within\+ULP(float target, uint64\+\_\+t max\+Ulp\+Diff);    // Given IEEE-\/754 format for floats and doubles, we can assume    // that float -\/$>$ double promotion is lossless. Given this, we can    // assume that \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} we do the standard relative comparison of    // \texorpdfstring{$\vert$}{|}lhs -\/ rhs\texorpdfstring{$\vert$}{|} $<$= epsilon \texorpdfstring{$\ast$}{*} max(fabs(lhs), fabs(rhs)), then we get    // the same \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} we do this for floats, as \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} we do this for    // doubles that were promoted from floats.    class Within\+Rel\+Matcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Within\+Rel\+Matcher( double target, double epsilon );        bool match(double const\& matchee) const override;        std\+::string describe() const override;    private\+:        double m\+\_\+target;        double m\+\_\+epsilon;    \};        Within\+Rel\+Matcher Within\+Rel(double target, double eps);        Within\+Rel\+Matcher Within\+Rel(double target);        Within\+Rel\+Matcher Within\+Rel(float target, float eps);        Within\+Rel\+Matcher Within\+Rel(float target);    class Is\+Na\+NMatcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Is\+Na\+NMatcher() = default;        bool match( double const\& matchee ) const override;        std\+::string describe() const override;    \};    Is\+Na\+NMatcher Is\+NaN();\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+PREDICATE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+PREDICATE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{namespace Matchers \{namespace Detail \{    std\+::string finalize\+Description(const std\+::string\& desc);\} // namespace Detailtemplate $<$typename T, typename Predicate$>$class Predicate\+Matcher final \+: public Matcher\+Base$<$T$>$ \{    Predicate m\+\_\+predicate;    std\+::string m\+\_\+description;public\+:    Predicate\+Matcher(Predicate\&\& elem, std\+::string const\& descr)        \+:m\+\_\+predicate(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(elem)),        m\+\_\+description(Detail\+::finalize\+Description(descr))    \{\}    bool match( T const\& item ) const override \{        return m\+\_\+predicate(item);    \}    std\+::string describe() const override \{        return m\+\_\+description;    \}\};    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Creates a matcher that calls delegates \`{}match\`{} to the provided predicate.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} The user has to explicitly specify the argument type to the matcher     \texorpdfstring{$\ast$}{*}/    template$<$typename T, typename Pred$>$    Predicate\+Matcher$<$T, Pred$>$ Predicate(Pred\&\& predicate, std\+::string const\& description = "{}"{}) \{        static\+\_\+assert(is\+\_\+callable$<$Pred(T)$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Predicate not callable with argument T"{});        static\+\_\+assert(std\+::is\+\_\+same$<$bool, Function\+Return\+Type$<$Pred, T$>$$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Predicate does not return bool"{});        return Predicate\+Matcher$<$T, Pred$>$(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(predicate), description);    \}\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+PREDICATE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+QUANTIFIERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+QUANTIFIERS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    namespace Matchers \{        // Matcher for checking that all elements in range matches a given matcher.        template $<$typename Matcher$>$        class All\+Match\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            All\+Match\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            std\+::string describe() const override \{                return "{}all match "{} + m\+\_\+matcher.\+describe();            \}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!m\+\_\+matcher.\+match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range matches a given matcher.        template $<$typename Matcher$>$        class None\+Match\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            None\+Match\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            std\+::string describe() const override \{                return "{}none match "{} + m\+\_\+matcher.\+describe();            \}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+matcher.\+match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that at least one element in range matches a given matcher.        template $<$typename Matcher$>$        class Any\+Match\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            Any\+Match\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            std\+::string describe() const override \{                return "{}any match "{} + m\+\_\+matcher.\+describe();            \}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+matcher.\+match(elem)) \{                        return true;                    \}                \}                return false;            \}        \};        // Matcher for checking that all elements in range are true.        class All\+True\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            std\+::string describe() const override;            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range is true.        class None\+True\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            std\+::string describe() const override;            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that any element in range is true.        class Any\+True\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            std\+::string describe() const override;            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (elem) \{                        return true;                    \}                \}                return false;            \}        \};        // Creates a matcher that checks whether all elements in a range match a matcher        template $<$typename Matcher$>$        All\+Match\+Matcher$<$Matcher$>$ All\+Match(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}        // Creates a matcher that checks whether no element in a range matches a matcher.        template $<$typename Matcher$>$        None\+Match\+Matcher$<$Matcher$>$ None\+Match(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}        // Creates a matcher that checks whether any element in a range matches a matcher.        template $<$typename Matcher$>$        Any\+Match\+Matcher$<$Matcher$>$ Any\+Match(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}        // Creates a matcher that checks whether all elements in a range are true        All\+True\+Matcher All\+True();        // Creates a matcher that checks whether no element in a range is true        None\+True\+Matcher None\+True();        // Creates a matcher that checks whether any element in a range is true        Any\+True\+Matcher Any\+True();    \}\}\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+QUANTIFIERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+RANGE\+\_\+\+EQUALS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+RANGE\+\_\+\+EQUALS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$\#include $<$utility$>$namespace Catch \{    namespace Matchers \{        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Matcher for checking that an element contains the same         \texorpdfstring{$\ast$}{*} elements in the same order         \texorpdfstring{$\ast$}{*}/        template $<$typename Target\+Range\+Like, typename Equality$>$        class Range\+Equals\+Matcher final \+: public Matcher\+Generic\+Base \{            Target\+Range\+Like m\+\_\+desired;            Equality m\+\_\+predicate;        public\+:            template $<$typename Target\+Range\+Like2, typename Equality2$>$            Range\+Equals\+Matcher( Target\+Range\+Like2\&\& range,                                Equality2\&\& predicate )\+:                m\+\_\+desired( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ) ),                m\+\_\+predicate( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) ) \{\}            template $<$typename Range\+Like$>$            bool match( Range\+Like\&\& rng ) const \{                auto rng\+\_\+start = begin( rng );                const auto rng\+\_\+end = end( rng );                auto target\+\_\+start = begin( m\+\_\+desired );                const auto target\+\_\+end = end( m\+\_\+desired );                while (rng\+\_\+start != rng\+\_\+end \&\& target\+\_\+start != target\+\_\+end) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!m\+\_\+predicate(\texorpdfstring{$\ast$}{*}rng\+\_\+start, \texorpdfstring{$\ast$}{*}target\+\_\+start)) \{                        return false;                    \}                    ++rng\+\_\+start;                    ++target\+\_\+start;                \}                return rng\+\_\+start == rng\+\_\+end \&\& target\+\_\+start == target\+\_\+end;            \}            std\+::string describe() const override \{                return "{}elements are "{} + Catch\+::\+Detail\+::stringify( m\+\_\+desired );            \}        \};        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Matcher for checking that an element contains the same         \texorpdfstring{$\ast$}{*} elements (but not necessarily in the same order)         \texorpdfstring{$\ast$}{*}/        template $<$typename Target\+Range\+Like, typename Equality$>$        class Unordered\+Range\+Equals\+Matcher final \+: public Matcher\+Generic\+Base \{            Target\+Range\+Like m\+\_\+desired;            Equality m\+\_\+predicate;        public\+:            template $<$typename Target\+Range\+Like2, typename Equality2$>$            Unordered\+Range\+Equals\+Matcher( Target\+Range\+Like2\&\& range,                                         Equality2\&\& predicate )\+:                m\+\_\+desired( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ) ),                m\+\_\+predicate( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) ) \{\}            template $<$typename Range\+Like$>$            bool match( Range\+Like\&\& rng ) const \{                using std\+::begin;                using std\+::end;                return \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::is\+\_\+permutation}}( begin( m\+\_\+desired ),                                                      end( m\+\_\+desired ),                                                      begin( rng ),                                                      end( rng ),                                                      m\+\_\+predicate );            \}            std\+::string describe() const override \{                return "{}unordered elements are "{} +                       \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+desired );            \}        \};        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses \`{}std\+::equal\+\_\+to\`{} to do the comparison         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like$>$        std\+::enable\+\_\+if\+\_\+t$<$!Detail\+::is\+\_\+matcher$<$Range\+Like$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                         Range\+Equals\+Matcher$<$Range\+Like, std\+::equal\+\_\+to$<$$>$$>$$>$        Range\+Equals( Range\+Like\&\& range ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), std\+::equal\+\_\+to$<$$>$\{\} \};        \}        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses to provided predicate \`{}predicate\`{} to do the comparisons         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like, typename Equality$>$        Range\+Equals\+Matcher$<$Range\+Like, Equality$>$        Range\+Equals( Range\+Like\&\& range, Equality\&\& predicate ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) \};        \}        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range, in some permutation         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses \`{}std\+::equal\+\_\+to\`{} to do the comparison         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like$>$        std\+::enable\+\_\+if\+\_\+t$<$            !Detail\+::is\+\_\+matcher$<$Range\+Like$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Unordered\+Range\+Equals\+Matcher$<$Range\+Like, std\+::equal\+\_\+to$<$$>$$>$$>$        Unordered\+Range\+Equals( Range\+Like\&\& range ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), std\+::equal\+\_\+to$<$$>$\{\} \};        \}        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range, in some permutation.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses to provided predicate \`{}predicate\`{} to do the comparisons         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like, typename Equality$>$        Unordered\+Range\+Equals\+Matcher$<$Range\+Like, Equality$>$        Unordered\+Range\+Equals( Range\+Like\&\& range, Equality\&\& predicate ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) \};        \}    \} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+RANGE\+\_\+\+EQUALS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{namespace Matchers \{    struct Cased\+String \{        Cased\+String( std\+::string const\& str, Case\+Sensitive case\+Sensitivity );        std\+::string adjust\+String( std\+::string const\& str ) const;        String\+Ref case\+Sensitivity\+Suffix() const;        Case\+Sensitive m\+\_\+case\+Sensitivity;        std\+::string m\+\_\+str;    \};    class String\+Matcher\+Base \+: public Matcher\+Base$<$std\+::string$>$ \{    protected\+:        Cased\+String m\+\_\+comparator;        String\+Ref m\+\_\+operation;    public\+:        String\+Matcher\+Base( String\+Ref operation,                           Cased\+String const\& comparator );        std\+::string describe() const override;    \};    class String\+Equals\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        String\+Equals\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class String\+Contains\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        String\+Contains\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class Starts\+With\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        Starts\+With\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class Ends\+With\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        Ends\+With\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class Regex\+Matcher final \+: public Matcher\+Base$<$std\+::string$>$ \{        std\+::string m\+\_\+regex;        Case\+Sensitive m\+\_\+case\+Sensitivity;    public\+:        Regex\+Matcher( std\+::string regex, Case\+Sensitive case\+Sensitivity );        bool match( std\+::string const\& matchee ) const override;        std\+::string describe() const override;    \};        String\+Equals\+Matcher Equals( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        String\+Contains\+Matcher Contains\+Substring( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        Ends\+With\+Matcher Ends\+With( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        Starts\+With\+Matcher Starts\+With( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        Regex\+Matcher Matches( std\+::string const\& regex, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+VECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+VECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$namespace Catch \{namespace Matchers \{    template$<$typename T, typename Alloc$>$    class Vector\+Contains\+Element\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc$>$$>$ \{        T const\& m\+\_\+comparator;    public\+:        Vector\+Contains\+Element\+Matcher(T const\& comparator)\+:            m\+\_\+comparator(comparator)        \{\}        bool match(std\+::vector$<$T, Alloc$>$ const\& v) const override \{            for (auto const\& el \+: v) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (el == m\+\_\+comparator) \{                    return true;                \}            \}            return false;        \}        std\+::string describe() const override \{            return "{}Contains\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Contains\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+comparator;    public\+:        Contains\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator)\+:            m\+\_\+comparator( comparator )        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& v) const override \{            // !TBD\+: see note in Equals\+Matcher            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+comparator.\+size() $>$ v.\+size())                return false;            for (auto const\& comparator \+: m\+\_\+comparator) \{                auto present = false;                for (const auto\& el \+: v) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (el == comparator) \{                        present = true;                        break;                    \}                \}                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!present) \{                    return false;                \}            \}            return true;        \}        std\+::string describe() const override \{            return "{}Contains\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Equals\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+comparator;    public\+:        Equals\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator)\+:            m\+\_\+comparator( comparator )        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& v) const override \{            // !TBD\+: This currently works \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements can be compared using !=            // -\/ a more general approach would be via a compare template that defaults            // to using !=. but could be specialised for, e.\+g. std\+::vector$<$T$>$ etc            // -\/ then just call that directly            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+comparator.\+size() != v.\+size() ) \{ return false; \}            for ( std\+::size\+\_\+t i = 0; i $<$ v.\+size(); ++i ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( !( m\+\_\+comparator\mbox{[}i\mbox{]} == v\mbox{[}i\mbox{]} ) ) \{ return false; \}            \}            return true;        \}        std\+::string describe() const override \{            return "{}Equals\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Approx\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+comparator;        mutable \mbox{\hyperlink{class_catch_1_1_approx}{Catch\+::\+Approx}} approx = \mbox{\hyperlink{class_catch_1_1_approx_aae48202f7bf38b6e3ebfaac7ef46b7af}{Catch\+::\+Approx\+::custom}}();    public\+:        Approx\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator)\+:            m\+\_\+comparator( comparator )        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& v) const override \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+comparator.\+size() != v.\+size())                return false;            for (std\+::size\+\_\+t i = 0; i $<$ v.\+size(); ++i)                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+comparator\mbox{[}i\mbox{]} != approx(v\mbox{[}i\mbox{]}))                    return false;            return true;        \}        std\+::string describe() const override \{            return "{}is approx\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}        template $<$typename = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+constructible$<$double, T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Approx\+Matcher\& epsilon( T const\& new\+Epsilon ) \{            approx.\+epsilon(static\+\_\+cast$<$double$>$(new\+Epsilon));            return \texorpdfstring{$\ast$}{*}this;        \}        template $<$typename = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+constructible$<$double, T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Approx\+Matcher\& margin( T const\& new\+Margin ) \{            approx.\+margin(static\+\_\+cast$<$double$>$(new\+Margin));            return \texorpdfstring{$\ast$}{*}this;        \}        template $<$typename = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+constructible$<$double, T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Approx\+Matcher\& scale( T const\& new\+Scale ) \{            approx.\+scale(static\+\_\+cast$<$double$>$(new\+Scale));            return \texorpdfstring{$\ast$}{*}this;        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Unordered\+Equals\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+target;    public\+:        Unordered\+Equals\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& target)\+:            m\+\_\+target(target)        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& vec) const override \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+target.\+size() != vec.\+size()) \{                return false;            \}            return std\+::is\+\_\+permutation(m\+\_\+target.\+begin(), m\+\_\+target.\+end(), vec.\+begin());        \}        std\+::string describe() const override \{            return "{}Unordered\+Equals\+: "{} + \+::\+Catch\+::\+Detail\+::stringify(m\+\_\+target);        \}    \};    // The following functions create the actual matcher objects.    // This allows the types to be inferred        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Contains\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Contains( std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator ) \{        return Contains\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(comparator);    \}        template$<$typename T, typename Alloc = std\+::allocator$<$T$>$$>$    Vector\+Contains\+Element\+Matcher$<$T, Alloc$>$ Vector\+Contains( T const\& comparator ) \{        return Vector\+Contains\+Element\+Matcher$<$T, Alloc$>$(comparator);    \}        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Equals( std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator ) \{        return Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(comparator);    \}        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Approx\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Approx( std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator ) \{        return Approx\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(comparator);    \}        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Unordered\+Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Unordered\+Equals(std\+::vector$<$T, Alloc\+Comp$>$ const\& target) \{        return Unordered\+Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(target);    \}\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+VECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED/\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \textbackslash{}file \texorpdfstring{$\ast$}{*} This is a convenience header for Catch2\textquotesingle{}s Reporter support. It includes \texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}all\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} of Catch2 headers related to reporters, including all reporters. \texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*} Generally the Catch2 users should use specific includes they need, \texorpdfstring{$\ast$}{*} but this header can be used instead for ease-\/of-\/experimentation, or \texorpdfstring{$\ast$}{*} just plain convenience, at the cost of (significantly) increased \texorpdfstring{$\ast$}{*} compilation times. \texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*} When a new header (reporter) is added to either the \`{}reporter\`{} folder, \texorpdfstring{$\ast$}{*} or to the corresponding internal subfolder, it should be added here. \texorpdfstring{$\ast$}{*}/\#ifndef CATCH\+\_\+\+REPORTERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+AUTOMAKE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+AUTOMAKE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+STREAMING\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+STREAMING\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+COMMON\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+COMMON\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$map$>$\#include $<$string$>$namespace Catch \{    class Colour\+Impl;    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} This is the base class for all reporters.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} If are writing a reporter, you must derive from this type, or one     \texorpdfstring{$\ast$}{*} of the helper reporter bases that are derived from this type.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Reporter\+Base centralizes handling of various common tasks in reporters,     \texorpdfstring{$\ast$}{*} like storing the right \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} for the reporters to write to, and     \texorpdfstring{$\ast$}{*} providing the default implementation of the different listing events.     \texorpdfstring{$\ast$}{*}/    class Reporter\+Base \+: public IEvent\+Listener \{    protected\+:                Detail\+::unique\+\_\+ptr$<$IStream$>$ m\+\_\+wrapped\+\_\+stream;                        std\+::ostream\& m\+\_\+stream;                Detail\+::unique\+\_\+ptr$<$Colour\+Impl$>$ \mbox{\hyperlink{catch__amalgamated_8cpp_a4359931fc656b120d087d978af7a052c}{m\+\_\+colour}};                std\+::map$<$std\+::string, std\+::string$>$ m\+\_\+custom\+Options;    public\+:        Reporter\+Base( Reporter\+Config\&\& config );        \texorpdfstring{$\sim$}{\string~}Reporter\+Base() override; // = default;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of reporters.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Should look roughly like the reporter listing in v2 and earlier         \texorpdfstring{$\ast$}{*} versions of Catch2.         \texorpdfstring{$\ast$}{*}/        void list\+Reporters(            std\+::vector$<$Reporter\+Description$>$ const\& descriptions ) override;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of listeners         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Looks similarly to listing of reporters, but with listener type         \texorpdfstring{$\ast$}{*} instead of reporter name.         \texorpdfstring{$\ast$}{*}/        void list\+Listeners(            std\+::vector$<$Listener\+Description$>$ const\& descriptions ) override;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of tests.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Should look roughly like the test listing in v2 and earlier versions         \texorpdfstring{$\ast$}{*} of Catch2. Especially supports low-\/verbosity listing that mimics the         \texorpdfstring{$\ast$}{*} old \`{}-\/-\/list-\/test-\/names-\/only\`{} output.         \texorpdfstring{$\ast$}{*}/        void list\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& tests ) override;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of tags.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Should look roughly like the tag listing in v2 and earlier versions         \texorpdfstring{$\ast$}{*} of Catch2.         \texorpdfstring{$\ast$}{*}/        void list\+Tags( std\+::vector$<$Tag\+Info$>$ const\& tags ) override;    \};\} // namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+COMMON\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    class Streaming\+Reporter\+Base \+: public Reporter\+Base \{    public\+:        // GCC5 compat\+: we cannot use inherited constructor, because it        //              doesn\textquotesingle{}t implement backport of P0136        Streaming\+Reporter\+Base(Reporter\+Config\&\& \+\_\+config)\+:            Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config))        \{\}        \texorpdfstring{$\sim$}{\string~}Streaming\+Reporter\+Base() override;        void benchmark\+Preparing( String\+Ref ) override \{\}        void benchmark\+Starting( Benchmark\+Info const\& ) override \{\}        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& ) override \{\}        void benchmark\+Failed( String\+Ref ) override \{\}        void fatal\+Error\+Encountered( String\+Ref /\texorpdfstring{$\ast$}{*}error\texorpdfstring{$\ast$}{*}/ ) override \{\}        void no\+Matching\+Test\+Cases( String\+Ref /\texorpdfstring{$\ast$}{*}unmatched\+Spec\texorpdfstring{$\ast$}{*}/ ) override \{\}        void report\+Invalid\+Test\+Spec( String\+Ref /\texorpdfstring{$\ast$}{*}invalid\+Argument\texorpdfstring{$\ast$}{*}/ ) override \{\}        void test\+Run\+Starting( Test\+Run\+Info const\& \+\_\+test\+Run\+Info ) override;        void test\+Case\+Starting(Test\+Case\+Info const\& \+\_\+test\+Info) override  \{            current\+Test\+Case\+Info = \&\+\_\+test\+Info;        \}        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\&, uint64\+\_\+t ) override \{\}        void section\+Starting(Section\+Info const\& \+\_\+section\+Info) override \{            m\+\_\+section\+Stack.\+push\+\_\+back(\+\_\+section\+Info);        \}        void assertion\+Starting( Assertion\+Info const\& ) override \{\}        void assertion\+Ended( Assertion\+Stats const\& ) override \{\}        void section\+Ended(Section\+Stats const\& /\texorpdfstring{$\ast$}{*} \+\_\+section\+Stats \texorpdfstring{$\ast$}{*}/) override \{            m\+\_\+section\+Stack.\+pop\+\_\+back();        \}        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\&, uint64\+\_\+t ) override \{\}        void test\+Case\+Ended(Test\+Case\+Stats const\& /\texorpdfstring{$\ast$}{*} \+\_\+test\+Case\+Stats \texorpdfstring{$\ast$}{*}/) override \{            current\+Test\+Case\+Info = nullptr;        \}        void test\+Run\+Ended( Test\+Run\+Stats const\& /\texorpdfstring{$\ast$}{*} \+\_\+test\+Run\+Stats \texorpdfstring{$\ast$}{*}/ ) override;        void skip\+Test(Test\+Case\+Info const\&) override \{            // Don\textquotesingle{}t do anything with this by default.            // It can optionally be overridden in the derived class.        \}    protected\+:        Test\+Run\+Info current\+Test\+Run\+Info\{ "{}test run has not started yet"{}\+\_\+sr \};        Test\+Case\+Info const\texorpdfstring{$\ast$}{*} current\+Test\+Case\+Info = nullptr;                std\+::vector$<$Section\+Info$>$ m\+\_\+section\+Stack;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+STREAMING\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    class Automake\+Reporter final \+: public Streaming\+Reporter\+Base \{    public\+:        // GCC5 compat\+: we cannot use inherited constructor, because it        //              doesn\textquotesingle{}t implement backport of P0136        Automake\+Reporter(Reporter\+Config\&\& \+\_\+config)\+:            Streaming\+Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config))        \{\}        \texorpdfstring{$\sim$}{\string~}Automake\+Reporter() override;        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results in the format of Automake .trs files"{}s;        \}        void test\+Case\+Ended(Test\+Case\+Stats const\& \+\_\+test\+Case\+Stats) override;        void skip\+Test(Test\+Case\+Info const\& test\+Info) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+AUTOMAKE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+COMPACT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+COMPACT\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Compact\+Reporter final \+: public Streaming\+Reporter\+Base \{    public\+:        using Streaming\+Reporter\+Base\+::\+Streaming\+Reporter\+Base;        \texorpdfstring{$\sim$}{\string~}Compact\+Reporter() override;        static std\+::string get\+Description();        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void test\+Run\+Starting( Test\+Run\+Info const\& \+\_\+test\+Info ) override;        void assertion\+Ended(Assertion\+Stats const\& \+\_\+assertion\+Stats) override;        void section\+Ended(Section\+Stats const\& \+\_\+section\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& \+\_\+test\+Run\+Stats) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+COMPACT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    // Fwd decls    class Table\+Printer;    class Console\+Reporter final \+: public Streaming\+Reporter\+Base \{        Detail\+::unique\+\_\+ptr$<$Table\+Printer$>$ m\+\_\+table\+Printer;    public\+:        Console\+Reporter(Reporter\+Config\&\& config);        \texorpdfstring{$\sim$}{\string~}Console\+Reporter() override;        static std\+::string get\+Description();        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void report\+Invalid\+Test\+Spec( String\+Ref arg ) override;        void assertion\+Starting(Assertion\+Info const\&) override;        void assertion\+Ended(Assertion\+Stats const\& \+\_\+assertion\+Stats) override;        void section\+Starting(Section\+Info const\& \+\_\+section\+Info) override;        void section\+Ended(Section\+Stats const\& \+\_\+section\+Stats) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting(Benchmark\+Info const\& info) override;        void benchmark\+Ended(Benchmark\+Stats$<$$>$ const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}}) override;        void benchmark\+Failed( String\+Ref error ) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& \+\_\+test\+Case\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& \+\_\+test\+Run\+Stats) override;        void test\+Run\+Starting(Test\+Run\+Info const\& \+\_\+test\+Run\+Info) override;    private\+:        void lazy\+Print();        void lazy\+Print\+Without\+Closing\+Benchmark\+Table();        void lazy\+Print\+Run\+Info();        void print\+Test\+Case\+And\+Section\+Header();        void print\+Closed\+Header(std\+::string const\& \+\_\+name);        void print\+Open\+Header(std\+::string const\& \+\_\+name);        // \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} string has a \+: in first line will set indent to follow it on        // subsequent lines        void print\+Header\+String(std\+::string const\& \+\_\+string, std\+::size\+\_\+t indent = 0);        void print\+Totals\+Divider(Totals const\& totals);        bool m\+\_\+header\+Printed = false;        bool m\+\_\+test\+Run\+Info\+Printed = false;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+CUMULATIVE\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+CUMULATIVE\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    namespace Detail \{                class Assertion\+Or\+Benchmark\+Result \{            // This should really be a variant, but this is much faster            // to write and the \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{data}} layout here is already terrible            // enough that we do not have to care about the object size.            Optional$<$Assertion\+Stats$>$ m\+\_\+assertion;            Optional$<$Benchmark\+Stats$<$$>$$>$ m\+\_\+benchmark;        public\+:            Assertion\+Or\+Benchmark\+Result(Assertion\+Stats const\& assertion);            Assertion\+Or\+Benchmark\+Result(Benchmark\+Stats$<$$>$ const\& benchmark);            bool is\+Assertion() const;            bool is\+Benchmark() const;            Assertion\+Stats const\& as\+Assertion() const;            Benchmark\+Stats$<$$>$ const\& as\+Benchmark() const;        \};    \}    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Utility base for reporters that need to handle all results at once     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} It stores tree of all test cases, sections and assertions, and after the     \texorpdfstring{$\ast$}{*} test run is finished, calls into \`{}test\+Run\+Ended\+Cumulative\`{} to pass the     \texorpdfstring{$\ast$}{*} control to the deriving class.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} If you are deriving from this class and override any testing related     \texorpdfstring{$\ast$}{*} member functions, you should first call into the base\textquotesingle{}s implementation to     \texorpdfstring{$\ast$}{*} avoid breaking the tree construction.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Due to the way this base functions, it has to expand assertions up-\/front,     \texorpdfstring{$\ast$}{*} even \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} they are later unused (e.\+g. because the deriving reporter does     \texorpdfstring{$\ast$}{*} not report successful assertions, or because the deriving reporter does     \texorpdfstring{$\ast$}{*} not use assertion expansion at all). Derived classes can use two     \texorpdfstring{$\ast$}{*} customization points, \`{}m\+\_\+should\+Store\+Succesful\+Assertions\`{} and     \texorpdfstring{$\ast$}{*} \`{}m\+\_\+should\+Store\+Failed\+Assertions\`{}, to disable the expansion and gain extra     \texorpdfstring{$\ast$}{*} performance. \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}Accessing the assertion expansions \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} it wasn\textquotesingle{}t stored is     \texorpdfstring{$\ast$}{*} UB.\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*}/    class Cumulative\+Reporter\+Base \+: public Reporter\+Base \{    public\+:        template$<$typename T, typename Child\+NodeT$>$        struct Node \{            explicit Node( T const\& \+\_\+value ) \+: \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}( \+\_\+value ) \{\}            using Child\+Nodes = std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Child\+NodeT$>$$>$;            T \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}};            Child\+Nodes children;        \};        struct Section\+Node \{            explicit Section\+Node(Section\+Stats const\& \+\_\+stats) \+: \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}}(\+\_\+stats) \{\}            bool operator == (Section\+Node const\& other) const \{                return stats.\+section\+Info.\+line\+Info == other.\+stats.\+section\+Info.\+line\+Info;            \}            bool has\+Any\+Assertions() const;            Section\+Stats \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}};            std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Section\+Node$>$$>$ child\+Sections;            std\+::vector$<$Detail\+::\+Assertion\+Or\+Benchmark\+Result$>$ assertions\+And\+Benchmarks;            std\+::string std\+Out;            std\+::string std\+Err;        \};        using Test\+Case\+Node = Node$<$Test\+Case\+Stats, Section\+Node$>$;        using Test\+Run\+Node = Node$<$Test\+Run\+Stats, Test\+Case\+Node$>$;        // GCC5 compat\+: we cannot use inherited constructor, because it        //              doesn\textquotesingle{}t implement backport of P0136        Cumulative\+Reporter\+Base(Reporter\+Config\&\& \+\_\+config)\+:            Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config))        \{\}        \texorpdfstring{$\sim$}{\string~}Cumulative\+Reporter\+Base() override;        void benchmark\+Preparing( String\+Ref ) override \{\}        void benchmark\+Starting( Benchmark\+Info const\& ) override \{\}        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) override;        void benchmark\+Failed( String\+Ref ) override \{\}        void no\+Matching\+Test\+Cases( String\+Ref ) override \{\}        void report\+Invalid\+Test\+Spec( String\+Ref ) override \{\}        void fatal\+Error\+Encountered( String\+Ref /\texorpdfstring{$\ast$}{*}error\texorpdfstring{$\ast$}{*}/ ) override \{\}        void test\+Run\+Starting( Test\+Run\+Info const\& ) override \{\}        void test\+Case\+Starting( Test\+Case\+Info const\& ) override \{\}        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\&, uint64\+\_\+t ) override \{\}        void section\+Starting( Section\+Info const\& section\+Info ) override;        void assertion\+Starting( Assertion\+Info const\& ) override \{\}        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\&, uint64\+\_\+t ) override \{\}        void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) override;                virtual void test\+Run\+Ended\+Cumulative() = 0;        void skip\+Test(Test\+Case\+Info const\&) override \{\}    protected\+:                bool m\+\_\+should\+Store\+Succesful\+Assertions = true;                bool m\+\_\+should\+Store\+Failed\+Assertions = true;        // We need lazy construction here. We should probably refactor it        // later, after the events are redone.                Detail\+::unique\+\_\+ptr$<$Test\+Run\+Node$>$ m\+\_\+test\+Run;    private\+:        // Note\+: We rely on pointer identity being stable, which is why        //       we store pointers to the nodes rather than the values.        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Test\+Case\+Node$>$$>$ m\+\_\+test\+Cases;        // Root section of the \+\_\+current\+\_\+ test case        Detail\+::unique\+\_\+ptr$<$Section\+Node$>$ m\+\_\+root\+Section;        // Deepest section of the \+\_\+current\+\_\+ test case        Section\+Node\texorpdfstring{$\ast$}{*} m\+\_\+deepest\+Section = nullptr;        // Stack of \+\_\+active\+\_\+ sections in the \+\_\+current\+\_\+ test case        std\+::vector$<$Section\+Node\texorpdfstring{$\ast$}{*}$>$ m\+\_\+section\+Stack;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+CUMULATIVE\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+EVENT\+\_\+\+LISTENER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+EVENT\+\_\+\+LISTENER\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Base class to simplify implementing listeners.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Provides empty default implementation for all IEvent\+Listener member     \texorpdfstring{$\ast$}{*} functions, so that a listener implementation can pick which     \texorpdfstring{$\ast$}{*} member functions it actually cares about.     \texorpdfstring{$\ast$}{*}/    class Event\+Listener\+Base \+: public IEvent\+Listener \{    public\+:        using IEvent\+Listener\+::\+IEvent\+Listener;        void report\+Invalid\+Test\+Spec( String\+Ref unmatched\+Spec ) override;        void fatal\+Error\+Encountered( String\+Ref error ) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& benchmark\+Info ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) override;        void benchmark\+Failed( String\+Ref error ) override;        void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) override;        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        void list\+Reporters(            std\+::vector$<$Reporter\+Description$>$ const\& descriptions ) override;        void list\+Listeners(            std\+::vector$<$Listener\+Description$>$ const\& descriptions ) override;        void list\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& tests ) override;        void list\+Tags( std\+::vector$<$Tag\+Info$>$ const\& tag\+Infos ) override;        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) override;        void test\+Case\+Starting( Test\+Case\+Info const\& test\+Info ) override;        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\& test\+Info,                                      uint64\+\_\+t part\+Number ) override;        void section\+Starting( Section\+Info const\& section\+Info ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats,                                   uint64\+\_\+t part\+Number ) override;        void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) override;        void skip\+Test( Test\+Case\+Info const\& test\+Info ) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+EVENT\+\_\+\+LISTENER\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    class IConfig;    class Test\+Case\+Handle;    class Colour\+Impl;    // Returns double formatted as \%.\+3f (format expected on output)    std\+::string get\+Formatted\+Duration( double duration );        bool should\+Show\+Duration( IConfig const\& config, double duration );    std\+::string serialize\+Filters( std\+::vector$<$std\+::string$>$ const\& filters );    struct line\+Of\+Chars \{        char c;        constexpr line\+Of\+Chars( char c\+\_\+ )\+: c( c\+\_\+ ) \{\}        friend std\+::ostream\& operator$<$$<$( std\+::ostream\& out, line\+Of\+Chars \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );    \};    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists reporter descriptions to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly     \texorpdfstring{$\ast$}{*} format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used as the default listing implementation by the first party reporter     \texorpdfstring{$\ast$}{*} bases. The output should be backwards compatible with the output of     \texorpdfstring{$\ast$}{*} Catch2 v2 binaries.     \texorpdfstring{$\ast$}{*}/    void    default\+List\+Reporters( std\+::ostream\& out,                          std\+::vector$<$Reporter\+Description$>$ const\& descriptions,                          Verbosity verbosity );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists listeners descriptions to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly     \texorpdfstring{$\ast$}{*} format     \texorpdfstring{$\ast$}{*}/    void default\+List\+Listeners( std\+::ostream\& out,                               std\+::vector$<$Listener\+Description$>$ const\& descriptions );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists tag information to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used as the default listing implementation by the first party reporter     \texorpdfstring{$\ast$}{*} bases. The output should be backwards compatible with the output of     \texorpdfstring{$\ast$}{*} Catch2 v2 binaries.     \texorpdfstring{$\ast$}{*}/    void default\+List\+Tags( std\+::ostream\& out, std\+::vector$<$Tag\+Info$>$ const\& tags, bool is\+Filtered );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists test case information to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly     \texorpdfstring{$\ast$}{*} format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used as the default listing implementation by the first party reporter     \texorpdfstring{$\ast$}{*} bases. The output is backwards compatible with the output of Catch2     \texorpdfstring{$\ast$}{*} v2 binaries, and also supports the format specific to the old     \texorpdfstring{$\ast$}{*} \`{}-\/-\/list-\/test-\/names-\/only\`{} option, for people who used it in integrations.     \texorpdfstring{$\ast$}{*}/    void default\+List\+Tests( std\+::ostream\& out,                           Colour\+Impl\texorpdfstring{$\ast$}{*} stream\+Colour,                           std\+::vector$<$Test\+Case\+Handle$>$ const\& tests,                           bool is\+Filtered,                           Verbosity verbosity );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Prints test run totals to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used by the console and compact reporters.     \texorpdfstring{$\ast$}{*}/    void print\+Test\+Run\+Totals( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}},                      Colour\+Impl\& stream\+Colour,                      Totals const\& totals );\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+JSON\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+JSON\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$stack$>$namespace Catch \{    class Json\+Reporter \+: public Streaming\+Reporter\+Base \{    public\+:        Json\+Reporter( Reporter\+Config\&\& config );        \texorpdfstring{$\sim$}{\string~}Json\+Reporter() override;        static std\+::string get\+Description();    public\+: // Streaming\+Reporter\+Base        void test\+Run\+Starting( Test\+Run\+Info const\& run\+Info ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& run\+Stats ) override;        void test\+Case\+Starting( Test\+Case\+Info const\& tc\+Info ) override;        void test\+Case\+Ended( Test\+Case\+Stats const\& tc\+Stats ) override;        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\& tc\+Info,                                      uint64\+\_\+t index ) override;        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\& tc\+Stats,                                   uint64\+\_\+t index ) override;        void section\+Starting( Section\+Info const\& section\+Info ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) override;        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        //void test\+Run\+Ended\+Cumulative() override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& ) override;        void benchmark\+Failed( String\+Ref error ) override;        void list\+Reporters(            std\+::vector$<$Reporter\+Description$>$ const\& descriptions ) override;        void list\+Listeners(            std\+::vector$<$Listener\+Description$>$ const\& descriptions ) override;        void list\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& tests ) override;        void list\+Tags( std\+::vector$<$Tag\+Info$>$ const\& tags ) override;    private\+:        Timer m\+\_\+test\+Case\+Timer;        enum class Writer \{            Object,            Array        \};        Json\+Array\+Writer\& start\+Array();        Json\+Array\+Writer\& start\+Array( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}{key}} );        Json\+Object\+Writer\& start\+Object();        Json\+Object\+Writer\& start\+Object( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}{key}} );        void end\+Object();        void end\+Array();        bool is\+Inside( Writer writer );        void start\+Listing();        void end\+Listing();        // Invariant\+:        // When m\+\_\+writers is not empty and its top element is        // -\/ Writer\+::\+Object, then m\+\_\+object\+Writers is not be empty        // -\/ Writer\+::\+Array,  then m\+\_\+array\+Writers shall not be empty        std\+::stack$<$Json\+Object\+Writer$>$ m\+\_\+object\+Writers\{\};        std\+::stack$<$Json\+Array\+Writer$>$ m\+\_\+array\+Writers\{\};        std\+::stack$<$Writer$>$ m\+\_\+writers\{\};        bool m\+\_\+started\+Listing = false;        // std\+::size\+\_\+t m\+\_\+section\+Depth = 0;        // std\+::size\+\_\+t m\+\_\+section\+Started = 0;    \};\} // namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+JSON\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+JUNIT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+JUNIT\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Junit\+Reporter final \+: public Cumulative\+Reporter\+Base \{    public\+:        Junit\+Reporter(Reporter\+Config\&\& \+\_\+config);        static std\+::string get\+Description();        void test\+Run\+Starting(Test\+Run\+Info const\& run\+Info) override;        void test\+Case\+Starting(Test\+Case\+Info const\& test\+Case\+Info) override;        void assertion\+Ended(Assertion\+Stats const\& assertion\+Stats) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats) override;        void test\+Run\+Ended\+Cumulative() override;    private\+:        void write\+Run(Test\+Run\+Node const\& test\+Run\+Node, double suite\+Time);        void write\+Test\+Case(Test\+Case\+Node const\& test\+Case\+Node);        void write\+Section( std\+::string const\& class\+Name,                           std\+::string const\& root\+Name,                           Section\+Node const\& section\+Node,                           bool test\+Ok\+To\+Fail );        void write\+Assertions(Section\+Node const\& section\+Node);        void write\+Assertion(Assertion\+Stats const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}});        Xml\+Writer xml;        Timer suite\+Timer;        std\+::string std\+Out\+For\+Suite;        std\+::string std\+Err\+For\+Suite;        unsigned int unexpected\+Exceptions = 0;        bool m\+\_\+ok\+To\+Fail = false;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+JUNIT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+MULTI\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+MULTI\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Multi\+Reporter final \+: public IEvent\+Listener \{        /\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Stores all added reporters and listeners         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} All Listeners are stored before all reporters, and individual         \texorpdfstring{$\ast$}{*} listeners/reporters are stored in order of insertion.         \texorpdfstring{$\ast$}{*}/        std\+::vector$<$IEvent\+Listener\+Ptr$>$ m\+\_\+reporter\+Likes;        bool m\+\_\+have\+Noncapturing\+Reporters = false;        // Keep track of how many listeners we have already inserted,        // so that we can insert them into the \mbox{\hyperlink{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}} vector at the right place        size\+\_\+t m\+\_\+inserted\+Listeners = 0;        void update\+Preferences(IEvent\+Listener const\& reporterish);    public\+:        using IEvent\+Listener\+::\+IEvent\+Listener;        void add\+Listener( IEvent\+Listener\+Ptr\&\& listener );        void add\+Reporter( IEvent\+Listener\+Ptr\&\& reporter );    public\+: // IEvent\+Listener        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void fatal\+Error\+Encountered( String\+Ref error ) override;        void report\+Invalid\+Test\+Spec( String\+Ref arg ) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& benchmark\+Info ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) override;        void benchmark\+Failed( String\+Ref error ) override;        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) override;        void test\+Case\+Starting( Test\+Case\+Info const\& test\+Info ) override;        void test\+Case\+Partial\+Starting(Test\+Case\+Info const\& test\+Info, uint64\+\_\+t part\+Number) override;        void section\+Starting( Section\+Info const\& section\+Info ) override;        void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) override;        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void test\+Case\+Partial\+Ended(Test\+Case\+Stats const\& test\+Stats, uint64\+\_\+t part\+Number) override;        void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) override;        void skip\+Test( Test\+Case\+Info const\& test\+Info ) override;        void list\+Reporters(std\+::vector$<$Reporter\+Description$>$ const\& descriptions) override;        void list\+Listeners(std\+::vector$<$Listener\+Description$>$ const\& descriptions) override;        void list\+Tests(std\+::vector$<$Test\+Case\+Handle$>$ const\& tests) override;        void list\+Tags(std\+::vector$<$Tag\+Info$>$ const\& tags) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+MULTI\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRARS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRARS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$type\+\_\+traits$>$namespace Catch \{    namespace Detail \{        template $<$typename T, typename = void$>$        struct has\+\_\+description \+: std\+::false\+\_\+type \{\};        template $<$typename T$>$        struct has\+\_\+description$<$            T,            void\+\_\+t$<$decltype( T\+::get\+Description() )$>$$>$            \+: std\+::true\+\_\+type \{\};                        void register\+Reporter\+Impl( std\+::string const\& name,                                   IReporter\+Factory\+Ptr reporter\+Ptr );                void register\+Listener\+Impl( Detail\+::unique\+\_\+ptr$<$Event\+Listener\+Factory$>$ listener\+Factory );    \} // namespace Detail    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;    template $<$typename T$>$    class Reporter\+Factory \+: public IReporter\+Factory \{        IEvent\+Listener\+Ptr create( Reporter\+Config\&\& config ) const override \{            return Detail\+::make\+\_\+unique$<$T$>$( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(config) );        \}        std\+::string get\+Description() const override \{            return T\+::get\+Description();        \}    \};    template$<$typename T$>$    class Reporter\+Registrar \{    public\+:        explicit Reporter\+Registrar( std\+::string const\& name ) \{            register\+Reporter\+Impl( name,                                  Detail\+::make\+\_\+unique$<$Reporter\+Factory$<$T$>$$>$() );        \}    \};    template$<$typename T$>$    class Listener\+Registrar \{        class Typed\+Listener\+Factory \+: public Event\+Listener\+Factory \{            String\+Ref m\+\_\+listener\+Name;            std\+::string get\+Description\+Impl( std\+::true\+\_\+type ) const \{                return T\+::get\+Description();            \}            std\+::string get\+Description\+Impl( std\+::false\+\_\+type ) const \{                return "{}(No description provided)"{};            \}        public\+:            Typed\+Listener\+Factory( String\+Ref listener\+Name )\+:                m\+\_\+listener\+Name( listener\+Name ) \{\}            IEvent\+Listener\+Ptr create( IConfig const\texorpdfstring{$\ast$}{*} config ) const override \{                return Detail\+::make\+\_\+unique$<$T$>$( config );            \}            String\+Ref get\+Name() const override \{                return m\+\_\+listener\+Name;            \}            std\+::string get\+Description() const override \{                return get\+Description\+Impl( Detail\+::has\+\_\+description$<$T$>$\{\} );            \}        \};    public\+:        Listener\+Registrar(String\+Ref listener\+Name) \{            register\+Listener\+Impl( Detail\+::make\+\_\+unique$<$Typed\+Listener\+Factory$>$(listener\+Name) );        \}    \};\}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)\#    define CATCH\+\_\+\+REGISTER\+\_\+\+REPORTER( name, reporter\+Type )                      \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a1500dca9a578a0bd2f85771cfa3fd35d}{CATCH\+\_\+\+INTERNAL\+\_\+\+START\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}                              \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_aa0200c23b35ba2bd8ebed69a8f3c1c66}{CATCH\+\_\+\+INTERNAL\+\_\+\+SUPPRESS\+\_\+\+GLOBALS\+\_\+\+WARNINGS}}                               \textbackslash{}        namespace \{                                                            \textbackslash{}            Catch\+::\+Reporter\+Registrar$<$reporter\+Type$>$ \mbox{\hyperlink{catch__amalgamated_8hpp_afe320ceec108fc8c160f9ac3938f1bc8}{INTERNAL\+\_\+\+CATCH\+\_\+\+UNIQUE\+\_\+\+NAME}}( \textbackslash{}                catch\+\_\+internal\+\_\+\+Registrar\+For )( name );                         \textbackslash{}        \}                                                                      \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_ad9594e9891b032f0dd0279960dc861a5}{CATCH\+\_\+\+INTERNAL\+\_\+\+STOP\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}\#    define CATCH\+\_\+\+REGISTER\+\_\+\+LISTENER( listener\+Type )                            \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a1500dca9a578a0bd2f85771cfa3fd35d}{CATCH\+\_\+\+INTERNAL\+\_\+\+START\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}                              \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_aa0200c23b35ba2bd8ebed69a8f3c1c66}{CATCH\+\_\+\+INTERNAL\+\_\+\+SUPPRESS\+\_\+\+GLOBALS\+\_\+\+WARNINGS}}                               \textbackslash{}        namespace \{                                                            \textbackslash{}            Catch\+::\+Listener\+Registrar$<$listener\+Type$>$ \mbox{\hyperlink{catch__amalgamated_8hpp_afe320ceec108fc8c160f9ac3938f1bc8}{INTERNAL\+\_\+\+CATCH\+\_\+\+UNIQUE\+\_\+\+NAME}}( \textbackslash{}                catch\+\_\+internal\+\_\+\+Registrar\+For )( \#listener\+Type\#\#\+\_\+catch\+\_\+sr );     \textbackslash{}        \}                                                                      \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_ad9594e9891b032f0dd0279960dc861a5}{CATCH\+\_\+\+INTERNAL\+\_\+\+STOP\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} // CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\#define CATCH\+\_\+\+REGISTER\+\_\+\+REPORTER(name, reporter\+Type)\#define CATCH\+\_\+\+REGISTER\+\_\+\+LISTENER(listener\+Type)\#endif // CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRARS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+SONARQUBE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+SONARQUBE\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Sonar\+Qube\+Reporter final \+: public Cumulative\+Reporter\+Base \{    public\+:        Sonar\+Qube\+Reporter(Reporter\+Config\&\& config)        \+: Cumulative\+Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(config))        , xml(m\+\_\+stream) \{            m\+\_\+preferences.\+should\+Redirect\+Std\+Out = true;            m\+\_\+preferences.\+should\+Report\+All\+Assertions = true;            m\+\_\+should\+Store\+Succesful\+Assertions = false;        \}        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results in the Generic Test Data Sonar\+Qube XML format"{}s;        \}        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) override;        void test\+Run\+Ended\+Cumulative() override \{            write\+Run( \texorpdfstring{$\ast$}{*}m\+\_\+test\+Run );            xml.\+end\+Element();        \}        void write\+Run( Test\+Run\+Node const\& run\+Node );        void write\+Test\+File(String\+Ref filename, std\+::vector$<$Test\+Case\+Node const\texorpdfstring{$\ast$}{*}$>$ const\& test\+Case\+Nodes);        void write\+Test\+Case(Test\+Case\+Node const\& test\+Case\+Node);        void write\+Section(std\+::string const\& root\+Name, Section\+Node const\& section\+Node, bool ok\+To\+Fail);        void write\+Assertions(Section\+Node const\& section\+Node, bool ok\+To\+Fail);        void write\+Assertion(Assertion\+Stats const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}}, bool ok\+To\+Fail);    private\+:        Xml\+Writer xml;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+SONARQUBE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+TAP\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+TAP\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class TAPReporter final \+: public Streaming\+Reporter\+Base \{    public\+:        TAPReporter( Reporter\+Config\&\& config )\+:            Streaming\+Reporter\+Base( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(config) ) \{            m\+\_\+preferences.\+should\+Report\+All\+Assertions = true;        \}        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results in TAP format, suitable for test harnesses"{}s;        \}        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Info ) override;        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void assertion\+Ended(Assertion\+Stats const\& \+\_\+assertion\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& \+\_\+test\+Run\+Stats) override;    private\+:        std\+::size\+\_\+t \mbox{\hyperlink{catch__amalgamated_8cpp_ac449e05964ab2319a33c1718c5ad485b}{counter}} = 0;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+TAP\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+TEAMCITY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+TEAMCITY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstring$>$\#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#   pragma clang diagnostic push\#   pragma clang diagnostic ignored "{}-\/Wpadded"{}\#endifnamespace Catch \{    class Team\+City\+Reporter final \+: public Streaming\+Reporter\+Base \{    public\+:        Team\+City\+Reporter( Reporter\+Config\&\& \+\_\+config )        \+:   Streaming\+Reporter\+Base( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config) )        \{            m\+\_\+preferences.\+should\+Redirect\+Std\+Out = true;        \}        \texorpdfstring{$\sim$}{\string~}Team\+City\+Reporter() override;        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results as Team\+City service messages"{}s;        \}        void test\+Run\+Starting( Test\+Run\+Info const\& run\+Info ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& run\+Stats ) override;        void assertion\+Ended(Assertion\+Stats const\& assertion\+Stats) override;        void section\+Starting(Section\+Info const\& section\+Info) override \{            m\+\_\+header\+Printed\+For\+This\+Section = false;            Streaming\+Reporter\+Base\+::section\+Starting( section\+Info );        \}        void test\+Case\+Starting(Test\+Case\+Info const\& test\+Info) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats) override;    private\+:        void print\+Section\+Header(std\+::ostream\& os);        bool m\+\_\+header\+Printed\+For\+This\+Section = false;        Timer m\+\_\+test\+Timer;    \};\} // end namespace Catch\#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#   pragma clang diagnostic pop\#endif\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+TEAMCITY\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+XML\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+XML\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Xml\+Reporter \+: public Streaming\+Reporter\+Base \{    public\+:        Xml\+Reporter(Reporter\+Config\&\& \+\_\+config);        \texorpdfstring{$\sim$}{\string~}Xml\+Reporter() override;        static std\+::string get\+Description();        virtual std\+::string get\+Stylesheet\+Ref() const;        void write\+Source\+Info(Source\+Line\+Info const\& source\+Info);    public\+: // Streaming\+Reporter\+Base        void test\+Run\+Starting(Test\+Run\+Info const\& test\+Info) override;        void test\+Case\+Starting(Test\+Case\+Info const\& test\+Info) override;        void section\+Starting(Section\+Info const\& section\+Info) override;        void assertion\+Starting(Assertion\+Info const\&) override;        void assertion\+Ended(Assertion\+Stats const\& assertion\+Stats) override;        void section\+Ended(Section\+Stats const\& section\+Stats) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& test\+Run\+Stats) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting(Benchmark\+Info const\&) override;        void benchmark\+Ended(Benchmark\+Stats$<$$>$ const\&) override;        void benchmark\+Failed( String\+Ref error ) override;        void list\+Reporters(std\+::vector$<$Reporter\+Description$>$ const\& descriptions) override;        void list\+Listeners(std\+::vector$<$Listener\+Description$>$ const\& descriptions) override;        void list\+Tests(std\+::vector$<$Test\+Case\+Handle$>$ const\& tests) override;        void list\+Tags(std\+::vector$<$Tag\+Info$>$ const\& tags) override;    private\+:        Timer m\+\_\+test\+Case\+Timer;        Xml\+Writer m\+\_\+xml;        int m\+\_\+section\+Depth = 0;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+XML\+\_\+\+HPP\+\_\+\+INCLUDED\#endif // CATCH\+\_\+\+REPORTERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#endif // \mbox{\hyperlink{catch__amalgamated_8hpp_a46e230da206ed7d95ccf9f8c57f39f99}{CATCH\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED}}\#endif // CATCH\+\_\+\+AMALGAMATED\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+WINDOWS\+\_\+\+H\+\_\+\+PROXY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+WINDOWS\+\_\+\+H\+\_\+\+PROXY\+\_\+\+HPP\+\_\+\+INCLUDED\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+PLATFORM\+\_\+\+WINDOWS)// We might end up with the define made globally through the compiler,// and we don\textquotesingle{}t want to trigger warnings for this\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(NOMINMAX)\#  define NOMINMAX\#endif\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(WIN32\+\_\+\+LEAN\+\_\+\+AND\+\_\+\+MEAN)\#  define WIN32\+\_\+\+LEAN\+\_\+\+AND\+\_\+\+MEAN\#endif\#include $<$windows.\+h$>$\#endif // defined(CATCH\+\_\+\+PLATFORM\+\_\+\+WINDOWS)\#endif // CATCH\+\_\+\+WINDOWS\+\_\+\+H\+\_\+\+PROXY\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            Chronometer\+Concept\+::\texorpdfstring{$\sim$}{\string~}\+Chronometer\+Concept() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.\#include $<$vector$>$namespace Catch \{    namespace Benchmark \{        namespace Detail \{            Sample\+Analysis analyse(const IConfig \&cfg, FDuration\texorpdfstring{$\ast$}{*} first, FDuration\texorpdfstring{$\ast$}{*} last) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!cfg.\+benchmark\+No\+Analysis()) \{                    std\+::vector$<$double$>$ samples;                    samples.\+reserve(static\+\_\+cast$<$size\+\_\+t$>$(last -\/ first));                    for (auto current = first; current != last; ++current) \{                        samples.\+push\+\_\+back( current-\/$>$count() );                    \}                    auto analysis = \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a1a4ae7ccc7fa8c996bc6e4ada5a7004b}{Catch\+::\+Benchmark\+::\+Detail\+::analyse\+\_\+samples}}(                        cfg.\+benchmark\+Confidence\+Interval(),                        cfg.\+benchmark\+Resamples(),                        \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}(),                        \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}() + samples.\+size() );                    auto outliers = \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a523468c0e7dbf99ffb1801aad78e352d}{Catch\+::\+Benchmark\+::\+Detail\+::classify\+\_\+outliers}}(                        \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}(), \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}() + samples.\+size() );                    auto wrap\+\_\+estimate = \mbox{[}$\,$\mbox{]}(Estimate$<$double$>$ e) \{                        return Estimate$<$FDuration$>$ \{                            FDuration(e.\+point),                                FDuration(e.\+lower\+\_\+bound),                                FDuration(e.\+upper\+\_\+bound),                                e.\+confidence\+\_\+interval,                        \};                    \};                    std\+::vector$<$FDuration$>$ samples2;                    samples2.\+reserve(samples.\+size());                    for (auto s \+: samples) \{                        samples2.\+push\+\_\+back( FDuration( s ) );                    \}                    return \{                        \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(samples2),                        wrap\+\_\+estimate(analysis.\+mean),                        wrap\+\_\+estimate(analysis.\+standard\+\_\+deviation),                        outliers,                        analysis.\+outlier\+\_\+variance,                    \};                \} \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} \{                    std\+::vector$<$FDuration$>$ samples;                    samples.\+reserve(static\+\_\+cast$<$size\+\_\+t$>$(last -\/ first));                    FDuration mean = FDuration(0);                    int i = 0;                    for (auto it = first; it $<$ last; ++it, ++i) \{                        samples.\+push\+\_\+back(\texorpdfstring{$\ast$}{*}it);                        mean += \texorpdfstring{$\ast$}{*}it;                    \}                    mean /= i;                    return Sample\+Analysis\{                        \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(samples),                        Estimate$<$FDuration$>$\{ mean, mean, mean, 0.\+0 \},                        Estimate$<$FDuration$>$\{ FDuration( 0 ),                                             FDuration( 0 ),                                             FDuration( 0 ),                                             0.\+0 \},                        Outlier\+Classification\{\},                        0.\+0                    \};                \}            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catchnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            Benchmark\+Function\+::callable\+::\texorpdfstring{$\sim$}{\string~}callable() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch\#include $<$exception$>$namespace Catch \{    namespace Benchmark \{        namespace Detail \{            struct optimized\+\_\+away\+\_\+error \+: std\+::exception \{                const char\texorpdfstring{$\ast$}{*} what() const noexcept override;            \};            const char\texorpdfstring{$\ast$}{*} optimized\+\_\+away\+\_\+error\+::what() const noexcept \{                return "{}could not measure benchmark, maybe it was optimized away"{};            \}            void throw\+\_\+optimized\+\_\+away\+\_\+error() \{                \mbox{\hyperlink{namespace_catch_a3cbceeab9252d1b752f66a2826e92548}{Catch\+::throw\+\_\+exception}}(optimized\+\_\+away\+\_\+error\{\});            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.\#include $<$algorithm$>$\#include $<$cassert$>$\#include $<$cmath$>$\#include $<$cstddef$>$\#include $<$numeric$>$\#include $<$random$>$\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+USE\+\_\+\+ASYNC)\#include $<$future$>$\#endifnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            namespace \{                template $<$typename URng, typename Estimator$>$                static sample                resample( URng\& rng,                          unsigned int resamples,                          double const\texorpdfstring{$\ast$}{*} first,                          double const\texorpdfstring{$\ast$}{*} last,                          Estimator\& estimator ) \{                    auto n = static\+\_\+cast$<$size\+\_\+t$>$( last -\/ first );                    Catch\+::uniform\+\_\+integer\+\_\+distribution$<$size\+\_\+t$>$ dist( 0, n -\/ 1 );                    sample out;                    out.\+reserve( resamples );                    std\+::vector$<$double$>$ resampled;                    resampled.\+reserve( n );                    for ( size\+\_\+t i = 0; i $<$ resamples; ++i ) \{                        resampled.\+clear();                        for ( size\+\_\+t s = 0; s $<$ n; ++s ) \{                            resampled.\+push\+\_\+back( first\mbox{[}dist( rng )\mbox{]} );                        \}                        const auto estimate =                            estimator( \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{resampled.\+data}}(), \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{resampled.\+data}}() + resampled.\+size() );                        out.\+push\+\_\+back( estimate );                    \}                    std\+::sort( out.\+begin(), out.\+end() );                    return out;                \}                static double outlier\+\_\+variance( Estimate$<$double$>$ mean,                                                Estimate$<$double$>$ stddev,                                                int n ) \{                    double sb = stddev.\+point;                    double mn = mean.\+point / n;                    double mg\+\_\+min = mn / 2.;                    double sg = (std\+::min)( mg\+\_\+min / 4., sb / std\+::sqrt( n ) );                    double sg2 = sg \texorpdfstring{$\ast$}{*} sg;                    double sb2 = sb \texorpdfstring{$\ast$}{*} sb;                    auto c\+\_\+max = \mbox{[}n, mn, sb2, sg2\mbox{]}( double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) -\/$>$ double \{                        double k = mn -\/ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}};                        double d = k \texorpdfstring{$\ast$}{*} k;                        double nd = n \texorpdfstring{$\ast$}{*} d;                        double k0 = -\/n \texorpdfstring{$\ast$}{*} nd;                        double k1 = sb2 -\/ n \texorpdfstring{$\ast$}{*} sg2 + nd;                        double det = k1 \texorpdfstring{$\ast$}{*} k1 -\/ 4 \texorpdfstring{$\ast$}{*} sg2 \texorpdfstring{$\ast$}{*} k0;                        return static\+\_\+cast$<$int$>$( -\/2. \texorpdfstring{$\ast$}{*} k0 /                                                 ( k1 + std\+::sqrt( det ) ) );                    \};                    auto var\+\_\+out = \mbox{[}n, sb2, sg2\mbox{]}( double c ) \{                        double nc = n -\/ c;                        return ( nc / n ) \texorpdfstring{$\ast$}{*} ( sb2 -\/ nc \texorpdfstring{$\ast$}{*} sg2 );                    \};                    return (std\+::min)( var\+\_\+out( 1 ),                                       var\+\_\+out(                                           (std\+::min)( c\+\_\+max( 0. ),                                                       c\+\_\+max( mg\+\_\+min ) ) ) ) /                           sb2;                \}                static double erf\+\_\+inv( double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) \{                    // Code accompanying the article "{}Approximating the erfinv
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{namespace_catch_aa5d4bbf2380d3781343c4eefcb3456b9}{Catch\+::\+Registry\+Hub\+Singleton}} = Singleton$<$Registry\+Hub, \mbox{\hyperlink{class_catch_1_1_i_registry_hub}{IRegistry\+Hub}}, \mbox{\hyperlink{class_catch_1_1_i_mutable_registry_hub}{IMutable\+Registry\+Hub}}$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \mbox{\hyperlink{namespace_catch_1_1_matchers_1_1_detail_a65dcb4c6cc6803847848523398ae680c}{Catch\+::\+Matchers\+::\+Detail\+::\+Floating\+Point\+Kind}} \+: uint8\+\_\+t \{ \mbox{\hyperlink{namespace_catch_1_1_matchers_1_1_detail_a65dcb4c6cc6803847848523398ae680ca22ae0e2b89e5e3d477f988cc36d3272b}{Catch\+::\+Matchers\+::\+Detail\+::\+Float}}
, \mbox{\hyperlink{namespace_catch_1_1_matchers_1_1_detail_a65dcb4c6cc6803847848523398ae680cad909d38d705ce75386dd86e611a82f5b}{Catch\+::\+Matchers\+::\+Detail\+::\+Double}}
 \}
\item 
enum class \mbox{\hyperlink{namespace_catch_a3ae9998b7d4a81417ea68591451a4fd6}{Catch\+::\+Justification}} \{ \mbox{\hyperlink{namespace_catch_a3ae9998b7d4a81417ea68591451a4fd6a945d5e233cf7d6240f6b783b36a374ff}{Catch\+::\+Left}}
, \mbox{\hyperlink{namespace_catch_a3ae9998b7d4a81417ea68591451a4fd6a92b09c7c48c520c3c55e497875da437c}{Catch\+::\+Right}}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (\mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}}$<$ 6.\+250000)
\item 
double \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a571030d8a3068b49d454220cfdea714f}{Catch\+::\+Benchmark\+::\+Detail\+::weighted\+\_\+average\+\_\+quantile}} (int k, int q, double \texorpdfstring{$\ast$}{*}first, double \texorpdfstring{$\ast$}{*}last)
\item 
\mbox{\hyperlink{struct_catch_1_1_benchmark_1_1_outlier_classification}{Outlier\+Classification}} \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a523468c0e7dbf99ffb1801aad78e352d}{Catch\+::\+Benchmark\+::\+Detail\+::classify\+\_\+outliers}} (double const \texorpdfstring{$\ast$}{*}first, double const \texorpdfstring{$\ast$}{*}last)
\item 
double \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_ac5f830d662344dd75387c26aa83e6ac3}{Catch\+::\+Benchmark\+::\+Detail\+::mean}} (double const \texorpdfstring{$\ast$}{*}first, double const \texorpdfstring{$\ast$}{*}last)
\item 
double \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_abc5e70b0f758f550b2fdff85512efdb5}{Catch\+::\+Benchmark\+::\+Detail\+::normal\+\_\+cdf}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}})
\item 
double \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a62d6c634e2c8901d02ffe8718817f1b4}{Catch\+::\+Benchmark\+::\+Detail\+::erfc\+\_\+inv}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}})
\item 
double \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_af3527090cdeb0456b1aacbdc29050841}{Catch\+::\+Benchmark\+::\+Detail\+::normal\+\_\+quantile}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}})
\item 
\mbox{\hyperlink{struct_catch_1_1_benchmark_1_1_estimate}{Estimate}}$<$ double $>$ \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a0a635ce60c227f5217d9606e2afe527c}{Catch\+::\+Benchmark\+::\+Detail\+::bootstrap}} (double confidence\+\_\+level, double \texorpdfstring{$\ast$}{*}first, double \texorpdfstring{$\ast$}{*}last, \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_ad7bb71eb022618e4a57e3378f5d70b13}{sample}} const \&resample, double(\texorpdfstring{$\ast$}{*}estimator)(double const \texorpdfstring{$\ast$}{*}, double const \texorpdfstring{$\ast$}{*}))
\item 
\mbox{\hyperlink{struct_catch_1_1_benchmark_1_1_detail_1_1bootstrap__analysis}{bootstrap\+\_\+analysis}} \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a1a4ae7ccc7fa8c996bc6e4ada5a7004b}{Catch\+::\+Benchmark\+::\+Detail\+::analyse\+\_\+samples}} (double confidence\+\_\+level, unsigned int n\+\_\+resamples, double \texorpdfstring{$\ast$}{*}first, double \texorpdfstring{$\ast$}{*}last)
\item 
\mbox{\hyperlink{class_catch_1_1_approx}{Approx}} \mbox{\hyperlink{namespace_catch_1_1literals_af610e11bcfe94ebc07788fdcf1b716b7}{Catch\+::literals\+::operator"{}"{}\+\_\+a}} (long double val)
\item 
\mbox{\hyperlink{class_catch_1_1_approx}{Approx}} \mbox{\hyperlink{namespace_catch_1_1literals_ad9c310bd2eaacfd7c23f7a5a1fc587bf}{Catch\+::literals\+::operator"{}"{}\+\_\+a}} (unsigned long long val)
\item 
bool \mbox{\hyperlink{namespace_catch_a2842e594466b16b9ca13e09077b44406}{Catch\+::operator==}} (\mbox{\hyperlink{struct_catch_1_1_processed_reporter_spec}{Processed\+Reporter\+Spec}} const \&lhs, \mbox{\hyperlink{struct_catch_1_1_processed_reporter_spec}{Processed\+Reporter\+Spec}} const \&rhs)
\item 
std\+::uint32\+\_\+t \mbox{\hyperlink{namespace_catch_aba921d5844aa120874480fe71d1c1ae3}{Catch\+::get\+Seed}} ()
\begin{DoxyCompactList}\small\item\em Returns Catch2\textquotesingle{}s current RNG seed. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_catch_1_1_i_registry_hub}{IRegistry\+Hub}} const \& \mbox{\hyperlink{namespace_catch_a5d328566cb8da87b48f1fac3f319ac7a}{Catch\+::get\+Registry\+Hub}} ()
\item 
\mbox{\hyperlink{class_catch_1_1_i_mutable_registry_hub}{IMutable\+Registry\+Hub}} \& \mbox{\hyperlink{namespace_catch_a585459763f2c7610e57de2dd22dd1ad8}{Catch\+::get\+Mutable\+Registry\+Hub}} ()
\item 
void \mbox{\hyperlink{namespace_catch_a0f78e9afdebc6d4512d18e76fbf54b8c}{Catch\+::clean\+Up}} ()
\item 
std\+::string \mbox{\hyperlink{namespace_catch_adafff91485eeeeb9e9333f317cc0e3b1}{Catch\+::translate\+Active\+Exception}} ()
\item 
bool \mbox{\hyperlink{namespace_catch_ad31a3e3a246a7ae3b28d62db42ad5837}{Catch\+::operator$<$}} (\mbox{\hyperlink{struct_catch_1_1_tag}{Tag}} const \&lhs, \mbox{\hyperlink{struct_catch_1_1_tag}{Tag}} const \&rhs)
\item 
bool \mbox{\hyperlink{namespace_catch_a757e5758cf4ec14df26ff166f3db43ab}{Catch\+::operator==}} (\mbox{\hyperlink{struct_catch_1_1_tag}{Tag}} const \&lhs, \mbox{\hyperlink{struct_catch_1_1_tag}{Tag}} const \&rhs)
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{struct_catch_1_1_test_case_info}{Test\+Case\+Info}} $>$ \mbox{\hyperlink{namespace_catch_ac0bff8ed2ec530c293ad520bf2ce7075}{Catch\+::make\+Test\+Case\+Info}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} \+\_\+class\+Name, \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{Name\+And\+Tags}} const \&name\+And\+Tags, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{Source\+Line\+Info}} const \&\+\_\+line\+Info)
\item 
bool \mbox{\hyperlink{namespace_catch_ab9aaac3d0fbc3b4b371541fd21ffb8ad}{Catch\+::operator$<$}} (\mbox{\hyperlink{struct_catch_1_1_test_case_info}{Test\+Case\+Info}} const \&lhs, \mbox{\hyperlink{struct_catch_1_1_test_case_info}{Test\+Case\+Info}} const \&rhs)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_1_1_detail_a23bdcac0ef138b222c3747e2af979e9a}{Catch\+::\+Detail\+::convert\+Into\+String}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} string, \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{bool}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{escape\+Invisibles}})
\begin{DoxyCompactList}\small\item\em Encases \`{}string in quotes, and optionally escapes invisibles. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespace_catch_1_1_detail_a0dc4241ab150d3d8e1d0a3d30c781c39}{Catch\+::\+Detail\+::convert\+Into\+String}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} string)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_1_1_detail_ac5d6c510e565ee5bddcc2236194ce29e}{Catch\+::\+Detail\+::raw\+Memory\+To\+String}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{const}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{object}}, std\+::size\+\_\+t size)
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{void}} \mbox{\hyperlink{namespace_catch_1_1_detail_a60f033a91680546a152f5dfa4427104c}{Catch\+::\+Detail\+::register\+Translator\+Impl}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{class_catch_1_1_i_exception_translator}{IException\+Translator}} $>$ \&\&\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{translator}})
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_aa7e8f5954fada348761e0473b3e4c1a2}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{struct_catch_1_1_version}{Version}} const \&version)
\item 
\mbox{\hyperlink{struct_catch_1_1_version}{Version}} const \& \mbox{\hyperlink{namespace_catch_a35e54475ed669ef7f7ac00b858e91b2a}{Catch\+::library\+Version}} ()
\item 
void \mbox{\hyperlink{namespace_catch_1_1_generators_1_1_detail_ab6e4736f7a2b0501a13c4dc4adfe5bb6}{Catch\+::\+Generators\+::\+Detail\+::throw\+\_\+generator\+\_\+exception}} (char const \texorpdfstring{$\ast$}{*}msg)
\begin{DoxyCompactList}\small\item\em Throws \doxylink{class_catch_1_1_generator_exception}{Generator\+Exception} with the provided message. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_catch_1_1_i_generator_tracker}{IGenerator\+Tracker}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespace_catch_1_1_generators_ab0ad55177ac1e5f00b123909b191f436}{Catch\+::\+Generators\+::acquire\+Generator\+Tracker}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} generator\+Name, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{Source\+Line\+Info}} const \&line\+Info)
\item 
\mbox{\hyperlink{class_catch_1_1_i_generator_tracker}{IGenerator\+Tracker}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespace_catch_1_1_generators_a24e1bac2be5e078f26c395a96470b706}{Catch\+::\+Generators\+::create\+Generator\+Tracker}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} generator\+Name, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{Source\+Line\+Info}} line\+Info, \mbox{\hyperlink{namespace_catch_1_1_generators_aa9dc8fef28828fe351480d5be7bb287d}{Generator\+Base\+Ptr}} \&\&generator)
\item 
std\+::uint32\+\_\+t \mbox{\hyperlink{namespace_catch_1_1_generators_1_1_detail_a43ff3ca07ca525084cadb89dee13e39e}{Catch\+::\+Generators\+::\+Detail\+::get\+Seed}} ()
\item 
void \mbox{\hyperlink{namespace_catch_a26cdeefafe46a4d606b51248eb7bbe7e}{Catch\+::handle\+Exception\+Match\+Expr}} (\mbox{\hyperlink{class_catch_1_1_assertion_handler}{Assertion\+Handler}} \&handler, std\+::string const \&str)
\item 
\mbox{\hyperlink{namespace_catch_1_1_clara_1_1_detail_a6822080555d7f8f7fb6f8149c7819c42}{Parser\+Result}} \mbox{\hyperlink{namespace_catch_1_1_clara_1_1_detail_ab5b76a1843c33a4a71aa698a3defc528}{Catch\+::\+Clara\+::\+Detail\+::convert\+Into}} (std\+::string const \&source, std\+::string \&target)
\item 
\mbox{\hyperlink{namespace_catch_1_1_clara_1_1_detail_a6822080555d7f8f7fb6f8149c7819c42}{Parser\+Result}} \mbox{\hyperlink{namespace_catch_1_1_clara_1_1_detail_aaf5cc67b22b463d47af6e69ee31bf44e}{Catch\+::\+Clara\+::\+Detail\+::convert\+Into}} (std\+::string const \&source, bool \&target)
\item 
\mbox{\hyperlink{class_catch_1_1_clara_1_1_parser}{Clara\+::\+Parser}} \mbox{\hyperlink{namespace_catch_a96d773398ae9697da7845bbf5027e35e}{Catch\+::make\+Command\+Line\+Parser}} (\mbox{\hyperlink{struct_catch_1_1_config_data}{Config\+Data}} \&config)
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ Colour\+Impl $>$ \mbox{\hyperlink{namespace_catch_a66d288723373b192f025a2f4ed2f3f11}{Catch\+::make\+Colour\+Impl}} (\mbox{\hyperlink{namespace_catch_a91308e87521e370e591065a22b010025}{Colour\+Mode}} colour\+Selection, IStream \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}})
\item 
bool \mbox{\hyperlink{namespace_catch_a76a7aa70b229be45ef1eec1d5ca8d87c}{Catch\+::is\+Colour\+Impl\+Available}} (\mbox{\hyperlink{namespace_catch_a91308e87521e370e591065a22b010025}{Colour\+Mode}} colour\+Selection)
\item 
void \mbox{\hyperlink{namespace_catch_ae50508f10ffc4ed873a31a4db4caea16}{Catch\+::clean\+Up\+Context}} ()
\item 
\mbox{\hyperlink{class_catch_1_1_context}{Context}} \& \mbox{\hyperlink{namespace_catch_aeb5fab7ca94d3e959fd7db6167caf5ee}{Catch\+::get\+Current\+Mutable\+Context}} ()
\item 
\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Simple\+Pcg32}} \& \mbox{\hyperlink{namespace_catch_a95e86995bfdce76fca887634094ef2e9}{Catch\+::shared\+Rng}} ()
\item 
void \mbox{\hyperlink{namespace_catch_aa5dcf4750ce9a854f4b74d3c952d13cc}{Catch\+::write\+To\+Debug\+Console}} (std\+::string const \&text)
\item 
bool \mbox{\hyperlink{namespace_catch_ab079497368fb1df25af39ad494d2a241}{Catch\+::is\+Debugger\+Active}} ()
\item 
void \mbox{\hyperlink{namespace_catch_a520110c31f26cf9892595772ab814fc0}{Catch\+::format\+Reconstructed\+Expression}} (std\+::ostream \&os, std\+::string const \&lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} op, std\+::string const \&rhs)
\item 
void \mbox{\hyperlink{namespace_catch_a3cbceeab9252d1b752f66a2826e92548}{Catch\+::throw\+\_\+exception}} (std\+::exception const \&e)
\item 
void \mbox{\hyperlink{namespace_catch_a707884e681203fef6bf7dbf752532fa5}{Catch\+::throw\+\_\+logic\+\_\+error}} (std\+::string const \&msg)
\item 
void \mbox{\hyperlink{namespace_catch_ae67297c3e265b0fcd55de371bf408e4e}{Catch\+::throw\+\_\+domain\+\_\+error}} (std\+::string const \&msg)
\item 
void \mbox{\hyperlink{namespace_catch_a48d2c35022dd9d56a1b7ee78ad581eea}{Catch\+::throw\+\_\+runtime\+\_\+error}} (std\+::string const \&msg)
\item 
std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} $>$ \mbox{\hyperlink{namespace_catch_1_1_detail_a4e0e09e87f561af2d3a881b209a9a481}{Catch\+::\+Detail\+::parse\+Enums}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{enums}})
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{Enum\+Info}} $>$ \mbox{\hyperlink{namespace_catch_1_1_detail_a4f0c01d00fa6af891eb82fcf9baaf95c}{Catch\+::\+Detail\+::make\+Enum\+Info}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{enum\+Name}}, \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{all\+Value\+Names}}, std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{int}} $>$ \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{const}} \&values)
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{uint32\+\_\+t}} \mbox{\hyperlink{namespace_catch_1_1_detail_ade51091dea188100d1c7a8acc55f5ea5}{Catch\+::\+Detail\+::convert\+To\+Bits}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{float}} f)
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{uint64\+\_\+t}} \mbox{\hyperlink{namespace_catch_1_1_detail_aa4cbea1ca1087603043d57005bbbec54}{Catch\+::\+Detail\+::convert\+To\+Bits}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{double}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{d}})
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{bool}} \mbox{\hyperlink{namespace_catch_1_1_detail_a18fef8312d01399bbf5722432f099216}{Catch\+::\+Detail\+::direct\+Compare}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{float}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{lhs}}, \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{float}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{rhs}})
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{bool}} \mbox{\hyperlink{namespace_catch_1_1_detail_a4e6b189b0908b0866a4f79b5ba5f9b7d}{Catch\+::\+Detail\+::direct\+Compare}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{double}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{lhs}}, \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{double}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{rhs}})
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{char}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{const}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespace_catch_1_1_detail_a9a53cd3f44546dfc2935a3a6d3277ce6}{Catch\+::\+Detail\+::get\+Env}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{char}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{const}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{var\+Name}})
\item 
auto \mbox{\hyperlink{namespace_catch_a375b927ff7cc5356ff4a71626d54c83f}{Catch\+::make\+Stream}} (std\+::string const \&filename) -\/$>$ \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ IStream $>$
\item 
auto \mbox{\hyperlink{namespace_catch_abf821d46e662c8d93d80a98d79a10314}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{class_catch_1_1_lazy_expression}{Lazy\+Expression}} const \&lazy\+Expr) -\/$>$ std\+::ostream \&
\item 
bool \mbox{\hyperlink{namespace_catch_a11c40de0d3593160a350d9e4323311b2}{Catch\+::list}} (IEvent\+Listener \&reporter, \mbox{\hyperlink{class_catch_1_1_config}{Config}} const \&config)
\item 
int \mbox{\hyperlink{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}} (int argc, char \texorpdfstring{$\ast$}{*}argv\mbox{[}$\,$\mbox{]})
\item 
\mbox{\hyperlink{class_catch_1_1_optional}{Optional}}$<$ unsigned int $>$ \mbox{\hyperlink{namespace_catch_a369d3d53347e3c8da1d23ef64fa39daf}{Catch\+::parse\+UInt}} (std\+::string const \&input, int base)
\item 
bool \mbox{\hyperlink{namespace_catch_aff37796f0f578c2816f74267e641c5f7}{Catch\+::isnan}} (float f)
\item 
bool \mbox{\hyperlink{namespace_catch_a37d450336c237ac77721f0a3f9fb048d}{Catch\+::isnan}} (double d)
\item 
float \mbox{\hyperlink{namespace_catch_ae65d074e6c60320640a500d302b83bb2}{Catch\+::nextafter}} (float \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, float y)
\item 
double \mbox{\hyperlink{namespace_catch_add39a699bce7f13c95616fcaa62ab7ca}{Catch\+::nextafter}} (double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, double y)
\item 
bool \mbox{\hyperlink{namespace_catch_a6d5126d3ec2d72a47fa404b704d99010}{Catch\+::operator==}} (\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Simple\+Pcg32}} const \&lhs, \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Simple\+Pcg32}} const \&rhs)
\item 
bool \mbox{\hyperlink{namespace_catch_ab5a7a360e947e33298ee18f652749230}{Catch\+::operator!=}} (\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Simple\+Pcg32}} const \&lhs, \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Simple\+Pcg32}} const \&rhs)
\item 
std\+::uint32\+\_\+t \mbox{\hyperlink{namespace_catch_a170bbe5db76570c4820b5e2eb260f82b}{Catch\+::generate\+Random\+Seed}} (\mbox{\hyperlink{namespace_catch_a0e8d3a1107ecbaa1943e0a462db99a3d}{Generate\+From}} from)
\item 
std\+::vector$<$ std\+::string $>$ \mbox{\hyperlink{namespace_catch_1_1_detail_a874fd7848ec5a0ef02d88c6ec37c9a03}{Catch\+::\+Detail\+::split\+Reporter\+Spec}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{reporter\+Spec}})
\begin{DoxyCompactList}\small\item\em Splits the reporter spec into reporter name and kv-\/pair options. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_catch_1_1_optional}{Optional}}$<$ \mbox{\hyperlink{namespace_catch_a91308e87521e370e591065a22b010025}{Colour\+Mode}} $>$ \mbox{\hyperlink{namespace_catch_1_1_detail_a64ba838a0c2e6767d095a7a01fc07b48}{Catch\+::\+Detail\+::string\+To\+Colour\+Mode}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} colour\+Mode)
\item 
bool \mbox{\hyperlink{namespace_catch_a408299b05a1363c7cd99fb5b6c7f1e3d}{Catch\+::operator==}} (\mbox{\hyperlink{class_catch_1_1_reporter_spec}{Reporter\+Spec}} const \&lhs, \mbox{\hyperlink{class_catch_1_1_reporter_spec}{Reporter\+Spec}} const \&rhs)
\item 
\mbox{\hyperlink{class_catch_1_1_optional}{Optional}}$<$ \mbox{\hyperlink{class_catch_1_1_reporter_spec}{Reporter\+Spec}} $>$ \mbox{\hyperlink{namespace_catch_ae987bd04fd59321f5183794daeffd4cf}{Catch\+::parse\+Reporter\+Spec}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} reporter\+Spec)
\item 
bool \mbox{\hyperlink{namespace_catch_a5205869c81c06d3460759cb86676ae68}{Catch\+::is\+Ok}} (\mbox{\hyperlink{struct_catch_1_1_result_was_a624e1ee3661fcf6094ceef1f654601ef}{Result\+Was\+::\+Of\+Type}} result\+Type)
\item 
bool \mbox{\hyperlink{namespace_catch_a54b01af61673a3e1f21f31713639b180}{Catch\+::is\+Just\+Info}} (int flags)
\item 
\mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8}{Result\+Disposition\+::\+Flags}} \mbox{\hyperlink{namespace_catch_ab32a083e442cc09f736327d2e2865999}{Catch\+::operator\texorpdfstring{$\vert$}{|}}} (\mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8}{Result\+Disposition\+::\+Flags}} lhs, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8}{Result\+Disposition\+::\+Flags}} rhs)
\item 
bool \mbox{\hyperlink{namespace_catch_a7f7480b15d74965459c844f0d393ed87}{Catch\+::should\+Continue\+On\+Failure}} (int flags)
\item 
bool \mbox{\hyperlink{namespace_catch_ab91eb13081203d634fe48d3d2ab386d7}{Catch\+::should\+Suppress\+Failure}} (int flags)
\item 
\mbox{\hyperlink{class_catch_1_1_i_result_capture}{IResult\+Capture}} \& \mbox{\hyperlink{namespace_catch_af718eeab870712f292ed8dc6ee3f6488}{Catch\+::get\+Result\+Capture}} ()
\item 
void \mbox{\hyperlink{namespace_catch_a161400810eb0995394d6d8d3cae821ad}{Catch\+::seed\+Rng}} (\mbox{\hyperlink{class_catch_1_1_i_config}{IConfig}} const \&config)
\item 
unsigned int \mbox{\hyperlink{namespace_catch_acf5ea05e942d2d7fe79111e12754ed76}{Catch\+::rng\+Seed}} ()
\item 
void \mbox{\hyperlink{namespace_catch_a788ebefcd83342b7c479222a1eeffaee}{Catch\+::add\+Singleton}} (ISingleton \texorpdfstring{$\ast$}{*}singleton)
\item 
void \mbox{\hyperlink{namespace_catch_a8bdb92cb53a4e016bc0dee66efd99118}{Catch\+::cleanup\+Singletons}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a8c8ea1f66bc1cdc3e1254ed7fa57c06d}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{Source\+Line\+Info}} const \&info)
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a0179d453617ba2296f2baa99a49e7264}{Catch\+::cout}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a54c1ce08041448d684ae8edc14162cd2}{Catch\+::cerr}} ()
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a1b2213f54e4d31a659db49827e81856b}{Catch\+::clog}} ()
\item 
bool \mbox{\hyperlink{namespace_catch_a695f62327be0676e046291eeaae15110}{Catch\+::starts\+With}} (std\+::string const \&s, std\+::string const \&prefix)
\item 
bool \mbox{\hyperlink{namespace_catch_aa77a782fac38c4f6417a7af909e8b29c}{Catch\+::starts\+With}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} s, char prefix)
\item 
bool \mbox{\hyperlink{namespace_catch_ada025504f627feaf9ac68ca391515dff}{Catch\+::ends\+With}} (std\+::string const \&s, std\+::string const \&suffix)
\item 
bool \mbox{\hyperlink{namespace_catch_afd801a3e33fd7a8b91ded0d02747a93f}{Catch\+::ends\+With}} (std\+::string const \&s, char suffix)
\item 
bool \mbox{\hyperlink{namespace_catch_aa52974b0e426e7e2fbd725a900e9c36e}{Catch\+::contains}} (std\+::string const \&s, std\+::string const \&infix)
\item 
void \mbox{\hyperlink{namespace_catch_a0760dbe87d090a55a35414db57d272c4}{Catch\+::to\+Lower\+In\+Place}} (std\+::string \&s)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_ac036a17412d318598ffda8e1fe7a1177}{Catch\+::to\+Lower}} (std\+::string const \&s)
\item 
char \mbox{\hyperlink{namespace_catch_ad2b13ec5c5220e066b6fe7ba7a82db9d}{Catch\+::to\+Lower}} (char c)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_a084108b47f37d8bfd5db51c50c7451b3}{Catch\+::trim}} (std\+::string const \&str)
\item 
\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} \mbox{\hyperlink{namespace_catch_a6f6d8ef0349688290bd242b50a702c28}{Catch\+::trim}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} ref)
\item 
bool \mbox{\hyperlink{namespace_catch_afe4e6770da547e43e9e4eeaa05f946ea}{Catch\+::replace\+In\+Place}} (std\+::string \&str, std\+::string const \&replace\+This, std\+::string const \&with\+This)
\item 
std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} $>$ \mbox{\hyperlink{namespace_catch_a678e3c779388970bb3ec5802245f93d7}{Catch\+::split\+String\+Ref}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} str, char delimiter)
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a27d46b1ac4a1956660e4e9361c4835b8}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, pluralise const \&pluraliser)
\item 
auto \mbox{\hyperlink{namespace_catch_acabbdedb64bd66b7e0233969f6cdfb58}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} str) -\/$>$ std\+::ostream \&
\item 
std\+::string \mbox{\hyperlink{namespace_catch_ae053e7e198e60bf45f2b8bc51050f5f4}{Catch\+::operator+}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} rhs)
\item 
auto \mbox{\hyperlink{namespace_catch_a1c519834d917d9c6d2df64f26abcf059}{Catch\+::operator+=}} (std\+::string \&lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} rhs) -\/$>$ std\+::string \&
\item 
std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} $>$ \mbox{\hyperlink{namespace_catch_ad9dc14789e42b18c6dc26590a49a6eaa}{Catch\+::sort\+Tests}} (\mbox{\hyperlink{class_catch_1_1_i_config}{IConfig}} const \&config, std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} $>$ const \&unsorted\+Test\+Cases)
\item 
bool \mbox{\hyperlink{namespace_catch_a12f76a88f2882e9d1d221979dec0324d}{Catch\+::is\+Throw\+Safe}} (\mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} const \&test\+Case, \mbox{\hyperlink{class_catch_1_1_i_config}{IConfig}} const \&config)
\item 
std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} $>$ \mbox{\hyperlink{namespace_catch_af1944a358b260e03c6695aa7ae259c9a}{Catch\+::filter\+Tests}} (std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} $>$ const \&test\+Cases, \mbox{\hyperlink{class_catch_1_1_test_spec}{Test\+Spec}} const \&test\+Spec, \mbox{\hyperlink{class_catch_1_1_i_config}{IConfig}} const \&config)
\item 
std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} $>$ const \& \mbox{\hyperlink{namespace_catch_aae7d61b3abc9c8d3c82407b380e6a414}{Catch\+::get\+All\+Test\+Cases\+Sorted}} (\mbox{\hyperlink{class_catch_1_1_i_config}{IConfig}} const \&config)
\item 
void \mbox{\hyperlink{namespace_catch_a2236988eae84fb6bcc456bbf8ddfd2bf}{Catch\+::throw\+\_\+test\+\_\+failure\+\_\+exception}} ()
\item 
void \mbox{\hyperlink{namespace_catch_a7c6db2bf035e2e570d0b6703f6f5a3d8}{Catch\+::throw\+\_\+test\+\_\+skip\+\_\+exception}} ()
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{class_catch_1_1_i_test_invoker}{ITest\+Invoker}} $>$ \mbox{\hyperlink{namespace_catch_a4036958fd61b3ba0b3d2467e7f4f6fd7}{Catch\+::make\+Test\+Invoker}} (void(\texorpdfstring{$\ast$}{*}test\+As\+Function)())
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_1_1_text_flow_a512213886b4304e4573b57fe42b66d4e}{Catch\+::\+Text\+Flow\+::operator$<$$<$}} (std\+::ostream \&os, Column const \&col)
\item 
Column \mbox{\hyperlink{namespace_catch_1_1_text_flow_a24f631f4606e5664e764e6a6b9df5c04}{Catch\+::\+Text\+Flow\+::\+Spacer}} (size\+\_\+t space\+Width)
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_1_1_text_flow_a2627582ff1b81131b3deac691e847156}{Catch\+::\+Text\+Flow\+::operator$<$$<$}} (std\+::ostream \&os, Columns const \&cols)
\item 
Columns \mbox{\hyperlink{namespace_catch_1_1_text_flow_a3027b08d3fce163c060fbeb52520d28a}{Catch\+::\+Text\+Flow\+::operator+}} (Column const \&lhs, Column const \&rhs)
\item 
Columns \mbox{\hyperlink{namespace_catch_1_1_text_flow_a3fe83f06ebecb334bd138dae8568ad29}{Catch\+::\+Text\+Flow\+::operator+}} (Column \&\&lhs, Column \&\&rhs)
\item 
Columns \& \mbox{\hyperlink{namespace_catch_1_1_text_flow_a12526387d93de04a83f5842cefb83d92}{Catch\+::\+Text\+Flow\+::operator+=}} (Columns \&lhs, Column const \&rhs)
\item 
Columns \& \mbox{\hyperlink{namespace_catch_1_1_text_flow_ae7ff2aeae98d2bb38fd08399bb7da352}{Catch\+::\+Text\+Flow\+::operator+=}} (Columns \&lhs, Column \&\&rhs)
\item 
Columns \mbox{\hyperlink{namespace_catch_1_1_text_flow_addb58348d617cfd289663fe52c185e68}{Catch\+::\+Text\+Flow\+::operator+}} (Columns const \&lhs, Column const \&rhs)
\item 
Columns \mbox{\hyperlink{namespace_catch_1_1_text_flow_aa8b32803ded290301e4ec200e138c541}{Catch\+::\+Text\+Flow\+::operator+}} (Columns \&\&lhs, Column \&\&rhs)
\item 
bool \mbox{\hyperlink{namespace_catch_a4b5a2b34a00e65b753185bbc6a4962be}{Catch\+::uncaught\+\_\+exceptions}} ()
\item 
Xml\+Formatting \mbox{\hyperlink{namespace_catch_ae7c1b9d4303677f5326cc121c83703df}{Catch\+::operator\texorpdfstring{$\vert$}{|}}} (Xml\+Formatting lhs, Xml\+Formatting rhs)
\item 
Xml\+Formatting \mbox{\hyperlink{namespace_catch_a5fe56089298472584786c12b6ba9910c}{Catch\+::operator\&}} (Xml\+Formatting lhs, Xml\+Formatting rhs)
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a64142d8bbd7638d9af0e6b6829821e86}{Catch\+::operator$<$$<$}} (std\+::ostream \&os, Xml\+Encode const \&xml\+Encode)
\item 
Is\+Empty\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_ae345560f84f68d52fc5df4ac77eb4b92}{Catch\+::\+Matchers\+::\+Is\+Empty}} ()
\item 
Has\+Size\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a640c1714c014191cc131b37f955f83ed}{Catch\+::\+Matchers\+::\+Size\+Is}} (std\+::size\+\_\+t sz)
\item 
Exception\+Message\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a4c7d45a32d4ecf1d71b24b37920a5be7}{Catch\+::\+Matchers\+::\+Message}} (std\+::string const \&message)
\item 
Within\+Ulps\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a88361ad809aab09ff75c87bf6cdd7fad}{Catch\+::\+Matchers\+::\+Within\+ULP}} (double target, uint64\+\_\+t max\+Ulp\+Diff)
\item 
Within\+Ulps\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_af0eb912b197be0f79e60fd1884e9ac29}{Catch\+::\+Matchers\+::\+Within\+ULP}} (float target, uint64\+\_\+t max\+Ulp\+Diff)
\item 
Within\+Abs\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a13a915665906ab3efb39e118c649285f}{Catch\+::\+Matchers\+::\+Within\+Abs}} (double target, double margin)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a78dba3ba1112c48a6376a38b48ea70e2}{Catch\+::\+Matchers\+::\+Within\+Rel}} (double target, double eps)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a01c32f9483573cfb0d703f5f34b9848d}{Catch\+::\+Matchers\+::\+Within\+Rel}} (double target)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a65b303b8eb9ba612cc5c149488aa7753}{Catch\+::\+Matchers\+::\+Within\+Rel}} (float target, float eps)
\item 
Within\+Rel\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a735b5278dad4189adbc79098c2360b03}{Catch\+::\+Matchers\+::\+Within\+Rel}} (float target)
\item 
Is\+Na\+NMatcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a0d170fa146d9a4ec0d908acce010128e}{Catch\+::\+Matchers\+::\+Is\+NaN}} ()
\item 
All\+True\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a4f719bca42718f4936668308772732ae}{Catch\+::\+Matchers\+::\+All\+True}} ()
\item 
None\+True\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a072ee44afcb1647b55b6c3437f22af44}{Catch\+::\+Matchers\+::\+None\+True}} ()
\item 
Any\+True\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a99b3d0b547a4335b786e8fcea6a11cad}{Catch\+::\+Matchers\+::\+Any\+True}} ()
\item 
String\+Equals\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_ae584743abef84739c036faf46eef53b7}{Catch\+::\+Matchers\+::\+Equals}} (std\+::string const \&str, \mbox{\hyperlink{namespace_catch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
String\+Contains\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a348b90347a2dea3747eabd01d03c114c}{Catch\+::\+Matchers\+::\+Contains\+Substring}} (std\+::string const \&str, \mbox{\hyperlink{namespace_catch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
Ends\+With\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_a12b1480cb0af61579e8776cf538d0069}{Catch\+::\+Matchers\+::\+Ends\+With}} (std\+::string const \&str, \mbox{\hyperlink{namespace_catch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
Starts\+With\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_af3c7edfbfb4cba59f76578304597e548}{Catch\+::\+Matchers\+::\+Starts\+With}} (std\+::string const \&str, \mbox{\hyperlink{namespace_catch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
Regex\+Matcher \mbox{\hyperlink{namespace_catch_1_1_matchers_af4de9d3e501b83d17a048cf2107629dc}{Catch\+::\+Matchers\+::\+Matches}} (std\+::string const \&regex, \mbox{\hyperlink{namespace_catch_ac881e5ba54c09673c50349dbea7fff36}{Case\+Sensitive}} case\+Sensitivity)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_1_1_matchers_1_1_detail_a228a8fff5aa311bd0e3592b8cb711392}{Catch\+::\+Matchers\+::\+Detail\+::describe\+\_\+multi\+\_\+matcher}} (\mbox{\hyperlink{class_catch_1_1_string_ref}{String\+Ref}} combine, std\+::string const \texorpdfstring{$\ast$}{*}descriptions\+\_\+begin, std\+::string const \texorpdfstring{$\ast$}{*}descriptions\+\_\+end)
\item 
void \mbox{\hyperlink{namespace_catch_a4c77e898254807f1a2d7195ca324c19e}{Catch\+::handle\+Exception\+Match\+Expr}} (\mbox{\hyperlink{class_catch_1_1_assertion_handler}{Assertion\+Handler}} \&handler, String\+Matcher const \&matcher)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_af65507889895c5c4b04fb831eeab2972}{Catch\+::get\+Formatted\+Duration}} (double duration)
\item 
bool \mbox{\hyperlink{namespace_catch_af125966eee74f0256b8bfddec3840497}{Catch\+::should\+Show\+Duration}} (\mbox{\hyperlink{class_catch_1_1_i_config}{IConfig}} const \&config, double duration)
\item 
std\+::string \mbox{\hyperlink{namespace_catch_ae5e405537e8a55293a1b6cad32e2cdb5}{Catch\+::serialize\+Filters}} (std\+::vector$<$ std\+::string $>$ const \&filters)
\item 
std\+::ostream \& \mbox{\hyperlink{namespace_catch_a78a94236ca5f49ef11f36cf02483cb1d}{Catch\+::operator$<$$<$}} (std\+::ostream \&out, line\+Of\+Chars \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}})
\item 
void \mbox{\hyperlink{namespace_catch_a7fc9276bf852d1625d986c0cbc3eabce}{Catch\+::default\+List\+Reporters}} (std\+::ostream \&out, std\+::vector$<$ Reporter\+Description $>$ const \&descriptions, \mbox{\hyperlink{namespace_catch_af85c0d46dfe687d923a157362fd07737}{Verbosity}} verbosity)
\item 
void \mbox{\hyperlink{namespace_catch_a906d1c90c5a8118e737bd14bef2885ea}{Catch\+::default\+List\+Listeners}} (std\+::ostream \&out, std\+::vector$<$ Listener\+Description $>$ const \&descriptions)
\item 
void \mbox{\hyperlink{namespace_catch_a29d53521f0da176f732c3a022dbb04df}{Catch\+::default\+List\+Tags}} (std\+::ostream \&out, std\+::vector$<$ Tag\+Info $>$ const \&tags, bool is\+Filtered)
\item 
void \mbox{\hyperlink{namespace_catch_a6dce9f6d9a416fe7a06e6394d557606a}{Catch\+::default\+List\+Tests}} (std\+::ostream \&out, Colour\+Impl \texorpdfstring{$\ast$}{*}stream\+Colour, std\+::vector$<$ \mbox{\hyperlink{class_catch_1_1_test_case_handle}{Test\+Case\+Handle}} $>$ const \&tests, bool is\+Filtered, \mbox{\hyperlink{namespace_catch_af85c0d46dfe687d923a157362fd07737}{Verbosity}} verbosity)
\item 
void \mbox{\hyperlink{namespace_catch_aecf85e8927841af21b8fcd3bab31df2b}{Catch\+::print\+Test\+Run\+Totals}} (std\+::ostream \&\mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}}, Colour\+Impl \&stream\+Colour, \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} const \&totals)
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{void}} \mbox{\hyperlink{namespace_catch_1_1_detail_af8703a4eaf12133aa02a50dee831f2bc}{Catch\+::\+Detail\+::register\+Reporter\+Impl}} (std\+::string \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{const}} \&name, \mbox{\hyperlink{namespace_catch_a7b0c740ea1bcc8618dc95cd8d36f9fd3}{IReporter\+Factory\+Ptr}} \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{reporter\+Ptr}})
\item 
\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{void}} \mbox{\hyperlink{namespace_catch_1_1_detail_aae9b0608769b42ff7bbd07687348c7e5}{Catch\+::\+Detail\+::register\+Listener\+Impl}} (\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Detail\+::unique\+\_\+ptr}}$<$ \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Event\+Listener\+Factory}} $>$ \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{listener\+Factory}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}} = -\/log( ( 1.\+0 -\/ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) \texorpdfstring{$\ast$}{*} ( 1.\+0 + \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) )
\item 
double \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}} = -\/2.\+7109920616438573243e-\/11
\item 
\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}
\item 
return \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This file provides platform specific implementations of Fatal\+Condition\+Handler

This means that there is a lot of conditional compilation, and platform specific code. Currently, Catch2 supports a dummy handler (if no handler is desired), and 2 platform specific handlers\+:
\begin{DoxyItemize}
\item Windows\textquotesingle{} SEH
\item POSIX signals
\end{DoxyItemize}

Consequently, various pieces of code below are compiled if either of the platform specific handlers is enabled, or if none of them are enabled. It is assumed that both cannot be enabled at the same time, and doing so should cause a compilation error.

If another platform specific handler is added, the compile guards below will need to be updated taking these assumptions into account. 

\doxysubsection{Macro Definition Documentation}
\Hypertarget{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12}\label{catch__amalgamated_8cpp_a49ffcf43841dcedc78c808b8e62e4f12} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!Digits@{Digits}}
\index{Digits@{Digits}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{Digits}{Digits}}
{\footnotesize\ttfamily \#define Digits(\begin{DoxyParamCaption}\item[{}]{\mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} }\end{DoxyParamCaption})~( \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} \& 0x\+FF\textquotesingle{}FF\textquotesingle{}FF\textquotesingle{}FF )            std\+::uint64\+\_\+t lhs\+\_\+low = Digits( lhs );            std\+::uint64\+\_\+t rhs\+\_\+low = Digits( rhs );            std\+::uint64\+\_\+t low\+\_\+low = ( lhs\+\_\+low \texorpdfstring{$\ast$}{*} rhs\+\_\+low );            std\+::uint64\+\_\+t high\+\_\+high = \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( lhs ) \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( rhs );                        std\+::uint64\+\_\+t high\+\_\+low =                ( \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( lhs ) \texorpdfstring{$\ast$}{*} rhs\+\_\+low ) + \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( low\+\_\+low );                                    std\+::uint64\+\_\+t low\+\_\+high =                ( lhs\+\_\+low \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( rhs ) ) + Digits( high\+\_\+low );            return \{ high\+\_\+high + \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( high\+\_\+low ) + \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}( low\+\_\+high ),                     ( low\+\_\+high $<$$<$ 32 ) \texorpdfstring{$\vert$}{|} Digits( low\+\_\+low ) \};\#undef \mbox{\hyperlink{catch__amalgamated_8hpp_a3b9fde7bed48606915ced702d38db7ce}{Carry\+Bits}}\#undef Digits        \}                inline Extended\+Mult\+Result$<$std\+::uint64\+\_\+t$>$        extended\+Mult( std\+::uint64\+\_\+t lhs, std\+::uint64\+\_\+t rhs ) \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( CATCH\+\_\+\+CONFIG\+\_\+\+UINT128 )            auto \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} = \+\_\+\+\_\+uint128\+\_\+t( lhs ) \texorpdfstring{$\ast$}{*} \+\_\+\+\_\+uint128\+\_\+t( rhs );            return \{ static\+\_\+cast$<$std\+::uint64\+\_\+t$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} $>$$>$ 64 ),                     static\+\_\+cast$<$std\+::uint64\+\_\+t$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} ) \};\#elif defined( CATCH\+\_\+\+CONFIG\+\_\+\+MSVC\+\_\+\+UMUL128 )            std\+::uint64\+\_\+t high;            std\+::uint64\+\_\+t low = \+\_\+umul128( lhs, rhs, \&high );            return \{ high, low \};\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}            return extended\+Mult\+Portable( lhs, rhs );\#endif        \}        template $<$typename UInt$>$        constexpr Extended\+Mult\+Result$<$UInt$>$ extended\+Mult( UInt lhs, UInt rhs ) \{            static\+\_\+assert( std\+::is\+\_\+unsigned$<$UInt$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}extended\+Mult can only handle unsigned integers"{} );            static\+\_\+assert( sizeof( UInt ) $<$ sizeof( std\+::uint64\+\_\+t ),                           "{}Generic extended\+Mult can only handle types smaller "{}                           "{}than uint64\+\_\+t"{} );            using Wide\+Type = Double\+Width\+Unsigned\+Type\+\_\+t$<$UInt$>$;            auto \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} = Wide\+Type( lhs ) \texorpdfstring{$\ast$}{*} Wide\+Type( rhs );            return \{                static\+\_\+cast$<$UInt$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} $>$$>$ ( CHAR\+\_\+\+BIT \texorpdfstring{$\ast$}{*} sizeof( UInt ) ) ),                static\+\_\+cast$<$UInt$>$( \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} \& UInt( -\/1 ) ) \};        \}        template $<$typename Target\+Type,                  typename Generator$>$            std\+::enable\+\_\+if\+\_\+t$<$sizeof(typename Generator\+::result\+\_\+type) $>$= sizeof(Target\+Type),            Target\+Type$>$ fill\+Bits\+From(Generator\& gen) \{            using gresult\+\_\+type = typename Generator\+::result\+\_\+type;            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Target\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Only unsigned integers are supported"{} );            static\+\_\+assert( Generator\+::min() == 0 \&\&                           Generator\+::max() == static\+\_\+cast$<$gresult\+\_\+type$>$( -\/1 ),                           "{}Generator must be able to output all numbers in its \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} type (effectively it must be a random bit generator)"{} );                                    constexpr auto generated\+\_\+bits = sizeof( gresult\+\_\+type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            constexpr auto return\+\_\+bits = sizeof( Target\+Type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            return static\+\_\+cast$<$Target\+Type$>$( gen() $>$$>$                                            ( generated\+\_\+bits -\/ return\+\_\+bits) );        \}        template $<$typename Target\+Type,                  typename Generator$>$            std\+::enable\+\_\+if\+\_\+t$<$sizeof(typename Generator\+::result\+\_\+type) $<$ sizeof(Target\+Type),            Target\+Type$>$ fill\+Bits\+From(Generator\& gen) \{            using gresult\+\_\+type = typename Generator\+::result\+\_\+type;            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Target\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}Only unsigned integers are supported"{} );            static\+\_\+assert( Generator\+::min() == 0 \&\&                           Generator\+::max() == static\+\_\+cast$<$gresult\+\_\+type$>$( -\/1 ),                           "{}Generator must be able to output all numbers in its \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} type (effectively it must be a random bit generator)"{} );            constexpr auto generated\+\_\+bits = sizeof( gresult\+\_\+type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            constexpr auto return\+\_\+bits = sizeof( Target\+Type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT;            std\+::size\+\_\+t filled\+\_\+bits = 0;            Target\+Type ret = 0;            do \{                ret $<$$<$= generated\+\_\+bits;                ret \texorpdfstring{$\vert$}{|}= gen();                filled\+\_\+bits += generated\+\_\+bits;            \} while ( filled\+\_\+bits $<$ return\+\_\+bits );            return ret;        \}                template $<$typename Original\+Type, typename Unsigned\+Type$>$        std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+signed$<$Original\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Unsigned\+Type$>$        transpose\+To\+Natural\+Order( Unsigned\+Type in ) \{            static\+\_\+assert(                sizeof( Original\+Type ) == sizeof( Unsigned\+Type ),                "{}reordering requires the same sized types on both sides"{} );            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Unsigned\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}Input type must be unsigned"{} );                                                            constexpr auto highest\+\_\+bit =                Unsigned\+Type( 1 ) $<$$<$ ( sizeof( Unsigned\+Type ) \texorpdfstring{$\ast$}{*} CHAR\+\_\+\+BIT -\/ 1 );            return static\+\_\+cast$<$Unsigned\+Type$>$( in \texorpdfstring{$^\wedge$}{\string^} highest\+\_\+bit );        \}        template $<$typename Original\+Type,                  typename Unsigned\+Type$>$        std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+unsigned$<$Original\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Unsigned\+Type$>$            transpose\+To\+Natural\+Order(Unsigned\+Type in) \{            static\+\_\+assert(                sizeof( Original\+Type ) == sizeof( Unsigned\+Type ),                "{}reordering requires the same sized types on both sides"{} );            static\+\_\+assert( std\+::is\+\_\+unsigned$<$Unsigned\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Input type must be unsigned"{} );                        return in;        \}    \} \} \#endif namespace Catch \{template $<$typename Integer\+Type$>$class uniform\+\_\+integer\+\_\+distribution \{    static\+\_\+assert(std\+::is\+\_\+integral$<$Integer\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}..."{});    using Unsigned\+Integer\+Type = Detail\+::\+Sized\+Unsigned\+Type\+\_\+t$<$sizeof(Integer\+Type)$>$;                        Unsigned\+Integer\+Type m\+\_\+a;        Unsigned\+Integer\+Type m\+\_\+ab\+\_\+distance;                            Unsigned\+Integer\+Type m\+\_\+rejection\+\_\+threshold = 0;    Unsigned\+Integer\+Type compute\+Distance(Integer\+Type a, Integer\+Type b) const \{                        return transpose\+To(b) -\/ transpose\+To(a) + 1;    \}    static Unsigned\+Integer\+Type compute\+Rejection\+Threshold(Unsigned\+Integer\+Type ab\+\_\+distance) \{                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( ab\+\_\+distance == 0 ) \{ return 0; \}        return ( \texorpdfstring{$\sim$}{\string~}ab\+\_\+distance + 1 ) \% ab\+\_\+distance;    \}    static Unsigned\+Integer\+Type transpose\+To(Integer\+Type in) \{        return Detail\+::transpose\+To\+Natural\+Order$<$Integer\+Type$>$(            static\+\_\+cast$<$Unsigned\+Integer\+Type$>$( in ) );    \}    static Integer\+Type transpose\+Back(Unsigned\+Integer\+Type in) \{        return static\+\_\+cast$<$Integer\+Type$>$(            Detail\+::transpose\+To\+Natural\+Order$<$Integer\+Type$>$(in) );    \}public\+:    using result\+\_\+type = Integer\+Type;    uniform\+\_\+integer\+\_\+distribution( Integer\+Type a, Integer\+Type b )\+:        m\+\_\+a( transpose\+To(a) ),        m\+\_\+ab\+\_\+distance( compute\+Distance(a, b) ),        m\+\_\+rejection\+\_\+threshold( compute\+Rejection\+Threshold(m\+\_\+ab\+\_\+distance) ) \{        assert( a $<$= b );    \}    template $<$typename Generator$>$    result\+\_\+type operator()( Generator\& g ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+ab\+\_\+distance == 0 ) \{            return transpose\+Back( Detail\+::fill\+Bits\+From$<$Unsigned\+Integer\+Type$>$( g ) );        \}        auto random\+\_\+number = Detail\+::fill\+Bits\+From$<$Unsigned\+Integer\+Type$>$( g );        auto emul = Detail\+::extended\+Mult( random\+\_\+number, m\+\_\+ab\+\_\+distance );                        while (emul.\+lower $<$ m\+\_\+rejection\+\_\+threshold) \{            random\+\_\+number = Detail\+::fill\+Bits\+From$<$Unsigned\+Integer\+Type$>$( g );            emul = Detail\+::extended\+Mult( random\+\_\+number, m\+\_\+ab\+\_\+distance );        \}        return transpose\+Back(m\+\_\+a + emul.\+upper);    \}    result\+\_\+type a() const \{ return transpose\+Back(m\+\_\+a); \}    result\+\_\+type b() const \{ return transpose\+Back(m\+\_\+ab\+\_\+distance + m\+\_\+a -\/ 1); \}\};\} \#endif \#ifndef CATCH\+\_\+\+UNIFORM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+DISTRIBUTION\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+UNIFORM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+DISTRIBUTION\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+RANDOM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+RANDOM\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+POLYFILLS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+POLYFILLS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    bool isnan(float f);    bool isnan(double d);    float nextafter(float \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, float y);    double nextafter(double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}}, double y);\}\#endif \#include $<$cassert$>$\#include $<$cmath$>$\#include $<$cstdint$>$\#include $<$limits$>$\#include $<$type\+\_\+traits$>$namespace Catch \{    namespace Detail \{                template $<$typename Float\+Type$>$        Float\+Type gamma(Float\+Type a, Float\+Type b) \{            static\+\_\+assert( std\+::is\+\_\+floating\+\_\+point$<$Float\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                           "{}gamma returns the largest ULP magnitude within "{}                           "{}floating point range \mbox{[}a, b\mbox{]}. This only makes sense "{}                           "{}for floating point types"{} );            assert( a $<$= b );            const auto gamma\+\_\+up = \mbox{\hyperlink{namespace_catch_ae65d074e6c60320640a500d302b83bb2}{Catch\+::nextafter}}( a, std\+::numeric\+\_\+limits$<$Float\+Type$>$\+::infinity() ) -\/ a;            const auto gamma\+\_\+down = b -\/ \mbox{\hyperlink{namespace_catch_ae65d074e6c60320640a500d302b83bb2}{Catch\+::nextafter}}( b, -\/std\+::numeric\+\_\+limits$<$Float\+Type$>$\+::infinity() );            return gamma\+\_\+up $<$ gamma\+\_\+down ? gamma\+\_\+down \+: gamma\+\_\+up;        \}        template $<$typename Floating\+Point$>$        struct Distance\+Type\+Picker;        template $<$$>$        struct Distance\+Type\+Picker$<$float$>$ \{            using type = std\+::uint32\+\_\+t;        \};        template $<$$>$        struct Distance\+Type\+Picker$<$double$>$ \{            using type = std\+::uint64\+\_\+t;        \};        template $<$typename T$>$        using Distance\+Type = typename Distance\+Type\+Picker$<$T$>$\+::type;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic push\#    pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}\#endif                template $<$typename Float\+Type$>$        Distance\+Type$<$Float\+Type$>$        count\+\_\+equidistant\+\_\+floats( Float\+Type a, Float\+Type b, Float\+Type distance ) \{            assert( a $<$= b );                                    const auto ag = a / distance;            const auto bg = b / distance;            const auto s = bg -\/ ag;            const auto err = ( std\+::fabs( a ) $<$= std\+::fabs( b ) )                                 ? -\/ag -\/ ( s -\/ bg )                                 \+: bg -\/ ( s + ag );            const auto ceil\+\_\+s = static\+\_\+cast$<$Distance\+Type$<$Float\+Type$>$$>$( std\+::ceil( s ) );            return ( ceil\+\_\+s != s ) ? ceil\+\_\+s \+: ceil\+\_\+s + ( err $>$ 0 );        \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic pop\#endif    \}\} \#endif \#include $<$cmath$>$\#include $<$type\+\_\+traits$>$namespace Catch \{    namespace Detail \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic push\#    pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}\#endif                                        constexpr std\+::uint64\+\_\+t calculate\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go(double gamma) \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( gamma == 1.\+99584030953472e+292 ) \{ return 9007199254740991; \}            return static\+\_\+cast$<$std\+::uint64\+\_\+t$>$( -\/1 );        \}        constexpr std\+::uint32\+\_\+t calculate\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go(float gamma) \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( gamma == 2.\+028241e+31f ) \{ return 16777215; \}            return static\+\_\+cast$<$std\+::uint32\+\_\+t$>$( -\/1 );        \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic pop\#endif    \}template $<$typename Float\+Type$>$class uniform\+\_\+floating\+\_\+point\+\_\+distribution \{    static\+\_\+assert(std\+::is\+\_\+floating\+\_\+point$<$Float\+Type$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}..."{});    static\+\_\+assert(!std\+::is\+\_\+same$<$Float\+Type, long double$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                  "{}We do not support long double due to inconsistent behaviour between platforms"{});    using Width\+Type = Detail\+::\+Distance\+Type$<$Float\+Type$>$;    Float\+Type m\+\_\+a, m\+\_\+b;    Float\+Type m\+\_\+ulp\+\_\+magnitude;    Width\+Type m\+\_\+floats\+\_\+in\+\_\+range;    uniform\+\_\+integer\+\_\+distribution$<$Width\+Type$>$ m\+\_\+int\+\_\+dist;                Width\+Type m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go;        bool m\+\_\+a\+\_\+has\+\_\+leq\+\_\+magnitude;public\+:    using result\+\_\+type = Float\+Type;    uniform\+\_\+floating\+\_\+point\+\_\+distribution( Float\+Type a, Float\+Type b )\+:        m\+\_\+a( a ),        m\+\_\+b( b ),        m\+\_\+ulp\+\_\+magnitude( Detail\+::gamma( m\+\_\+a, m\+\_\+b ) ),        m\+\_\+floats\+\_\+in\+\_\+range( Detail\+::count\+\_\+equidistant\+\_\+floats( m\+\_\+a, m\+\_\+b, m\+\_\+ulp\+\_\+magnitude ) ),        m\+\_\+int\+\_\+dist(0, m\+\_\+floats\+\_\+in\+\_\+range),        m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go( Detail\+::calculate\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go(m\+\_\+ulp\+\_\+magnitude)),        m\+\_\+a\+\_\+has\+\_\+leq\+\_\+magnitude(std\+::fabs(m\+\_\+a) $<$= std\+::fabs(m\+\_\+b))    \{        assert( a $<$= b );    \}    template $<$typename Generator$>$    result\+\_\+type operator()( Generator\& g ) \{        Width\+Type steps = m\+\_\+int\+\_\+dist( g );        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+a\+\_\+has\+\_\+leq\+\_\+magnitude ) \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( steps == m\+\_\+floats\+\_\+in\+\_\+range ) \{ return m\+\_\+a; \}            auto b = m\+\_\+b;            while (steps $>$ m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go) \{                b -\/= m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;                steps -\/= m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go;            \}            return b -\/ steps \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;        \} \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( steps == m\+\_\+floats\+\_\+in\+\_\+range ) \{ return m\+\_\+b; \}            auto a = m\+\_\+a;            while (steps $>$ m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go) \{                a += m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;                steps -\/= m\+\_\+max\+\_\+steps\+\_\+in\+\_\+one\+\_\+go;            \}            return a + steps \texorpdfstring{$\ast$}{*} m\+\_\+ulp\+\_\+magnitude;        \}    \}    result\+\_\+type a() const \{ return m\+\_\+a; \}    result\+\_\+type b() const \{ return m\+\_\+b; \}\};\} \#endif namespace Catch \{namespace Generators \{namespace Detail \{                std\+::uint32\+\_\+t get\+Seed();\}template $<$typename Float$>$class Random\+Floating\+Generator final \+: public IGenerator$<$Float$>$ \{    \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch\+::\+Simple\+Pcg32}} m\+\_\+rng;    Catch\+::uniform\+\_\+floating\+\_\+point\+\_\+distribution$<$Float$>$ m\+\_\+dist;    Float m\+\_\+current\+\_\+number;public\+:    Random\+Floating\+Generator( Float a, Float b, std\+::uint32\+\_\+t seed )\+:        m\+\_\+rng(seed),        m\+\_\+dist(a, b) \{        static\+\_\+cast$<$void$>$(next());    \}    Float const\& get() const override \{        return m\+\_\+current\+\_\+number;    \}    bool next() override \{        m\+\_\+current\+\_\+number = m\+\_\+dist(m\+\_\+rng);        return true;    \}\};template $<$$>$class Random\+Floating\+Generator$<$long double$>$ final \+: public IGenerator$<$long double$>$ \{            struct PImpl;    \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$PImpl$>$ m\+\_\+pimpl;    long double m\+\_\+current\+\_\+number;public\+:    Random\+Floating\+Generator( long double a, long double b, std\+::uint32\+\_\+t seed );    long double const\& get() const override \{ return m\+\_\+current\+\_\+number; \}    bool next() override;    \texorpdfstring{$\sim$}{\string~}Random\+Floating\+Generator() override; \};template $<$typename Integer$>$class Random\+Integer\+Generator final \+: public IGenerator$<$Integer$>$ \{    \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch\+::\+Simple\+Pcg32}} m\+\_\+rng;    Catch\+::uniform\+\_\+integer\+\_\+distribution$<$Integer$>$ m\+\_\+dist;    Integer m\+\_\+current\+\_\+number;public\+:    Random\+Integer\+Generator( Integer a, Integer b, std\+::uint32\+\_\+t seed )\+:        m\+\_\+rng(seed),        m\+\_\+dist(a, b) \{        static\+\_\+cast$<$void$>$(next());    \}    Integer const\& get() const override \{        return m\+\_\+current\+\_\+number;    \}    bool next() override \{        m\+\_\+current\+\_\+number = m\+\_\+dist(m\+\_\+rng);        return true;    \}\};template $<$typename T$>$std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+integral$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Generator\+Wrapper$<$T$>$$>$random(T a, T b) \{    return Generator\+Wrapper$<$T$>$(        \mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Random\+Integer\+Generator$<$T$>$$>$(a, b, Detail\+::get\+Seed())    );\}template $<$typename T$>$std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+floating\+\_\+point$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},Generator\+Wrapper$<$T$>$$>$random(T a, T b) \{    return Generator\+Wrapper$<$T$>$(        \mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Random\+Floating\+Generator$<$T$>$$>$(a, b, Detail\+::get\+Seed())    );\}\} \} \#endif \#ifndef CATCH\+\_\+\+GENERATORS\+\_\+\+RANGE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+GENERATORS\+\_\+\+RANGE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iterator$>$\#include $<$type\+\_\+traits$>$namespace Catch \{namespace Generators \{template $<$typename T$>$class Range\+Generator final \+: public IGenerator$<$T$>$ \{    T m\+\_\+current;    T m\+\_\+end;    T m\+\_\+step;    bool m\+\_\+positive;public\+:    Range\+Generator(T const\& start, T const\& end, T const\& step)\+:        m\+\_\+current(start),        m\+\_\+end(end),        m\+\_\+step(step),        m\+\_\+positive(m\+\_\+step $>$ T(0))    \{        assert(m\+\_\+current != m\+\_\+end \&\& "{}Range start and end cannot be equal"{});        assert(m\+\_\+step != T(0) \&\& "{}Step size cannot be zero"{});        assert(((m\+\_\+positive \&\& m\+\_\+current $<$= m\+\_\+end) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (!m\+\_\+positive \&\& m\+\_\+current $>$= m\+\_\+end)) \&\& "{}Step moves away from end"{});    \}    Range\+Generator(T const\& start, T const\& end)\+:        Range\+Generator(start, end, (start $<$ end) ? T(1) \+: T(-\/1))    \{\}    T const\& get() const override \{        return m\+\_\+current;    \}    bool next() override \{        m\+\_\+current += m\+\_\+step;        return (m\+\_\+positive) ? (m\+\_\+current $<$ m\+\_\+end) \+: (m\+\_\+current $>$ m\+\_\+end);    \}\};template $<$typename T$>$Generator\+Wrapper$<$T$>$ range(T const\& start, T const\& end, T const\& step) \{    static\+\_\+assert(std\+::is\+\_\+arithmetic$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}} \&\& !std\+::is\+\_\+same$<$T, bool$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Type must be numeric"{});    return Generator\+Wrapper$<$T$>$(\mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Range\+Generator$<$T$>$$>$(start, end, step));\}template $<$typename T$>$Generator\+Wrapper$<$T$>$ range(T const\& start, T const\& end) \{    static\+\_\+assert(std\+::is\+\_\+integral$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}} \&\& !std\+::is\+\_\+same$<$T, bool$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Type must be an integer"{});    return Generator\+Wrapper$<$T$>$(\mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Range\+Generator$<$T$>$$>$(start, end));\}template $<$typename T$>$class Iterator\+Generator final \+: public IGenerator$<$T$>$ \{    static\+\_\+assert(!std\+::is\+\_\+same$<$T, bool$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        "{}Iterator\+Generator currently does not support bools"{}        "{}because of std\+::vector$<$bool$>$ specialization"{});    std\+::vector$<$T$>$ m\+\_\+elems;    size\+\_\+t m\+\_\+current = 0;public\+:    template $<$typename Input\+Iterator, typename Input\+Sentinel$>$    Iterator\+Generator(Input\+Iterator first, Input\+Sentinel last)\+:m\+\_\+elems(first, last) \{        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+elems.\+empty()) \{            Detail\+::throw\+\_\+generator\+\_\+exception("{}Iterator\+Generator received no valid values"{});        \}    \}    T const\& get() const override \{        return m\+\_\+elems\mbox{[}m\+\_\+current\mbox{]};    \}    bool next() override \{        ++m\+\_\+current;        return m\+\_\+current != m\+\_\+elems.\+size();    \}\};template $<$typename Input\+Iterator,          typename Input\+Sentinel,          typename Result\+Type = typename std\+::iterator\+\_\+traits$<$Input\+Iterator$>$\+::value\+\_\+type$>$Generator\+Wrapper$<$Result\+Type$>$ from\+\_\+range(Input\+Iterator from, Input\+Sentinel to) \{    return Generator\+Wrapper$<$Result\+Type$>$(\mbox{\hyperlink{namespace_catch_1_1_detail_a3175310a581a4d3b7bd12cf543dfa0d9}{Catch\+::\+Detail\+::make\+\_\+unique}}$<$Iterator\+Generator$<$Result\+Type$>$$>$(from, to));\}template $<$typename Container$>$auto from\+\_\+range(Container const\& cnt) \{    using std\+::begin;    using std\+::end;    return from\+\_\+range( begin( cnt ), end( cnt ) );\}\} \} \#endif \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+TEST\+\_\+\+RUN\+\_\+\+INFO\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+RUN\+\_\+\+INFO\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    struct Test\+Run\+Info \{        constexpr Test\+Run\+Info(String\+Ref \+\_\+name) \+: name(\+\_\+name) \{\}        String\+Ref name;    \};\} \#endif \#include $<$map$>$\#include $<$string$>$\#include $<$vector$>$\#include $<$iosfwd$>$namespace Catch \{    struct Reporter\+Description;    struct Listener\+Description;    struct Tag\+Info;    struct Test\+Case\+Info;    class Test\+Case\+Handle;    class IConfig;    class IStream;    enum class Colour\+Mode \+: std\+::uint8\+\_\+t;    struct Reporter\+Config \{        Reporter\+Config( IConfig const\texorpdfstring{$\ast$}{*} \+\_\+full\+Config,                        Detail\+::unique\+\_\+ptr$<$IStream$>$ \+\_\+stream,                        Colour\+Mode colour\+Mode,                        std\+::map$<$std\+::string, std\+::string$>$ custom\+Options );        Reporter\+Config( Reporter\+Config\&\& ) = default;        Reporter\+Config\& operator=( Reporter\+Config\&\& ) = default;        \texorpdfstring{$\sim$}{\string~}Reporter\+Config();         Detail\+::unique\+\_\+ptr$<$IStream$>$ take\+Stream() \&\&;        IConfig const\texorpdfstring{$\ast$}{*} full\+Config() const;        Colour\+Mode colour\+Mode() const;        std\+::map$<$std\+::string, std\+::string$>$ const\& custom\+Options() const;    private\+:        Detail\+::unique\+\_\+ptr$<$IStream$>$ m\+\_\+stream;        IConfig const\texorpdfstring{$\ast$}{*} m\+\_\+full\+Config;        Colour\+Mode m\+\_\+colour\+Mode;        std\+::map$<$std\+::string, std\+::string$>$ m\+\_\+custom\+Options;    \};    struct Assertion\+Stats \{        Assertion\+Stats( Assertion\+Result const\& \+\_\+assertion\+Result,                        std\+::vector$<$Message\+Info$>$ const\& \+\_\+info\+Messages,                        Totals const\& \+\_\+totals );        Assertion\+Stats( Assertion\+Stats const\& )              = default;        Assertion\+Stats( Assertion\+Stats \&\& )                  = default;        Assertion\+Stats\& operator = ( Assertion\+Stats const\& ) = delete;        Assertion\+Stats\& operator = ( Assertion\+Stats \&\& )     = delete;        Assertion\+Result assertion\+Result;        std\+::vector$<$Message\+Info$>$ info\+Messages;        Totals totals;    \};    struct Section\+Stats \{        Section\+Stats(   Section\+Info\&\& \+\_\+section\+Info,                        Counts const\& \+\_\+assertions,                        double \+\_\+duration\+In\+Seconds,                        bool \+\_\+missing\+Assertions );        Section\+Info section\+Info;        Counts assertions;        double duration\+In\+Seconds;        bool missing\+Assertions;    \};    struct Test\+Case\+Stats \{        Test\+Case\+Stats(  Test\+Case\+Info const\& \+\_\+test\+Info,                        Totals const\& \+\_\+totals,                        std\+::string\&\& \+\_\+std\+Out,                        std\+::string\&\& \+\_\+std\+Err,                        bool \+\_\+aborting );        Test\+Case\+Info const \texorpdfstring{$\ast$}{*} test\+Info;        Totals totals;        std\+::string std\+Out;        std\+::string std\+Err;        bool aborting;    \};    struct Test\+Run\+Stats \{        Test\+Run\+Stats(   Test\+Run\+Info const\& \+\_\+run\+Info,                        Totals const\& \+\_\+totals,                        bool \+\_\+aborting );        Test\+Run\+Info run\+Info;        Totals totals;        bool aborting;    \};                struct Reporter\+Preferences \{                        bool should\+Redirect\+Std\+Out = false;                        bool should\+Report\+All\+Assertions = false;    \};        class IEvent\+Listener \{    protected\+:                Reporter\+Preferences m\+\_\+preferences;                IConfig const\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}{m\+\_\+config}};    public\+:        IEvent\+Listener( IConfig const\texorpdfstring{$\ast$}{*} config )\+: \mbox{\hyperlink{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}{m\+\_\+config}}( config ) \{\}        virtual \texorpdfstring{$\sim$}{\string~}IEvent\+Listener();                         Reporter\+Preferences const\& get\+Preferences() const \{            return m\+\_\+preferences;        \}                virtual void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) = 0;                virtual void report\+Invalid\+Test\+Spec( String\+Ref invalid\+Argument ) = 0;                virtual void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) = 0;                virtual void test\+Case\+Starting( Test\+Case\+Info const\& test\+Info ) = 0;                virtual void test\+Case\+Partial\+Starting( Test\+Case\+Info const\& test\+Info, uint64\+\_\+t part\+Number ) = 0;                virtual void section\+Starting( Section\+Info const\& section\+Info ) = 0;                virtual void benchmark\+Preparing( String\+Ref benchmark\+Name ) = 0;                virtual void benchmark\+Starting( Benchmark\+Info const\& benchmark\+Info ) = 0;                virtual void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) = 0;                virtual void benchmark\+Failed( String\+Ref benchmark\+Name ) = 0;                virtual void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) = 0;                virtual void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) = 0;                virtual void section\+Ended( Section\+Stats const\& section\+Stats ) = 0;                virtual void test\+Case\+Partial\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats, uint64\+\_\+t part\+Number ) = 0;                virtual void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) = 0;                virtual void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) = 0;                virtual void skip\+Test( Test\+Case\+Info const\& test\+Info ) = 0;                virtual void fatal\+Error\+Encountered( String\+Ref error ) = 0;                virtual void list\+Reporters(std\+::vector$<$Reporter\+Description$>$ const\& descriptions) = 0;                virtual void list\+Listeners(std\+::vector$<$Listener\+Description$>$ const\& descriptions) = 0;                virtual void list\+Tests(std\+::vector$<$Test\+Case\+Handle$>$ const\& tests) = 0;                virtual void list\+Tags(std\+::vector$<$Tag\+Info$>$ const\& tags) = 0;    \};    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;\} \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+FACTORY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+REPORTER\+\_\+\+FACTORY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    struct Reporter\+Config;    class IConfig;    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;    class IReporter\+Factory \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}IReporter\+Factory();         virtual IEvent\+Listener\+Ptr        create( Reporter\+Config\&\& config ) const = 0;        virtual std\+::string get\+Description() const = 0;    \};    using IReporter\+Factory\+Ptr = Detail\+::unique\+\_\+ptr$<$IReporter\+Factory$>$;    class Event\+Listener\+Factory \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}Event\+Listener\+Factory();         virtual IEvent\+Listener\+Ptr create( IConfig const\texorpdfstring{$\ast$}{*} config ) const = 0;                virtual String\+Ref get\+Name() const = 0;                virtual std\+::string get\+Description() const = 0;    \};\} \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    struct Tag\+Alias;    class ITag\+Alias\+Registry \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}ITag\+Alias\+Registry();                 virtual Tag\+Alias const\texorpdfstring{$\ast$}{*} find( std\+::string const\& alias ) const = 0;        virtual std\+::string expand\+Aliases( std\+::string const\& unexpanded\+Test\+Spec ) const = 0;        static ITag\+Alias\+Registry const\& get();    \};\} \#endif \#ifndef CATCH\+\_\+\+INTERFACES\+\_\+\+TESTCASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+INTERFACES\+\_\+\+TESTCASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    struct Test\+Case\+Info;    class Test\+Case\+Handle;    class IConfig;    class ITest\+Case\+Registry \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}ITest\+Case\+Registry();                 virtual std\+::vector$<$Test\+Case\+Info\texorpdfstring{$\ast$}{*} $>$ const\& get\+All\+Infos() const = 0;        virtual std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests() const = 0;        virtual std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests\+Sorted( IConfig const\& config ) const = 0;    \};\}\#endif \#endif \#ifndef CATCH\+\_\+\+CASE\+\_\+\+INSENSITIVE\+\_\+\+COMPARISONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CASE\+\_\+\+INSENSITIVE\+\_\+\+COMPARISONS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    namespace Detail \{                struct Case\+Insensitive\+Less \{            bool operator()( String\+Ref lhs,                             String\+Ref rhs ) const;        \};                struct Case\+Insensitive\+Equal\+To \{            bool operator()( String\+Ref lhs,                             String\+Ref rhs ) const;        \};    \} \} \#endif \#ifndef CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\+\_\+\+HPP\+\_\+\+INCLUDED\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+\+ANDROID\+\_\+\+\_\+)\#    define CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\#endif\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE ) \&\& \textbackslash{}    !defined( CATCH\+\_\+\+CONFIG\+\_\+\+NO\+\_\+\+ANDROID\+\_\+\+LOGWRITE ) \&\&      \textbackslash{}    !defined( CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE )\#    define CATCH\+\_\+\+CONFIG\+\_\+\+ANDROID\+\_\+\+LOGWRITE\#endif\#endif \#ifndef CATCH\+\_\+\+CONFIG\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONFIG\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDED\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+MSC\+\_\+\+VER)\#  \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} \+\_\+\+MSC\+\_\+\+VER $>$= 1900 \#    define CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\#  endif\#endif\#include $<$exception$>$\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+cpp\+\_\+lib\+\_\+uncaught\+\_\+exceptions) \textbackslash{}    \&\& !defined(CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS)\#  define CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\#endif \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+INTERNAL\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS) \textbackslash{}    \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+NO\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS) \textbackslash{}    \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS)\#  define CATCH\+\_\+\+CONFIG\+\_\+\+CPP17\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\#endif\#endif \#ifndef CATCH\+\_\+\+CONSOLE\+\_\+\+COLOUR\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONSOLE\+\_\+\+COLOUR\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$cstdint$>$namespace Catch \{    enum class Colour\+Mode \+: std\+::uint8\+\_\+t;    class IStream;    struct Colour \{        enum Code \{            None = 0,            White,            Red,            Green,            Blue,            Cyan,            Yellow,            Grey,            Bright = 0x10,            Bright\+Red = Bright \texorpdfstring{$\vert$}{|} Red,            Bright\+Green = Bright \texorpdfstring{$\vert$}{|} Green,            Light\+Grey = Bright \texorpdfstring{$\vert$}{|} Grey,            Bright\+White = Bright \texorpdfstring{$\vert$}{|} White,            Bright\+Yellow = Bright \texorpdfstring{$\vert$}{|} Yellow,                        File\+Name = Light\+Grey,            Warning = Bright\+Yellow,            Result\+Error = Bright\+Red,            Result\+Success = Bright\+Green,            Result\+Expected\+Failure = Warning,            Error = Bright\+Red,            Success = Green,            Skip = Light\+Grey,            Original\+Expression = Cyan,            Reconstructed\+Expression = Bright\+Yellow,            Secondary\+Text = Light\+Grey,            Headers = White        \};    \};    class Colour\+Impl \{    protected\+:                IStream\texorpdfstring{$\ast$}{*} m\+\_\+stream;    public\+:        Colour\+Impl( IStream\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} )\+: m\+\_\+stream( \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} ) \{\}                        class Colour\+Guard \{            Colour\+Impl const\texorpdfstring{$\ast$}{*} m\+\_\+colour\+Impl;            Colour\+::\+Code m\+\_\+code;            bool m\+\_\+engaged = false;        public\+:                        Colour\+Guard( Colour\+::\+Code code,                         Colour\+Impl const\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_a5f5de53ffd2c7aad35b1140210ffe6cf}{colour}} );            Colour\+Guard( Colour\+Guard const\& rhs ) = delete;            Colour\+Guard\& operator=( Colour\+Guard const\& rhs ) = delete;            Colour\+Guard( Colour\+Guard\&\& rhs ) noexcept;            Colour\+Guard\& operator=( Colour\+Guard\&\& rhs ) noexcept;                        \texorpdfstring{$\sim$}{\string~}Colour\+Guard();                        Colour\+Guard\& engage( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} ) \&;                        Colour\+Guard\&\& engage( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} ) \&\&;        private\+:                        friend std\+::ostream\& operator$<$$<$( std\+::ostream\& lhs,                                             Colour\+Guard\& guard ) \{                guard.\+engage\+Impl( lhs );                return lhs;            \}                        friend std\+::ostream\& operator$<$$<$( std\+::ostream\& lhs,                                            Colour\+Guard\&\& guard) \{                guard.\+engage\+Impl( lhs );                return lhs;            \}            void engage\+Impl( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} );        \};        virtual \texorpdfstring{$\sim$}{\string~}Colour\+Impl();                 Colour\+Guard guard\+Colour( Colour\+::\+Code colour\+Code );    private\+:        virtual void use( Colour\+::\+Code colour\+Code ) const = 0;    \};        Detail\+::unique\+\_\+ptr$<$Colour\+Impl$>$ make\+Colour\+Impl( Colour\+Mode colour\+Selection,                                                   IStream\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} );        bool is\+Colour\+Impl\+Available( Colour\+Mode colour\+Selection );\} \#endif \#ifndef CATCH\+\_\+\+CONSOLE\+\_\+\+WIDTH\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONSOLE\+\_\+\+WIDTH\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+CONFIG\+\_\+\+CONSOLE\+\_\+\+WIDTH\#define CATCH\+\_\+\+CONFIG\+\_\+\+CONSOLE\+\_\+\+WIDTH 80\#endif\#endif \#ifndef CATCH\+\_\+\+CONTAINER\+\_\+\+NONMEMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+CONTAINER\+\_\+\+NONMEMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstddef$>$\#include $<$initializer\+\_\+list$>$\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CPP17\+\_\+\+OR\+\_\+\+GREATER) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+MSC\+\_\+\+VER)\#include $<$string$>$\#  \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(\+\_\+\+\_\+cpp\+\_\+lib\+\_\+nonmember\+\_\+container\+\_\+access)\#      define CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS\#  endif\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}\#define CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS\#endifnamespace Catch \{namespace Detail \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)    template $<$typename Container$>$    constexpr auto empty(Container const\& cont) -\/$>$ decltype(cont.\+empty()) \{        return cont.\+empty();    \}    template $<$typename T, std\+::size\+\_\+t N$>$    constexpr bool empty(const T (\&)\mbox{[}N\mbox{]}) noexcept \{                        (void)N;        return false;    \}    template $<$typename T$>$    constexpr bool empty(std\+::initializer\+\_\+list$<$T$>$ list) noexcept \{        return list.\+size() $>$ 0;    \}    template $<$typename Container$>$    constexpr auto size(Container const\& cont) -\/$>$ decltype(cont.\+size()) \{        return cont.\+size();    \}    template $<$typename T, std\+::size\+\_\+t N$>$    constexpr std\+::size\+\_\+t size(const T(\&)\mbox{[}N\mbox{]}) noexcept \{        return N;    \}\#endif \} \} \#endif \#ifndef CATCH\+\_\+\+DEBUG\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+DEBUG\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    void write\+To\+Debug\+Console( std\+::string const\& text );\}\#endif \#ifndef CATCH\+\_\+\+DEBUGGER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+DEBUGGER\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    bool is\+Debugger\+Active();\}\#ifdef CATCH\+\_\+\+PLATFORM\+\_\+\+MAC    \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+i386\+\_\+\+\_\+) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+\_\+x86\+\_\+64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+asm\+\_\+\+\_\+("{}int \$3\textbackslash{}n"{} \+: \+: )     \#elif defined(\+\_\+\+\_\+aarch64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xd43e0000"{})    \#elif defined(\+\_\+\+\_\+\+POWERPC\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+asm\+\_\+\+\_\+("{}li r0, 20\textbackslash{}nsc\textbackslash{}nnop\textbackslash{}nli r0, 37\textbackslash{}nli r4, 2\textbackslash{}nsc\textbackslash{}nnop\textbackslash{}n"{} \textbackslash{}        \+: \+: \+: "{}memory"{},"{}r0"{},"{}r3"{},"{}r4"{} )     \#endif\#elif defined(CATCH\+\_\+\+PLATFORM\+\_\+\+IPHONE)        \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+i386\+\_\+\+\_\+) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+\_\+x86\+\_\+64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}int \$3"{})    \#elif defined(\+\_\+\+\_\+aarch64\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xd4200000"{})    \#elif defined(\+\_\+\+\_\+arm\+\_\+\+\_\+) \&\& !defined(\+\_\+\+\_\+thumb\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xe7f001f0"{})    \#elif defined(\+\_\+\+\_\+arm\+\_\+\+\_\+) \&\&  defined(\+\_\+\+\_\+thumb\+\_\+\+\_\+)        \#define CATCH\+\_\+\+TRAP()  \+\_\+\+\_\+asm\+\_\+\+\_\+("{}.inst 0xde01"{})    \#endif\#elif defined(CATCH\+\_\+\+PLATFORM\+\_\+\+LINUX)                \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+\_\+\+GNUC\+\_\+\+\_\+) \&\& (defined(\+\_\+\+\_\+i386) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined(\+\_\+\+\_\+x86\+\_\+64))        \#define CATCH\+\_\+\+TRAP() asm volatile ("{}int \$3"{})     \#else         \#include $<$signal.\+h$>$        \#define CATCH\+\_\+\+TRAP() raise(SIGTRAP)    \#endif\#elif defined(\+\_\+\+MSC\+\_\+\+VER)    \#define CATCH\+\_\+\+TRAP() \+\_\+\+\_\+debugbreak()\#elif defined(\+\_\+\+\_\+\+MINGW32\+\_\+\+\_\+)    extern "{}C"{} \+\_\+\+\_\+declspec(dllimport) void \+\_\+\+\_\+stdcall Debug\+Break();    \#define CATCH\+\_\+\+TRAP() Debug\+Break()\#endif\#ifndef CATCH\+\_\+\+BREAK\+\_\+\+INTO\+\_\+\+DEBUGGER    \#ifdef CATCH\+\_\+\+TRAP        \#define CATCH\+\_\+\+BREAK\+\_\+\+INTO\+\_\+\+DEBUGGER() \mbox{[}$\,$\mbox{]}\{ \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( \mbox{\hyperlink{namespace_catch_ab079497368fb1df25af39ad494d2a241}{Catch\+::is\+Debugger\+Active}}() ) \{ CATCH\+\_\+\+TRAP(); \} \}()    \#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}        \#define CATCH\+\_\+\+BREAK\+\_\+\+INTO\+\_\+\+DEBUGGER() \mbox{[}$\,$\mbox{]}\{\}()    \#endif\#endif\#endif \#ifndef CATCH\+\_\+\+ENFORCE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ENFORCE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$exception$>$namespace Catch \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(\mbox{\hyperlink{catch__amalgamated_8hpp_a893712b2ba6e7400136a0a023b12e9db}{CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\+\_\+\+EXCEPTIONS}})    template $<$typename Ex$>$    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+exception(Ex const\& e) \{        throw e;    \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}     \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+exception(std\+::exception const\& e);\#endif    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+logic\+\_\+error(std\+::string const\& msg);    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+domain\+\_\+error(std\+::string const\& msg);    \mbox{[}\mbox{[}noreturn\mbox{]}\mbox{]}    void throw\+\_\+runtime\+\_\+error(std\+::string const\& msg);\} \#define CATCH\+\_\+\+MAKE\+\_\+\+MSG(...) \textbackslash{}    (\mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{Catch\+::\+Reusable\+String\+Stream}}() $<$$<$ \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+).str()\#define CATCH\+\_\+\+INTERNAL\+\_\+\+ERROR(...) \textbackslash{}    \mbox{\hyperlink{namespace_catch_a707884e681203fef6bf7dbf752532fa5}{Catch\+::throw\+\_\+logic\+\_\+error}}(CATCH\+\_\+\+MAKE\+\_\+\+MSG( \mbox{\hyperlink{catch__amalgamated_8hpp_abc0b2405454c51748a31e0393d9ad5d1}{CATCH\+\_\+\+INTERNAL\+\_\+\+LINEINFO}} $<$$<$ "{}\+: Internal Catch2 error\+: "{} $<$$<$ \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+))\#define CATCH\+\_\+\+ERROR(...) \textbackslash{}    \mbox{\hyperlink{namespace_catch_ae67297c3e265b0fcd55de371bf408e4e}{Catch\+::throw\+\_\+domain\+\_\+error}}(CATCH\+\_\+\+MAKE\+\_\+\+MSG( \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ))\#define CATCH\+\_\+\+RUNTIME\+\_\+\+ERROR(...) \textbackslash{}    \mbox{\hyperlink{namespace_catch_a48d2c35022dd9d56a1b7ee78ad581eea}{Catch\+::throw\+\_\+runtime\+\_\+error}}(CATCH\+\_\+\+MAKE\+\_\+\+MSG( \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ))\#define CATCH\+\_\+\+ENFORCE( condition, ... ) \textbackslash{}    do\{ \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( !(condition) ) CATCH\+\_\+\+ERROR( \+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ); \} while(false)\#endif \#ifndef CATCH\+\_\+\+ENUM\+\_\+\+VALUES\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ENUM\+\_\+\+VALUES\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    namespace Detail \{        \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$Enum\+Info$>$ make\+Enum\+Info( String\+Ref enum\+Name, String\+Ref all\+Value\+Names, std\+::vector$<$int$>$ const\& values );        class Enum\+Values\+Registry \+: public IMutable\+Enum\+Values\+Registry \{            std\+::vector$<$\mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$Enum\+Info$>$$>$ m\+\_\+enum\+Infos;            Enum\+Info const\& register\+Enum( String\+Ref enum\+Name, String\+Ref all\+Value\+Names, std\+::vector$<$int$>$ const\& values) override;        \};        std\+::vector$<$String\+Ref$>$ parse\+Enums( String\+Ref enums );    \} \} \#endif \#ifndef CATCH\+\_\+\+ERRNO\+\_\+\+GUARD\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ERRNO\+\_\+\+GUARD\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{            class Errno\+Guard \{    public\+:                Errno\+Guard();        \texorpdfstring{$\sim$}{\string~}Errno\+Guard();    private\+:        int m\+\_\+old\+Errno;    \};\}\#endif \#ifndef CATCH\+\_\+\+EXCEPTION\+\_\+\+TRANSLATOR\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+EXCEPTION\+\_\+\+TRANSLATOR\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$\#include $<$string$>$namespace Catch \{    class Exception\+Translator\+Registry \+: public IException\+Translator\+Registry \{    public\+:        \texorpdfstring{$\sim$}{\string~}Exception\+Translator\+Registry() override;        void register\+Translator( Detail\+::unique\+\_\+ptr$<$IException\+Translator$>$\&\& translator );        std\+::string translate\+Active\+Exception() const override;    private\+:        Exception\+Translators m\+\_\+translators;    \};\}\#endif \#ifndef CATCH\+\_\+\+FATAL\+\_\+\+CONDITION\+\_\+\+HANDLER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+FATAL\+\_\+\+CONDITION\+\_\+\+HANDLER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$namespace Catch \{        class Fatal\+Condition\+Handler \{        bool m\+\_\+started = false;                                void engage\+\_\+platform();        void disengage\+\_\+platform() noexcept;    public\+:                Fatal\+Condition\+Handler();        \texorpdfstring{$\sim$}{\string~}Fatal\+Condition\+Handler();        void engage() \{            assert(!m\+\_\+started \&\& "{}Handler cannot be installed twice."{});            m\+\_\+started = true;            engage\+\_\+platform();        \}        void disengage() noexcept \{            assert(m\+\_\+started \&\& "{}Handler cannot be uninstalled without being installed first"{});            m\+\_\+started = false;            disengage\+\_\+platform();        \}    \};        class Fatal\+Condition\+Handler\+Guard \{        Fatal\+Condition\+Handler\texorpdfstring{$\ast$}{*} m\+\_\+handler;    public\+:        Fatal\+Condition\+Handler\+Guard(Fatal\+Condition\+Handler\texorpdfstring{$\ast$}{*} handler)\+:            m\+\_\+handler(handler) \{            m\+\_\+handler-\/$>$engage();        \}        \texorpdfstring{$\sim$}{\string~}Fatal\+Condition\+Handler\+Guard() \{            m\+\_\+handler-\/$>$disengage();        \}    \};\} \#endif \#ifndef CATCH\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$\#include $<$cmath$>$\#include $<$cstdint$>$\#include $<$utility$>$\#include $<$limits$>$namespace Catch \{    namespace Detail \{        uint32\+\_\+t convert\+To\+Bits(float f);        uint64\+\_\+t convert\+To\+Bits(double d);                        bool direct\+Compare( float lhs, float rhs );        bool direct\+Compare( double lhs, double rhs );    \} \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic push            \#    pragma GCC diagnostic ignored "{}-\/Wfloat-\/equal"{}\#endif        template $<$typename FP$>$    uint64\+\_\+t ulp\+Distance( FP lhs, FP rhs ) \{        assert( std\+::numeric\+\_\+limits$<$FP$>$\+::is\+\_\+iec559 \&\&            "{}ulp\+Distance assumes IEEE-\/754 format for floating point types"{} );        assert( !\mbox{\hyperlink{namespace_catch_aff37796f0f578c2816f74267e641c5f7}{Catch\+::isnan}}( lhs ) \&\&                "{}Distance between NaN and number is not meaningful"{} );        assert( !\mbox{\hyperlink{namespace_catch_aff37796f0f578c2816f74267e641c5f7}{Catch\+::isnan}}( rhs ) \&\&                "{}Distance between NaN and number is not meaningful"{} );                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs == rhs ) \{ return 0; \}                static constexpr FP positive\+\_\+zero\{\};                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs == positive\+\_\+zero ) \{ lhs = positive\+\_\+zero; \}        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( rhs == positive\+\_\+zero ) \{ rhs = positive\+\_\+zero; \}                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( std\+::signbit( lhs ) != std\+::signbit( rhs ) ) \{            return ulp\+Distance( std\+::abs( lhs ), positive\+\_\+zero ) +                   ulp\+Distance( std\+::abs( rhs ), positive\+\_\+zero );        \}                                uint64\+\_\+t lc = Detail\+::convert\+To\+Bits( lhs );        uint64\+\_\+t rc = Detail\+::convert\+To\+Bits( rhs );                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lc $<$ rc ) \{            std\+::swap( lc, rc );        \}        return lc -\/ rc;    \}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined( \+\_\+\+\_\+\+GNUC\+\_\+\+\_\+ ) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} defined( \+\_\+\+\_\+clang\+\_\+\+\_\+ )\#    pragma GCC diagnostic pop\#endif\} \#endif \#ifndef CATCH\+\_\+\+GETENV\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+GETENV\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{namespace Detail \{        char const\texorpdfstring{$\ast$}{*} get\+Env(char const\texorpdfstring{$\ast$}{*} var\+Name);\}\}\#endif \#ifndef CATCH\+\_\+\+IS\+\_\+\+PERMUTATION\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+IS\+\_\+\+PERMUTATION\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$\#include $<$iterator$>$namespace Catch \{    namespace Detail \{        template $<$typename Forward\+Iter,                  typename Sentinel,                  typename T,                  typename Comparator$>$        Forward\+Iter find\+\_\+sentinel( Forward\+Iter start,                                   Sentinel sentinel,                                   T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}},                                   Comparator cmp ) \{            while ( start != sentinel ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( cmp( \texorpdfstring{$\ast$}{*}start, \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) ) \{ break; \}                ++start;            \}            return start;        \}        template $<$typename Forward\+Iter,                  typename Sentinel,                  typename T,                  typename Comparator$>$        std\+::ptrdiff\+\_\+t count\+\_\+sentinel( Forward\+Iter start,                                       Sentinel sentinel,                                       T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}},                                       Comparator cmp ) \{            std\+::ptrdiff\+\_\+t count = 0;            while ( start != sentinel ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( cmp( \texorpdfstring{$\ast$}{*}start, \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) ) \{ ++count; \}                ++start;            \}            return count;        \}        template $<$typename Forward\+Iter, typename Sentinel$>$        std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same$<$Forward\+Iter, Sentinel$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                         std\+::ptrdiff\+\_\+t$>$        sentinel\+\_\+distance( Forward\+Iter iter, const Sentinel sentinel ) \{            std\+::ptrdiff\+\_\+t dist = 0;            while ( iter != sentinel ) \{                ++iter;                ++dist;            \}            return dist;        \}        template $<$typename Forward\+Iter$>$        std\+::ptrdiff\+\_\+t sentinel\+\_\+distance( Forward\+Iter first,                                          Forward\+Iter last ) \{            return std\+::distance( first, last );        \}        template $<$typename Forward\+Iter1,                  typename Sentinel1,                  typename Forward\+Iter2,                  typename Sentinel2,                  typename Comparator$>$        bool check\+\_\+element\+\_\+counts( Forward\+Iter1 first\+\_\+1,                                   const Sentinel1 end\+\_\+1,                                   Forward\+Iter2 first\+\_\+2,                                   const Sentinel2 end\+\_\+2,                                   Comparator cmp ) \{            auto cursor = first\+\_\+1;            while ( cursor != end\+\_\+1 ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( find\+\_\+sentinel( first\+\_\+1, cursor, \texorpdfstring{$\ast$}{*}cursor, cmp ) ==                     cursor ) \{                                        const auto count\+\_\+in\+\_\+range\+\_\+2 =                        count\+\_\+sentinel( first\+\_\+2, end\+\_\+2, \texorpdfstring{$\ast$}{*}cursor, cmp );                                                            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( count\+\_\+in\+\_\+range\+\_\+2 == 0 ) \{ return false; \}                    const auto count\+\_\+in\+\_\+range\+\_\+1 =                        count\+\_\+sentinel( cursor, end\+\_\+1, \texorpdfstring{$\ast$}{*}cursor, cmp );                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( count\+\_\+in\+\_\+range\+\_\+1 != count\+\_\+in\+\_\+range\+\_\+2 ) \{                        return false;                    \}                \}                ++cursor;            \}            return true;        \}        template $<$typename Forward\+Iter1,                  typename Sentinel1,                  typename Forward\+Iter2,                  typename Sentinel2,                  typename Comparator$>$        bool is\+\_\+permutation( Forward\+Iter1 first\+\_\+1,                             const Sentinel1 end\+\_\+1,                             Forward\+Iter2 first\+\_\+2,                             const Sentinel2 end\+\_\+2,                             Comparator cmp ) \{                                                while (first\+\_\+1 != end\+\_\+1 \&\& first\+\_\+2 != end\+\_\+2 \&\& cmp(\texorpdfstring{$\ast$}{*}first\+\_\+1, \texorpdfstring{$\ast$}{*}first\+\_\+2)) \{                ++first\+\_\+1;                ++first\+\_\+2;            \}                        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (first\+\_\+1 == end\+\_\+1 \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} first\+\_\+2 == end\+\_\+2) \{                return first\+\_\+1 == end\+\_\+1 \&\& first\+\_\+2 == end\+\_\+2;            \}                        auto dist\+\_\+1 = sentinel\+\_\+distance( first\+\_\+1, end\+\_\+1 );            auto dist\+\_\+2 = sentinel\+\_\+distance( first\+\_\+2, end\+\_\+2 );            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (dist\+\_\+1 != dist\+\_\+2) \{ return false; \}                                                return check\+\_\+element\+\_\+counts( first\+\_\+1, end\+\_\+1, first\+\_\+2, end\+\_\+2, cmp );        \}    \} \} \#endif \#ifndef CATCH\+\_\+\+ISTREAM\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+ISTREAM\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$cstddef$>$\#include $<$ostream$>$\#include $<$string$>$namespace Catch \{    class IStream \{    public\+:        virtual \texorpdfstring{$\sim$}{\string~}IStream();         virtual std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}}() = 0;                virtual bool is\+Console() const \{ return false; \}    \};        auto make\+Stream( std\+::string const\& filename ) -\/$>$ Detail\+::unique\+\_\+ptr$<$IStream$>$;\}\#endif \#ifndef CATCH\+\_\+\+JSONWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+JSONWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdint$>$\#include $<$sstream$>$namespace Catch \{    class Json\+Object\+Writer;    class Json\+Array\+Writer;    struct Json\+Utils \{        static void indent( std\+::ostream\& os, std\+::uint64\+\_\+t level );        static void append\+Comma\+Newline( std\+::ostream\& os,                                        bool\& should\+\_\+comma,                                        std\+::uint64\+\_\+t level );    \};    class Json\+Value\+Writer \{    public\+:        Json\+Value\+Writer( std\+::ostream\& os );        Json\+Value\+Writer( std\+::ostream\& os, std\+::uint64\+\_\+t indent\+\_\+level );        Json\+Object\+Writer write\+Object() \&\&;        Json\+Array\+Writer write\+Array() \&\&;        template $<$typename T$>$        void write( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \&\& \{            write\+Impl( \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}, !std\+::is\+\_\+arithmetic$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}} );        \}        void write( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \&\&;        void write( bool \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \&\&;    private\+:        void write\+Impl( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}, bool quote );                                        template $<$typename T,                  typename = typename std\+::enable\+\_\+if\+\_\+t$<$                      !std\+::is\+\_\+convertible$<$T, String\+Ref$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        void write\+Impl( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}, bool quote\+\_\+value ) \{            m\+\_\+sstream $<$$<$ \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}};            write\+Impl( m\+\_\+sstream.\+str(), quote\+\_\+value );        \}        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};        std\+::stringstream m\+\_\+sstream;        std\+::uint64\+\_\+t m\+\_\+indent\+\_\+level;    \};    class Json\+Object\+Writer \{    public\+:        Json\+Object\+Writer( std\+::ostream\& os );        Json\+Object\+Writer( std\+::ostream\& os, std\+::uint64\+\_\+t indent\+\_\+level );        Json\+Object\+Writer( Json\+Object\+Writer\&\& source ) noexcept;        Json\+Object\+Writer\& operator=( Json\+Object\+Writer\&\& source ) = delete;        \texorpdfstring{$\sim$}{\string~}Json\+Object\+Writer();        Json\+Value\+Writer write( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}{key}} );    private\+:        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};        std\+::uint64\+\_\+t m\+\_\+indent\+\_\+level;        bool m\+\_\+should\+\_\+comma = false;        bool m\+\_\+active = true;    \};    class Json\+Array\+Writer \{    public\+:        Json\+Array\+Writer( std\+::ostream\& os );        Json\+Array\+Writer( std\+::ostream\& os, std\+::uint64\+\_\+t indent\+\_\+level );        Json\+Array\+Writer( Json\+Array\+Writer\&\& source ) noexcept;        Json\+Array\+Writer\& operator=( Json\+Array\+Writer\&\& source ) = delete;        \texorpdfstring{$\sim$}{\string~}Json\+Array\+Writer();        Json\+Object\+Writer write\+Object();        Json\+Array\+Writer write\+Array();        template $<$typename T$>$        Json\+Array\+Writer\& write( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \{            return write\+Impl( \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );        \}        Json\+Array\+Writer\& write( bool \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );    private\+:        template $<$typename T$>$        Json\+Array\+Writer\& write\+Impl( T const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} ) \{            Json\+Utils\+::append\+Comma\+Newline(                \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}}, m\+\_\+should\+\_\+comma, m\+\_\+indent\+\_\+level + 1 );            Json\+Value\+Writer\{ \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}} \}.write( \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );            return \texorpdfstring{$\ast$}{*}this;        \}        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};        std\+::uint64\+\_\+t m\+\_\+indent\+\_\+level;        bool m\+\_\+should\+\_\+comma = false;        bool m\+\_\+active = true;    \};\} \#endif \#ifndef CATCH\+\_\+\+LEAK\+\_\+\+DETECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+LEAK\+\_\+\+DETECTOR\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    struct Leak\+Detector \{        Leak\+Detector();        \texorpdfstring{$\sim$}{\string~}Leak\+Detector();    \};\}\#endif \#ifndef CATCH\+\_\+\+LIST\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+LIST\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$set$>$\#include $<$string$>$namespace Catch \{    class IEvent\+Listener;    class Config;    struct Reporter\+Description \{        std\+::string name, description;    \};    struct Listener\+Description \{        String\+Ref name;        std\+::string description;    \};    struct Tag\+Info \{        void add(String\+Ref spelling);        std\+::string all() const;        std\+::set$<$String\+Ref$>$ spellings;        std\+::size\+\_\+t count = 0;    \};    bool list( IEvent\+Listener\& reporter, Config const\& config );\} \#endif \#ifndef CATCH\+\_\+\+OUTPUT\+\_\+\+REDIRECT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+OUTPUT\+\_\+\+REDIRECT\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdio$>$\#include $<$iosfwd$>$\#include $<$string$>$namespace Catch \{    class Redirected\+Stream \{        std\+::ostream\& m\+\_\+original\+Stream;        std\+::ostream\& m\+\_\+redirection\+Stream;        std\+::streambuf\texorpdfstring{$\ast$}{*} m\+\_\+prev\+Buf;    public\+:        Redirected\+Stream( std\+::ostream\& original\+Stream, std\+::ostream\& redirection\+Stream );        \texorpdfstring{$\sim$}{\string~}Redirected\+Stream();    \};    class Redirected\+Std\+Out \{        Reusable\+String\+Stream m\+\_\+rss;        Redirected\+Stream m\+\_\+cout;    public\+:        Redirected\+Std\+Out();        auto str() const -\/$>$ std\+::string;    \};                class Redirected\+Std\+Err \{        Reusable\+String\+Stream m\+\_\+rss;        Redirected\+Stream m\+\_\+cerr;        Redirected\+Stream m\+\_\+clog;    public\+:        Redirected\+Std\+Err();        auto str() const -\/$>$ std\+::string;    \};    class Redirected\+Streams \{    public\+:        Redirected\+Streams(Redirected\+Streams const\&) = delete;        Redirected\+Streams\& operator=(Redirected\+Streams const\&) = delete;        Redirected\+Streams(Redirected\+Streams\&\&) = delete;        Redirected\+Streams\& operator=(Redirected\+Streams\&\&) = delete;        Redirected\+Streams(std\+::string\& redirected\+Cout, std\+::string\& redirected\+Cerr);        \texorpdfstring{$\sim$}{\string~}Redirected\+Streams();    private\+:        std\+::string\& m\+\_\+redirected\+Cout;        std\+::string\& m\+\_\+redirected\+Cerr;        Redirected\+Std\+Out m\+\_\+redirected\+Std\+Out;        Redirected\+Std\+Err m\+\_\+redirected\+Std\+Err;    \};\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+NEW\+\_\+\+CAPTURE)                    class Temp\+File \{    public\+:        Temp\+File(Temp\+File const\&) = delete;        Temp\+File\& operator=(Temp\+File const\&) = delete;        Temp\+File(Temp\+File\&\&) = delete;        Temp\+File\& operator=(Temp\+File\&\&) = delete;        Temp\+File();        \texorpdfstring{$\sim$}{\string~}Temp\+File();        std\+::\+FILE\texorpdfstring{$\ast$}{*} get\+File();        std\+::string get\+Contents();    private\+:        std\+::\+FILE\texorpdfstring{$\ast$}{*} m\+\_\+file = nullptr;    \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\+\_\+\+MSC\+\_\+\+VER)        char m\+\_\+buffer\mbox{[}L\+\_\+tmpnam\mbox{]} = \{ 0 \};    \#endif    \};    class Output\+Redirect \{    public\+:        Output\+Redirect(Output\+Redirect const\&) = delete;        Output\+Redirect\& operator=(Output\+Redirect const\&) = delete;        Output\+Redirect(Output\+Redirect\&\&) = delete;        Output\+Redirect\& operator=(Output\+Redirect\&\&) = delete;        Output\+Redirect(std\+::string\& stdout\+\_\+dest, std\+::string\& stderr\+\_\+dest);        \texorpdfstring{$\sim$}{\string~}Output\+Redirect();    private\+:        int m\+\_\+original\+Stdout = -\/1;        int m\+\_\+original\+Stderr = -\/1;        Temp\+File m\+\_\+stdout\+File;        Temp\+File m\+\_\+stderr\+File;        std\+::string\& m\+\_\+stdout\+Dest;        std\+::string\& m\+\_\+stderr\+Dest;    \};\#endif\} \#endif \#ifndef CATCH\+\_\+\+PARSE\+\_\+\+NUMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+PARSE\+\_\+\+NUMBERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{        Optional$<$unsigned int$>$ parse\+UInt(std\+::string const\& input, int base = 10);\}\#endif \#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$map$>$\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;    class IReporter\+Factory;    using IReporter\+Factory\+Ptr = Detail\+::unique\+\_\+ptr$<$IReporter\+Factory$>$;    struct Reporter\+Config;    class Event\+Listener\+Factory;    class Reporter\+Registry \{        struct Reporter\+Registry\+Impl;        Detail\+::unique\+\_\+ptr$<$Reporter\+Registry\+Impl$>$ m\+\_\+impl;    public\+:        Reporter\+Registry();        \texorpdfstring{$\sim$}{\string~}Reporter\+Registry();         IEvent\+Listener\+Ptr create( std\+::string const\& name,                                  Reporter\+Config\&\& config ) const;        void register\+Reporter( std\+::string const\& name,                               IReporter\+Factory\+Ptr factory );        void        register\+Listener( Detail\+::unique\+\_\+ptr$<$Event\+Listener\+Factory$>$ factory );        std\+::map$<$std\+::string,                 IReporter\+Factory\+Ptr,                 Detail\+::\+Case\+Insensitive\+Less$>$ const\&        get\+Factories() const;        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Event\+Listener\+Factory$>$$>$ const\&        get\+Listeners() const;    \};\} \#endif \#ifndef CATCH\+\_\+\+RUN\+\_\+\+CONTEXT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+RUN\+\_\+\+CONTEXT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+TRACKER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+TRACKER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$\#include $<$vector$>$namespace Catch \{namespace Test\+Case\+Tracking \{    struct Name\+And\+Location \{        std\+::string name;        Source\+Line\+Info location;        Name\+And\+Location( std\+::string\&\& \+\_\+name, Source\+Line\+Info const\& \+\_\+location );        friend bool operator==(Name\+And\+Location const\& lhs, Name\+And\+Location const\& rhs) \{                                                            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs.\+location.\+line != rhs.\+location.\+line ) \{ return false; \}            return lhs.\+name == rhs.\+name \&\& lhs.\+location == rhs.\+location;        \}        friend bool operator!=(Name\+And\+Location const\& lhs,                               Name\+And\+Location const\& rhs) \{            return !( lhs == rhs );        \}    \};        struct Name\+And\+Location\+Ref \{        String\+Ref name;        Source\+Line\+Info location;        constexpr Name\+And\+Location\+Ref( String\+Ref name\+\_\+,                                      Source\+Line\+Info location\+\_\+ )\+:            name( name\+\_\+ ), location( location\+\_\+ ) \{\}        friend bool operator==( Name\+And\+Location const\& lhs,                                Name\+And\+Location\+Ref const\& rhs ) \{                                                            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( lhs.\+location.\+line != rhs.\+location.\+line ) \{ return false; \}            return String\+Ref( lhs.\+name ) == rhs.\+name \&\&                   lhs.\+location == rhs.\+location;        \}        friend bool operator==( Name\+And\+Location\+Ref const\& lhs,                                Name\+And\+Location const\& rhs ) \{            return rhs == lhs;        \}    \};    class ITracker;    using ITracker\+Ptr = \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::unique\+\_\+ptr}}$<$ITracker$>$;    class ITracker \{        Name\+And\+Location m\+\_\+name\+And\+Location;        using Children = std\+::vector$<$ITracker\+Ptr$>$;    protected\+:        enum Cycle\+State \{            Not\+Started,            Executing,            Executing\+Children,            Needs\+Another\+Run,            Completed\+Successfully,            Failed        \};        ITracker\texorpdfstring{$\ast$}{*} m\+\_\+parent = nullptr;        Children m\+\_\+children;        Cycle\+State m\+\_\+run\+State = Not\+Started;    public\+:        ITracker( Name\+And\+Location\&\& name\+And\+Loc, ITracker\texorpdfstring{$\ast$}{*} parent )\+:            m\+\_\+name\+And\+Location( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(name\+And\+Loc) ),            m\+\_\+parent( parent )        \{\}                Name\+And\+Location const\& name\+And\+Location() const \{            return m\+\_\+name\+And\+Location;        \}        ITracker\texorpdfstring{$\ast$}{*} parent() const \{            return m\+\_\+parent;        \}        virtual \texorpdfstring{$\sim$}{\string~}ITracker();                         virtual bool is\+Complete() const = 0;                bool is\+Successfully\+Completed() const \{            return m\+\_\+run\+State == Completed\+Successfully;        \}                bool is\+Open() const;                bool has\+Started() const;                virtual void close() = 0;         virtual void fail() = 0;        void mark\+As\+Needing\+Another\+Run();                void add\+Child( ITracker\+Ptr\&\& child );                ITracker\texorpdfstring{$\ast$}{*} find\+Child( Name\+And\+Location\+Ref const\& name\+And\+Location );                bool has\+Children() const \{            return !m\+\_\+children.\+empty();        \}                void open\+Child();                virtual bool is\+Section\+Tracker() const;                virtual bool is\+Generator\+Tracker() const;    \};    class Tracker\+Context \{        enum Run\+State \{            Not\+Started,            Executing,            Completed\+Cycle        \};        ITracker\+Ptr m\+\_\+root\+Tracker;        ITracker\texorpdfstring{$\ast$}{*} m\+\_\+current\+Tracker = nullptr;        Run\+State m\+\_\+run\+State = Not\+Started;    public\+:        ITracker\& start\+Run();        void start\+Cycle() \{            m\+\_\+current\+Tracker = m\+\_\+root\+Tracker.\+get();            m\+\_\+run\+State = Executing;        \}        void complete\+Cycle();        bool completed\+Cycle() const;        ITracker\& current\+Tracker() \{ return \texorpdfstring{$\ast$}{*}m\+\_\+current\+Tracker; \}        void set\+Current\+Tracker( ITracker\texorpdfstring{$\ast$}{*} tracker );    \};    class Tracker\+Base \+: public ITracker \{    protected\+:        Tracker\+Context\& m\+\_\+ctx;    public\+:        Tracker\+Base( Name\+And\+Location\&\& name\+And\+Location, Tracker\+Context\& ctx, ITracker\texorpdfstring{$\ast$}{*} parent );        bool is\+Complete() const override;        void open();        void close() override;        void fail() override;    private\+:        void move\+To\+Parent();        void move\+To\+This();    \};    class Section\+Tracker \+: public Tracker\+Base \{        std\+::vector$<$String\+Ref$>$ m\+\_\+filters;                                        String\+Ref m\+\_\+trimmed\+\_\+name;    public\+:        Section\+Tracker( Name\+And\+Location\&\& name\+And\+Location, Tracker\+Context\& ctx, ITracker\texorpdfstring{$\ast$}{*} parent );        bool is\+Section\+Tracker() const override;        bool is\+Complete() const override;        static Section\+Tracker\& acquire( Tracker\+Context\& ctx, Name\+And\+Location\+Ref const\& name\+And\+Location );        void try\+Open();        void add\+Initial\+Filters( std\+::vector$<$std\+::string$>$ const\& filters );        void add\+Next\+Filters( std\+::vector$<$String\+Ref$>$ const\& filters );                std\+::vector$<$String\+Ref$>$ const\& get\+Filters() const \{ return m\+\_\+filters; \}                String\+Ref trimmed\+Name() const;    \};\} using Test\+Case\+Tracking\+::\+ITracker;using Test\+Case\+Tracking\+::\+Tracker\+Context;using Test\+Case\+Tracking\+::\+Section\+Tracker;\} \#endif \#include $<$string$>$namespace Catch \{    class IGenerator\+Tracker;    class IConfig;    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;        class Run\+Context final \+: public IResult\+Capture \{    public\+:        Run\+Context( Run\+Context const\& ) = delete;        Run\+Context\& operator =( Run\+Context const\& ) = delete;        explicit Run\+Context( IConfig const\texorpdfstring{$\ast$}{*} \+\_\+config, IEvent\+Listener\+Ptr\&\& reporter );        \texorpdfstring{$\sim$}{\string~}Run\+Context() override;        Totals run\+Test(Test\+Case\+Handle const\& test\+Case);    public\+:                 void handle\+Expr                (   Assertion\+Info const\& info,                    ITransient\+Expression const\& expr,                    Assertion\+Reaction\& reaction ) override;        void handle\+Message                (   Assertion\+Info const\& info,                    Result\+Was\+::\+Of\+Type result\+Type,                    String\+Ref message,                    Assertion\+Reaction\& reaction ) override;        void handle\+Unexpected\+Exception\+Not\+Thrown                (   Assertion\+Info const\& info,                    Assertion\+Reaction\& reaction ) override;        void handle\+Unexpected\+Inflight\+Exception                (   Assertion\+Info const\& info,                    std\+::string\&\& message,                    Assertion\+Reaction\& reaction ) override;        void handle\+Incomplete                (   Assertion\+Info const\& info ) override;        void handle\+Non\+Expr                (   Assertion\+Info const \&info,                    Result\+Was\+::\+Of\+Type result\+Type,                    Assertion\+Reaction \&reaction ) override;        void notify\+Assertion\+Started( Assertion\+Info const\& info ) override;        bool section\+Started( String\+Ref section\+Name,                             Source\+Line\+Info const\& section\+Line\+Info,                             Counts\& assertions ) override;        void section\+Ended( Section\+End\+Info\&\& end\+Info ) override;        void section\+Ended\+Early( Section\+End\+Info\&\& end\+Info ) override;        IGenerator\+Tracker\texorpdfstring{$\ast$}{*}        acquire\+Generator\+Tracker( String\+Ref generator\+Name,                                 Source\+Line\+Info const\& line\+Info ) override;        IGenerator\+Tracker\texorpdfstring{$\ast$}{*} create\+Generator\+Tracker(            String\+Ref generator\+Name,            Source\+Line\+Info line\+Info,            Generators\+::\+Generator\+Base\+Ptr\&\& generator ) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& info ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}} ) override;        void benchmark\+Failed( String\+Ref error ) override;        void push\+Scoped\+Message( Message\+Info const\& message ) override;        void pop\+Scoped\+Message( Message\+Info const\& message ) override;        void emplace\+Unscoped\+Message( Message\+Builder\&\& builder ) override;        std\+::string get\+Current\+Test\+Name() const override;        const Assertion\+Result\texorpdfstring{$\ast$}{*} get\+Last\+Result() const override;        void exception\+Early\+Reported() override;        void handle\+Fatal\+Error\+Condition( String\+Ref message ) override;        bool last\+Assertion\+Passed() override;        void assertion\+Passed() override;    public\+:                bool aborting() const;    private\+:        void run\+Current\+Test( std\+::string\& redirected\+Cout, std\+::string\& redirected\+Cerr );        void invoke\+Active\+Test\+Case();        void reset\+Assertion\+Info();        bool test\+For\+Missing\+Assertions( Counts\& assertions );        void assertion\+Ended( Assertion\+Result\&\& \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} );        void report\+Expr                (   Assertion\+Info const \&info,                    Result\+Was\+::\+Of\+Type result\+Type,                    ITransient\+Expression const \texorpdfstring{$\ast$}{*}expr,                    bool negated );        void populate\+Reaction( Assertion\+Reaction\& reaction );    private\+:        void handle\+Unfinished\+Sections();        Test\+Run\+Info m\+\_\+run\+Info;        Test\+Case\+Handle const\texorpdfstring{$\ast$}{*} m\+\_\+active\+Test\+Case = nullptr;        ITracker\texorpdfstring{$\ast$}{*} m\+\_\+test\+Case\+Tracker = nullptr;        Optional$<$Assertion\+Result$>$ m\+\_\+last\+Result;        IConfig const\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}{m\+\_\+config}};        Totals m\+\_\+totals;        IEvent\+Listener\+Ptr \mbox{\hyperlink{catch__amalgamated_8cpp_aee7954c057251292dd81c24e2931c774}{m\+\_\+reporter}};        std\+::vector$<$Message\+Info$>$ m\+\_\+messages;        std\+::vector$<$Scoped\+Message$>$ m\+\_\+message\+Scopes;         Assertion\+Info m\+\_\+last\+Assertion\+Info;        std\+::vector$<$Section\+End\+Info$>$ m\+\_\+unfinished\+Sections;        std\+::vector$<$ITracker\texorpdfstring{$\ast$}{*}$>$ m\+\_\+active\+Sections;        Tracker\+Context m\+\_\+tracker\+Context;        Fatal\+Condition\+Handler m\+\_\+fatal\+Conditionhandler;        bool m\+\_\+last\+Assertion\+Passed = false;        bool m\+\_\+should\+Report\+Unexpected = true;        bool m\+\_\+include\+Successful\+Results;    \};    void seed\+Rng(IConfig const\& config);    unsigned int rng\+Seed();\} \#endif \#ifndef CATCH\+\_\+\+SHARDING\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+SHARDING\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$\#include $<$cmath$>$\#include $<$algorithm$>$namespace Catch \{    template$<$typename Container$>$    Container create\+Shard(Container const\& container, std\+::size\+\_\+t const \mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}}, std\+::size\+\_\+t const \mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}}) \{        assert(\mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}} $>$ \mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}});        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (\mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}} == 1) \{            return container;        \}        const std\+::size\+\_\+t total\+Test\+Count = container.\+size();        const std\+::size\+\_\+t shard\+Size = total\+Test\+Count / \mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}};        const std\+::size\+\_\+t leftover\+Tests = total\+Test\+Count \% \mbox{\hyperlink{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}{shard\+Count}};        const std\+::size\+\_\+t start\+Index = \mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}} \texorpdfstring{$\ast$}{*} shard\+Size + (std\+::min)(\mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}}, leftover\+Tests);        const std\+::size\+\_\+t end\+Index = (\mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}} + 1) \texorpdfstring{$\ast$}{*} shard\+Size + (std\+::min)(\mbox{\hyperlink{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}{shard\+Index}} + 1, leftover\+Tests);        auto start\+Iterator = std\+::next(container.\+begin(), static\+\_\+cast$<$std\+::ptrdiff\+\_\+t$>$(start\+Index));        auto end\+Iterator = std\+::next(container.\+begin(), static\+\_\+cast$<$std\+::ptrdiff\+\_\+t$>$(end\+Index));        return Container(start\+Iterator, end\+Iterator);    \}\}\#endif \#ifndef CATCH\+\_\+\+SINGLETONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+SINGLETONS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    struct ISingleton \{        virtual \texorpdfstring{$\sim$}{\string~}ISingleton();     \};    void add\+Singleton( ISingleton\texorpdfstring{$\ast$}{*} singleton );    void cleanup\+Singletons();    template$<$typename Singleton\+ImplT, typename InterfaceT = Singleton\+ImplT, typename Mutable\+InterfaceT = InterfaceT$>$    class Singleton \+: Singleton\+ImplT, public ISingleton \{        static auto get\+Internal() -\/$>$ Singleton\texorpdfstring{$\ast$}{*} \{            static Singleton\texorpdfstring{$\ast$}{*} s\+\_\+instance = nullptr;            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( !s\+\_\+instance ) \{                s\+\_\+instance = new Singleton;                add\+Singleton( s\+\_\+instance );            \}            return s\+\_\+instance;        \}    public\+:        static auto get() -\/$>$ InterfaceT const\& \{            return \texorpdfstring{$\ast$}{*}get\+Internal();        \}        static auto get\+Mutable() -\/$>$ Mutable\+InterfaceT\& \{            return \texorpdfstring{$\ast$}{*}get\+Internal();        \}    \};\} \#endif \#ifndef CATCH\+\_\+\+STARTUP\+\_\+\+EXCEPTION\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+STARTUP\+\_\+\+EXCEPTION\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$\#include $<$exception$>$namespace Catch \{    class Startup\+Exception\+Registry \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(\mbox{\hyperlink{catch__amalgamated_8hpp_a893712b2ba6e7400136a0a023b12e9db}{CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\+\_\+\+EXCEPTIONS}})    public\+:        void add(std\+::exception\+\_\+ptr const\& exception) noexcept;        std\+::vector$<$std\+::exception\+\_\+ptr$>$ const\& get\+Exceptions() const noexcept;    private\+:        std\+::vector$<$std\+::exception\+\_\+ptr$>$ m\+\_\+exceptions;\#endif    \};\} \#endif \#ifndef CATCH\+\_\+\+STDSTREAMS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+STDSTREAMS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$namespace Catch \{    std\+::ostream\& cout();    std\+::ostream\& cerr();    std\+::ostream\& clog();\} \#endif\#ifndef CATCH\+\_\+\+STRING\+\_\+\+MANIP\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+STRING\+\_\+\+MANIP\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdint$>$\#include $<$string$>$\#include $<$iosfwd$>$\#include $<$vector$>$namespace Catch \{    bool starts\+With( std\+::string const\& s, std\+::string const\& prefix );    bool starts\+With( String\+Ref s, char prefix );    bool ends\+With( std\+::string const\& s, std\+::string const\& suffix );    bool ends\+With( std\+::string const\& s, char suffix );    bool contains( std\+::string const\& s, std\+::string const\& infix );    void to\+Lower\+In\+Place( std\+::string\& s );    std\+::string to\+Lower( std\+::string const\& s );    char to\+Lower( char c );        std\+::string trim( std\+::string const\& str );        String\+Ref trim(String\+Ref ref);        std\+::vector$<$String\+Ref$>$ split\+String\+Ref( String\+Ref str, char delimiter );    bool replace\+In\+Place( std\+::string\& str, std\+::string const\& replace\+This, std\+::string const\& with\+This );        class pluralise \{        std\+::uint64\+\_\+t m\+\_\+count;        String\+Ref m\+\_\+label;    public\+:        constexpr pluralise(std\+::uint64\+\_\+t count, String\+Ref label)\+:            m\+\_\+count(count),            m\+\_\+label(label)        \{\}        friend std\+::ostream\& operator $<$$<$ ( std\+::ostream\& os, pluralise const\& pluraliser );    \};\}\#endif \#ifndef CATCH\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TAG\+\_\+\+ALIAS\+\_\+\+REGISTRY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$map$>$\#include $<$string$>$namespace Catch \{    struct Source\+Line\+Info;    class Tag\+Alias\+Registry \+: public ITag\+Alias\+Registry \{    public\+:        \texorpdfstring{$\sim$}{\string~}Tag\+Alias\+Registry() override;        Tag\+Alias const\texorpdfstring{$\ast$}{*} find( std\+::string const\& alias ) const override;        std\+::string expand\+Aliases( std\+::string const\& unexpanded\+Test\+Spec ) const override;        void add( std\+::string const\& alias, std\+::string const\& tag, Source\+Line\+Info const\& line\+Info );    private\+:        std\+::map$<$std\+::string, Tag\+Alias$>$ m\+\_\+registry;    \};\} \#endif \#ifndef CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+INFO\+\_\+\+HASHER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+INFO\+\_\+\+HASHER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstdint$>$namespace Catch \{    struct Test\+Case\+Info;    class Test\+Case\+Info\+Hasher \{    public\+:        using hash\+\_\+t = std\+::uint64\+\_\+t;        Test\+Case\+Info\+Hasher( hash\+\_\+t seed );        uint32\+\_\+t operator()( Test\+Case\+Info const\& t ) const;    private\+:        hash\+\_\+t m\+\_\+seed;    \};\} \#endif \#ifndef CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+REGISTRY\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+CASE\+\_\+\+REGISTRY\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    class IConfig;    class ITest\+Invoker;    class Test\+Case\+Handle;    class Test\+Spec;    std\+::vector$<$Test\+Case\+Handle$>$ sort\+Tests( IConfig const\& config, std\+::vector$<$Test\+Case\+Handle$>$ const\& unsorted\+Test\+Cases );    bool is\+Throw\+Safe( Test\+Case\+Handle const\& test\+Case, IConfig const\& config );    std\+::vector$<$Test\+Case\+Handle$>$ filter\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& test\+Cases, Test\+Spec const\& test\+Spec, IConfig const\& config );    std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Test\+Cases\+Sorted( IConfig const\& config );    class Test\+Registry \+: public ITest\+Case\+Registry \{    public\+:        void register\+Test( Detail\+::unique\+\_\+ptr$<$Test\+Case\+Info$>$ test\+Info, Detail\+::unique\+\_\+ptr$<$ITest\+Invoker$>$ test\+Invoker );        std\+::vector$<$Test\+Case\+Info\texorpdfstring{$\ast$}{*}$>$ const\& get\+All\+Infos() const override;        std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests() const override;        std\+::vector$<$Test\+Case\+Handle$>$ const\& get\+All\+Tests\+Sorted( IConfig const\& config ) const override;        \texorpdfstring{$\sim$}{\string~}Test\+Registry() override;     private\+:        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Test\+Case\+Info$>$$>$ m\+\_\+owned\+\_\+test\+\_\+infos;                        std\+::vector$<$Test\+Case\+Info\texorpdfstring{$\ast$}{*}$>$ m\+\_\+viewed\+\_\+test\+\_\+infos;        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$ITest\+Invoker$>$$>$ m\+\_\+invokers;        std\+::vector$<$Test\+Case\+Handle$>$ m\+\_\+handles;        mutable Test\+Run\+Order m\+\_\+current\+Sort\+Order = Test\+Run\+Order\+::\+Declared;        mutable std\+::vector$<$Test\+Case\+Handle$>$ m\+\_\+sorted\+Functions;    \};    \} \#endif \#ifndef CATCH\+\_\+\+TEST\+\_\+\+SPEC\+\_\+\+PARSER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEST\+\_\+\+SPEC\+\_\+\+PARSER\+\_\+\+HPP\+\_\+\+INCLUDED\#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#pragma clang diagnostic push\#pragma clang diagnostic ignored "{}-\/Wpadded"{}\#endif\#include $<$vector$>$\#include $<$string$>$namespace Catch \{    class ITag\+Alias\+Registry;    class Test\+Spec\+Parser \{        enum Mode\{ None, Name, Quoted\+Name, Tag, Escaped\+Name \};        Mode m\+\_\+mode = None;        Mode last\+Mode = None;        bool m\+\_\+exclusion = false;        std\+::size\+\_\+t m\+\_\+pos = 0;        std\+::size\+\_\+t m\+\_\+real\+Pattern\+Pos = 0;        std\+::string m\+\_\+arg;        std\+::string m\+\_\+substring;        std\+::string m\+\_\+pattern\+Name;        std\+::vector$<$std\+::size\+\_\+t$>$ m\+\_\+escape\+Chars;        Test\+Spec\+::\+Filter m\+\_\+current\+Filter;        Test\+Spec m\+\_\+test\+Spec;        ITag\+Alias\+Registry const\texorpdfstring{$\ast$}{*} m\+\_\+tag\+Aliases = nullptr;    public\+:        Test\+Spec\+Parser( ITag\+Alias\+Registry const\& tag\+Aliases );        Test\+Spec\+Parser\& parse( std\+::string const\& arg );        Test\+Spec test\+Spec();    private\+:        bool visit\+Char( char c );        void start\+New\+Mode( Mode mode );        bool process\+None\+Char( char c );        void process\+Name\+Char( char c );        bool process\+Other\+Char( char c );        void end\+Mode();        void escape();        bool is\+Control\+Char( char c ) const;        void save\+Last\+Mode();        void revert\+Back\+To\+Last\+Mode();        void add\+Filter();        bool separate();                std\+::string preprocess\+Pattern();                void add\+Name\+Pattern();                void add\+Tag\+Pattern();        inline void add\+Char\+To\+Pattern(char c) \{            m\+\_\+substring += c;            m\+\_\+pattern\+Name += c;            m\+\_\+real\+Pattern\+Pos++;        \}    \};\} \#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#pragma clang diagnostic pop\#endif\#endif \#ifndef CATCH\+\_\+\+TEXTFLOW\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TEXTFLOW\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cassert$>$\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    namespace Text\+Flow \{        class Columns;                class Column \{                        std\+::string m\+\_\+string;                        size\+\_\+t \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}} = CATCH\+\_\+\+CONFIG\+\_\+\+CONSOLE\+\_\+\+WIDTH -\/ 1;                        size\+\_\+t m\+\_\+indent = 0;                        size\+\_\+t m\+\_\+initial\+Indent = std\+::string\+::npos;        public\+:                        class const\+\_\+iterator \{                friend Column;                struct End\+Tag \{\};                Column const\& m\+\_\+column;                                size\+\_\+t m\+\_\+line\+Start = 0;                                size\+\_\+t m\+\_\+line\+Length = 0;                                size\+\_\+t m\+\_\+parsed\+To = 0;                                bool m\+\_\+add\+Hyphen = false;                const\+\_\+iterator( Column const\& column, End\+Tag )\+:                    m\+\_\+column( column ), m\+\_\+line\+Start( m\+\_\+column.\+m\+\_\+string.\+size() ) \{\}                                void calc\+Length();                                size\+\_\+t indent\+Size() const;                                                std\+::string add\+Indent\+And\+Suffix( size\+\_\+t position,                                                size\+\_\+t length ) const;            public\+:                using difference\+\_\+type = std\+::ptrdiff\+\_\+t;                using value\+\_\+type = std\+::string;                using pointer = value\+\_\+type\texorpdfstring{$\ast$}{*};                using reference = value\+\_\+type\&;                using iterator\+\_\+category = std\+::forward\+\_\+iterator\+\_\+tag;                explicit const\+\_\+iterator( Column const\& column );                std\+::string operator\texorpdfstring{$\ast$}{*}() const;                const\+\_\+iterator\& operator++();                const\+\_\+iterator operator++( int );                bool operator==( const\+\_\+iterator const\& other ) const \{                    return m\+\_\+line\+Start == other.\+m\+\_\+line\+Start \&\& \&m\+\_\+column == \&other.\+m\+\_\+column;                \}                bool operator!=( const\+\_\+iterator const\& other ) const \{                    return !operator==( other );                \}            \};            using iterator = const\+\_\+iterator;            explicit Column( std\+::string const\& text )\+: m\+\_\+string( text ) \{\}            explicit Column( std\+::string\&\& text )\+:                m\+\_\+string( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(text)) \{\}            Column\& width( size\+\_\+t new\+Width ) \& \{                assert( new\+Width $>$ 0 );                \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}} = new\+Width;                return \texorpdfstring{$\ast$}{*}this;            \}            Column\&\& width( size\+\_\+t new\+Width ) \&\& \{                assert( new\+Width $>$ 0 );                \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}} = new\+Width;                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( \texorpdfstring{$\ast$}{*}this );            \}            Column\& indent( size\+\_\+t new\+Indent ) \& \{                m\+\_\+indent = new\+Indent;                return \texorpdfstring{$\ast$}{*}this;            \}            Column\&\& indent( size\+\_\+t new\+Indent ) \&\& \{                m\+\_\+indent = new\+Indent;                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( \texorpdfstring{$\ast$}{*}this );            \}            Column\& initial\+Indent( size\+\_\+t new\+Indent ) \& \{                m\+\_\+initial\+Indent = new\+Indent;                return \texorpdfstring{$\ast$}{*}this;            \}            Column\&\& initial\+Indent( size\+\_\+t new\+Indent ) \&\& \{                m\+\_\+initial\+Indent = new\+Indent;                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( \texorpdfstring{$\ast$}{*}this );            \}            size\+\_\+t width() const \{ return \mbox{\hyperlink{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}{m\+\_\+width}}; \}            const\+\_\+iterator begin() const \{ return const\+\_\+iterator( \texorpdfstring{$\ast$}{*}this ); \}            const\+\_\+iterator end() const \{ return \{ \texorpdfstring{$\ast$}{*}this, const\+\_\+iterator\+::\+End\+Tag\{\} \}; \}            friend std\+::ostream\& operator$<$$<$( std\+::ostream\& os,                                             Column const\& col );            friend Columns operator+( Column const\& lhs, Column const\& rhs );            friend Columns operator+( Column\&\& lhs, Column\&\& rhs );        \};                Column Spacer( size\+\_\+t space\+Width );        class Columns \{            std\+::vector$<$Column$>$ m\+\_\+columns;        public\+:            class iterator \{                friend Columns;                struct End\+Tag \{\};                std\+::vector$<$Column$>$ const\& m\+\_\+columns;                std\+::vector$<$Column\+::const\+\_\+iterator$>$ m\+\_\+iterators;                size\+\_\+t m\+\_\+active\+Iterators;                iterator( Columns const\& columns, End\+Tag );            public\+:                using difference\+\_\+type = std\+::ptrdiff\+\_\+t;                using value\+\_\+type = std\+::string;                using pointer = value\+\_\+type\texorpdfstring{$\ast$}{*};                using reference = value\+\_\+type\&;                using iterator\+\_\+category = std\+::forward\+\_\+iterator\+\_\+tag;                explicit iterator( Columns const\& columns );                auto operator==( iterator const\& other ) const -\/$>$ bool \{                    return m\+\_\+iterators == other.\+m\+\_\+iterators;                \}                auto operator!=( iterator const\& other ) const -\/$>$ bool \{                    return m\+\_\+iterators != other.\+m\+\_\+iterators;                \}                std\+::string operator\texorpdfstring{$\ast$}{*}() const;                iterator\& operator++();                iterator operator++( int );            \};            using const\+\_\+iterator = iterator;            iterator begin() const \{ return iterator( \texorpdfstring{$\ast$}{*}this ); \}            iterator end() const \{ return \{ \texorpdfstring{$\ast$}{*}this, iterator\+::\+End\+Tag() \}; \}            friend Columns\& operator+=( Columns\& lhs, Column const\& rhs );            friend Columns\& operator+=( Columns\& lhs, Column\&\& rhs );            friend Columns operator+( Columns const\& lhs, Column const\& rhs );            friend Columns operator+( Columns\&\& lhs, Column\&\& rhs );            friend std\+::ostream\& operator$<$$<$( std\+::ostream\& os,                                             Columns const\& cols );        \};    \} \} \#endif \#ifndef CATCH\+\_\+\+TO\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+TO\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    template $<$typename T$>$    std\+::string to\+\_\+string(T const\& t) \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(\mbox{\hyperlink{catch__amalgamated_8hpp_a5e8669f07e3db1e9e1604508689bc28a}{CATCH\+\_\+\+CONFIG\+\_\+\+CPP11\+\_\+\+TO\+\_\+\+STRING}})        return std\+::to\+\_\+string(t);\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}        Reusable\+String\+Stream rss;        rss $<$$<$ t;        return rss.\+str();\#endif    \}\} \#endif \#ifndef CATCH\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+UNCAUGHT\+\_\+\+EXCEPTIONS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    bool uncaught\+\_\+exceptions();\} \#endif \#ifndef CATCH\+\_\+\+XMLWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+XMLWRITER\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$vector$>$namespace Catch \{    enum class Xml\+Formatting \{        None = 0x00,        Indent = 0x01,        Newline = 0x02,    \};    Xml\+Formatting operator \texorpdfstring{$\vert$}{|} (Xml\+Formatting lhs, Xml\+Formatting rhs);    Xml\+Formatting operator \& (Xml\+Formatting lhs, Xml\+Formatting rhs);        class Xml\+Encode \{    public\+:        enum For\+What \{ For\+Text\+Nodes, For\+Attributes \};        Xml\+Encode( String\+Ref str, For\+What for\+What = For\+Text\+Nodes );        void encode\+To( std\+::ostream\& os ) const;        friend std\+::ostream\& operator $<$$<$ ( std\+::ostream\& os, Xml\+Encode const\& xml\+Encode );    private\+:        String\+Ref m\+\_\+str;        For\+What m\+\_\+for\+What;    \};    class Xml\+Writer \{    public\+:        class Scoped\+Element \{        public\+:            Scoped\+Element( Xml\+Writer\texorpdfstring{$\ast$}{*} writer, Xml\+Formatting fmt );            Scoped\+Element( Scoped\+Element\&\& other ) noexcept;            Scoped\+Element\& operator=( Scoped\+Element\&\& other ) noexcept;            \texorpdfstring{$\sim$}{\string~}Scoped\+Element();            Scoped\+Element\&            write\+Text( String\+Ref text,                       Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|}                                           Xml\+Formatting\+::\+Indent );            Scoped\+Element\& write\+Attribute( String\+Ref name,                                           String\+Ref attribute );            template $<$typename T,                                                                                                              typename = typename std\+::enable\+\_\+if\+\_\+t$<$                          !std\+::is\+\_\+convertible$<$T, String\+Ref$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$            Scoped\+Element\& write\+Attribute( String\+Ref name,                                           T const\& attribute ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_ab448bd968db5f560dde343c3bee4df2b}{m\+\_\+writer}}-\/$>$write\+Attribute( name, attribute );                return \texorpdfstring{$\ast$}{*}this;            \}        private\+:            Xml\+Writer\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{catch__amalgamated_8cpp_ab448bd968db5f560dde343c3bee4df2b}{m\+\_\+writer}} = nullptr;            Xml\+Formatting m\+\_\+fmt;        \};        Xml\+Writer( std\+::ostream\& os );        \texorpdfstring{$\sim$}{\string~}Xml\+Writer();        Xml\+Writer( Xml\+Writer const\& ) = delete;        Xml\+Writer\& operator=( Xml\+Writer const\& ) = delete;        Xml\+Writer\& start\+Element( std\+::string const\& name, Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|} Xml\+Formatting\+::\+Indent);        Scoped\+Element scoped\+Element( std\+::string const\& name, Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|} Xml\+Formatting\+::\+Indent);        Xml\+Writer\& end\+Element(Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|} Xml\+Formatting\+::\+Indent);                Xml\+Writer\& write\+Attribute( String\+Ref name, String\+Ref attribute );                Xml\+Writer\& write\+Attribute( String\+Ref name, bool attribute );                Xml\+Writer\& write\+Attribute( String\+Ref name, char const\texorpdfstring{$\ast$}{*} attribute );                        template $<$typename T,                                                                                          typename = typename std\+::enable\+\_\+if\+\_\+t$<$                      !std\+::is\+\_\+convertible$<$T, String\+Ref$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Xml\+Writer\& write\+Attribute( String\+Ref name, T const\& attribute ) \{            Reusable\+String\+Stream rss;            rss $<$$<$ attribute;            return write\+Attribute( name, rss.\+str() );        \}                Xml\+Writer\& write\+Text( String\+Ref text,                              Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|}                                                  Xml\+Formatting\+::\+Indent );                Xml\+Writer\& write\+Comment( String\+Ref text,                                 Xml\+Formatting fmt = Xml\+Formatting\+::\+Newline \texorpdfstring{$\vert$}{|}                                                     Xml\+Formatting\+::\+Indent );        void write\+Stylesheet\+Ref( String\+Ref url );        void ensure\+Tag\+Closed();    private\+:        void apply\+Formatting(Xml\+Formatting fmt);        void write\+Declaration();        void newline\+If\+Necessary();        bool m\+\_\+tag\+Is\+Open = false;        bool m\+\_\+needs\+Newline = false;        std\+::vector$<$std\+::string$>$ m\+\_\+tags;        std\+::string m\+\_\+indent;        std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}{m\+\_\+os}};    \};\}\#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+IMPL\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    template$<$typename ArgT, typename MatcherT$>$    class Match\+Expr \+: public ITransient\+Expression \{        ArgT \&\& m\+\_\+arg;        MatcherT const\& m\+\_\+matcher;    public\+:        Match\+Expr( ArgT \&\& arg, MatcherT const\& matcher )        \+:   ITransient\+Expression\{ true, matcher.\+match( arg ) \},             m\+\_\+arg( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(arg) ),            m\+\_\+matcher( matcher )        \{\}        void stream\+Reconstructed\+Expression( std\+::ostream\& os ) const override \{            os $<$$<$ \mbox{\hyperlink{namespace_catch_1_1_detail_af0ad48344ffd3f92f3568465248a9880}{Catch\+::\+Detail\+::stringify}}( m\+\_\+arg )               $<$$<$ \textquotesingle{} \textquotesingle{}               $<$$<$ m\+\_\+matcher.\+to\+String();        \}    \};    namespace Matchers \{        template $<$typename ArgT$>$        class Matcher\+Base;    \}    using String\+Matcher = Matchers\+::\+Matcher\+Base$<$std\+::string$>$;    void handle\+Exception\+Match\+Expr( Assertion\+Handler\& handler, String\+Matcher const\& matcher );    template$<$typename ArgT, typename MatcherT$>$    auto make\+Match\+Expr( ArgT \&\& arg, MatcherT const\& matcher ) -\/$>$ Match\+Expr$<$ArgT, MatcherT$>$ \{        return Match\+Expr$<$ArgT, MatcherT$>$( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(arg), matcher );    \}\} \#define INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( macro\+Name, matcher, result\+Disposition, arg ) \textbackslash{}    do \{ \textbackslash{}        \mbox{\hyperlink{class_catch_1_1_assertion_handler}{Catch\+::\+Assertion\+Handler}} catch\+Assertion\+Handler( macro\+Name\#\#\+\_\+catch\+\_\+sr, \mbox{\hyperlink{catch__amalgamated_8hpp_abc0b2405454c51748a31e0393d9ad5d1}{CATCH\+\_\+\+INTERNAL\+\_\+\+LINEINFO}}, \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(arg) "{}, "{} \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(matcher), result\+Disposition ); \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_af21395add3cdee3109e0a2e7c15a54bc}{INTERNAL\+\_\+\+CATCH\+\_\+\+TRY}} \{ \textbackslash{}            catch\+Assertion\+Handler.\+handle\+Expr( Catch\+::make\+Match\+Expr( arg, matcher ) ); \textbackslash{}        \} \mbox{\hyperlink{catch__amalgamated_8hpp_a3ef8d1213eac4fd0e2fdb4e13bdb8070}{INTERNAL\+\_\+\+CATCH\+\_\+\+CATCH}}( catch\+Assertion\+Handler ) \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a87986fec7b6b65bdae29cd2fa62bec20}{INTERNAL\+\_\+\+CATCH\+\_\+\+REACT}}( catch\+Assertion\+Handler ) \textbackslash{}    \} while( false )\#define INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( macro\+Name, exception\+Type, result\+Disposition, matcher, ... ) \textbackslash{}    do \{ \textbackslash{}        \mbox{\hyperlink{class_catch_1_1_assertion_handler}{Catch\+::\+Assertion\+Handler}} catch\+Assertion\+Handler( macro\+Name\#\#\+\_\+catch\+\_\+sr, \mbox{\hyperlink{catch__amalgamated_8hpp_abc0b2405454c51748a31e0393d9ad5d1}{CATCH\+\_\+\+INTERNAL\+\_\+\+LINEINFO}}, \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(\+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+) "{}, "{} \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(exception\+Type) "{}, "{} \mbox{\hyperlink{catch__amalgamated_8hpp_ab6dc42a98c8854e2e1d91874b1fe406c}{CATCH\+\_\+\+INTERNAL\+\_\+\+STRINGIFY}}(matcher), result\+Disposition ); \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( catch\+Assertion\+Handler.\+allow\+Throws() ) \textbackslash{}            try \{ \textbackslash{}                static\+\_\+cast$<$void$>$(\+\_\+\+\_\+\+VA\+\_\+\+ARGS\+\_\+\+\_\+ ); \textbackslash{}                catch\+Assertion\+Handler.\+handle\+Unexpected\+Exception\+Not\+Thrown(); \textbackslash{}            \} \textbackslash{}            catch( exception\+Type const\& ex ) \{ \textbackslash{}                catch\+Assertion\+Handler.\+handle\+Expr( Catch\+::make\+Match\+Expr( ex, matcher ) ); \textbackslash{}            \} \textbackslash{}            catch( ... ) \{ \textbackslash{}                catch\+Assertion\+Handler.\+handle\+Unexpected\+Inflight\+Exception(); \textbackslash{}            \} \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} \textbackslash{}            catch\+Assertion\+Handler.\+handle\+Throwing\+Call\+Skipped(); \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a87986fec7b6b65bdae29cd2fa62bec20}{INTERNAL\+\_\+\+CATCH\+\_\+\+REACT}}( catch\+Assertion\+Handler ) \textbackslash{}    \} while( false )\#endif \#include $<$string$>$\#include $<$vector$>$namespace Catch \{namespace Matchers \{    class Matcher\+Untyped\+Base \{    public\+:        Matcher\+Untyped\+Base() = default;        Matcher\+Untyped\+Base(Matcher\+Untyped\+Base const\&) = default;        Matcher\+Untyped\+Base(Matcher\+Untyped\+Base\&\&) = default;        Matcher\+Untyped\+Base\& operator = (Matcher\+Untyped\+Base const\&) = delete;        Matcher\+Untyped\+Base\& operator = (Matcher\+Untyped\+Base\&\&) = delete;        std\+::string to\+String() const;    protected\+:        virtual \texorpdfstring{$\sim$}{\string~}Matcher\+Untyped\+Base();         virtual std\+::string describe() const = 0;        mutable std\+::string m\+\_\+cached\+To\+String;    \};    template$<$typename T$>$    class Matcher\+Base \+: public Matcher\+Untyped\+Base \{    public\+:        virtual bool match( T const\& arg ) const = 0;    \};    namespace Detail \{        template$<$typename ArgT$>$        class Match\+All\+Of final \+: public Matcher\+Base$<$ArgT$>$ \{            std\+::vector$<$Matcher\+Base$<$ArgT$>$ const\texorpdfstring{$\ast$}{*}$>$ m\+\_\+matchers;        public\+:            Match\+All\+Of() = default;            Match\+All\+Of(Match\+All\+Of const\&) = delete;            Match\+All\+Of\& operator=(Match\+All\+Of const\&) = delete;            Match\+All\+Of(Match\+All\+Of\&\&) = default;            Match\+All\+Of\& operator=(Match\+All\+Of\&\&) = default;            bool match( ArgT const\& arg ) const override \{                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!matcher-\/$>$match(arg))                        return false;                \}                return true;            \}            std\+::string describe() const override \{                std\+::string description;                description.\+reserve( 4 + m\+\_\+matchers.\+size()\texorpdfstring{$\ast$}{*}32 );                description += "{}( "{};                bool first = true;                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( first )                        first = false;                    \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                        description += "{} and "{};                    description += matcher-\/$>$to\+String();                \}                description += "{} )"{};                return description;            \}            friend Match\+All\+Of operator\&\& (Match\+All\+Of\&\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) \{                lhs.\+m\+\_\+matchers.\+push\+\_\+back(\&rhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs);            \}            friend Match\+All\+Of operator\&\& (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+All\+Of\&\& rhs) \{                rhs.\+m\+\_\+matchers.\+insert(rhs.\+m\+\_\+matchers.\+begin(), \&lhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs);            \}        \};                        template$<$typename ArgT$>$        Match\+All\+Of$<$ArgT$>$ operator\&\& (Match\+All\+Of$<$ArgT$>$ const\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) = delete;                        template$<$typename ArgT$>$        Match\+All\+Of$<$ArgT$>$ operator\&\& (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+All\+Of$<$ArgT$>$ const\& rhs) = delete;        template$<$typename ArgT$>$        class Match\+Any\+Of final \+: public Matcher\+Base$<$ArgT$>$ \{            std\+::vector$<$Matcher\+Base$<$ArgT$>$ const\texorpdfstring{$\ast$}{*}$>$ m\+\_\+matchers;        public\+:            Match\+Any\+Of() = default;            Match\+Any\+Of(Match\+Any\+Of const\&) = delete;            Match\+Any\+Of\& operator=(Match\+Any\+Of const\&) = delete;            Match\+Any\+Of(Match\+Any\+Of\&\&) = default;            Match\+Any\+Of\& operator=(Match\+Any\+Of\&\&) = default;            bool match( ArgT const\& arg ) const override \{                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (matcher-\/$>$match(arg))                        return true;                \}                return false;            \}            std\+::string describe() const override \{                std\+::string description;                description.\+reserve( 4 + m\+\_\+matchers.\+size()\texorpdfstring{$\ast$}{*}32 );                description += "{}( "{};                bool first = true;                for( auto matcher \+: m\+\_\+matchers ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}}( first )                        first = false;                    \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                        description += "{} or "{};                    description += matcher-\/$>$to\+String();                \}                description += "{} )"{};                return description;            \}            friend Match\+Any\+Of operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Match\+Any\+Of\&\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) \{                lhs.\+m\+\_\+matchers.\+push\+\_\+back(\&rhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs);            \}            friend Match\+Any\+Of operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+Any\+Of\&\& rhs) \{                rhs.\+m\+\_\+matchers.\+insert(rhs.\+m\+\_\+matchers.\+begin(), \&lhs);                return \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs);            \}        \};                        template$<$typename ArgT$>$        Match\+Any\+Of$<$ArgT$>$ operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Match\+Any\+Of$<$ArgT$>$ const\& lhs, Matcher\+Base$<$ArgT$>$ const\& rhs) = delete;                        template$<$typename ArgT$>$        Match\+Any\+Of$<$ArgT$>$ operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$ArgT$>$ const\& lhs, Match\+Any\+Of$<$ArgT$>$ const\& rhs) = delete;        template$<$typename ArgT$>$        class Match\+Not\+Of final \+: public Matcher\+Base$<$ArgT$>$ \{            Matcher\+Base$<$ArgT$>$ const\& m\+\_\+underlying\+Matcher;        public\+:            explicit Match\+Not\+Of( Matcher\+Base$<$ArgT$>$ const\& underlying\+Matcher )\+:                m\+\_\+underlying\+Matcher( underlying\+Matcher )            \{\}            bool match( ArgT const\& arg ) const override \{                return !m\+\_\+underlying\+Matcher.\+match( arg );            \}            std\+::string describe() const override \{                return "{}not "{} + m\+\_\+underlying\+Matcher.\+to\+String();            \}        \};    \}     template $<$typename T$>$    Detail\+::\+Match\+All\+Of$<$T$>$ operator\&\& (Matcher\+Base$<$T$>$ const\& lhs, Matcher\+Base$<$T$>$ const\& rhs) \{        return Detail\+::\+Match\+All\+Of$<$T$>$\{\} \&\& lhs \&\& rhs;    \}    template $<$typename T$>$    Detail\+::\+Match\+Any\+Of$<$T$>$ operator\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$T$>$ const\& lhs, Matcher\+Base$<$T$>$ const\& rhs) \{        return Detail\+::\+Match\+Any\+Of$<$T$>$\{\} \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} lhs \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} rhs;    \}    template $<$typename T$>$    Detail\+::\+Match\+Not\+Of$<$T$>$ operator! (Matcher\+Base$<$T$>$ const\& matcher) \{        return Detail\+::\+Match\+Not\+Of$<$T$>$\{ matcher \};    \}\} \} \#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CATCH\+\_\+\+CHECK\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}CATCH\+\_\+\+CHECK\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, arg )  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}CATCH\+\_\+\+REQUIRE\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, arg )\#elif defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                   (void)(0)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) (void)(0)  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                     (void)(0)  \#define CATCH\+\_\+\+CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher )   (void)(0)  \#define CATCH\+\_\+\+CHECK\+\_\+\+THAT( arg, matcher )                             (void)(0)  \#define CATCH\+\_\+\+REQUIRE\+\_\+\+THAT( arg, matcher )                           (void)(0)\#elif !defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& !defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}REQUIRE\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, matcher, expr )  \#define CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher ) \mbox{\hyperlink{catch__amalgamated_8hpp_a4296ab989dbc1f6c52c24d60012144d6}{INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+STR\+\_\+\+MATCHES}}( "{}CHECK\+\_\+\+THROWS\+\_\+\+WITH"{}, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) INTERNAL\+\_\+\+CATCH\+\_\+\+THROWS\+\_\+\+MATCHES( "{}CHECK\+\_\+\+THROWS\+\_\+\+MATCHES"{}, exception\+Type, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, matcher, expr )  \#define CHECK\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}CHECK\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8aa18c94bd60c5614e17a84c2ced3bbfd5}{Catch\+::\+Result\+Disposition\+::\+Continue\+On\+Failure}}, arg )  \#define REQUIRE\+\_\+\+THAT( arg, matcher ) INTERNAL\+\_\+\+CHECK\+\_\+\+THAT( "{}REQUIRE\+\_\+\+THAT"{}, matcher, \mbox{\hyperlink{struct_catch_1_1_result_disposition_a3396cad6e2259af326b3aae93e23e9d8af3bd52347ed6f8796e8ce2f77bb39ea5}{Catch\+::\+Result\+Disposition\+::\+Normal}}, arg )\#elif !defined(CATCH\+\_\+\+CONFIG\+\_\+\+PREFIX\+\_\+\+ALL) \&\& defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                   (void)(0)  \#define REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher ) (void)(0)  \#define CHECK\+\_\+\+THROWS\+\_\+\+WITH( expr, matcher )                     (void)(0)  \#define CHECK\+\_\+\+THROWS\+\_\+\+MATCHES( expr, exception\+Type, matcher )   (void)(0)  \#define CHECK\+\_\+\+THAT( arg, matcher )                             (void)(0)  \#define REQUIRE\+\_\+\+THAT( arg, matcher )                           (void)(0)\#endif \#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINER\+\_\+\+PROPERTIES\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINER\+\_\+\+PROPERTIES\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+TEMPLATED\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+TEMPLATED\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$array$>$\#include $<$algorithm$>$\#include $<$string$>$\#include $<$type\+\_\+traits$>$namespace Catch \{namespace Matchers \{    class Matcher\+Generic\+Base \+: public Matcher\+Untyped\+Base \{    public\+:        Matcher\+Generic\+Base() = default;        \texorpdfstring{$\sim$}{\string~}Matcher\+Generic\+Base() override;         Matcher\+Generic\+Base(Matcher\+Generic\+Base const\&) = default;        Matcher\+Generic\+Base(Matcher\+Generic\+Base\&\&) = default;        Matcher\+Generic\+Base\& operator=(Matcher\+Generic\+Base const\&) = delete;        Matcher\+Generic\+Base\& operator=(Matcher\+Generic\+Base\&\&) = delete;    \};    namespace Detail \{        template$<$std\+::size\+\_\+t N, std\+::size\+\_\+t M$>$        std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N + M$>$ array\+\_\+cat(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ \&\& lhs, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, M$>$ \&\& rhs) \{            std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N + M$>$ arr\{\};            std\+::copy\+\_\+n(lhs.\+begin(), N, arr.\+begin());            std\+::copy\+\_\+n(rhs.\+begin(), M, arr.\+begin() + N);            return arr;        \}        template$<$std\+::size\+\_\+t N$>$        std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N+1$>$ array\+\_\+cat(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ \&\& lhs, void const\texorpdfstring{$\ast$}{*} rhs) \{            std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N+1$>$ arr\{\};            std\+::copy\+\_\+n(lhs.\+begin(), N, arr.\+begin());            arr\mbox{[}N\mbox{]} = rhs;            return arr;        \}        template$<$std\+::size\+\_\+t N$>$        std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N+1$>$ array\+\_\+cat(void const\texorpdfstring{$\ast$}{*} lhs, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ \&\& rhs) \{            std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N + 1$>$ arr\{ \{lhs\} \};            std\+::copy\+\_\+n(rhs.\+begin(), N, arr.\+begin() + 1);            return arr;        \}        template$<$typename T$>$        using is\+\_\+generic\+\_\+matcher = std\+::is\+\_\+base\+\_\+of$<$            Catch\+::\+Matchers\+::\+Matcher\+Generic\+Base,            std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$T$>$$>$        $>$;        template$<$typename... Ts$>$        using are\+\_\+generic\+\_\+matchers = \mbox{\hyperlink{struct_catch_1_1_detail_1_1conjunction}{Catch\+::\+Detail\+::conjunction}}$<$is\+\_\+generic\+\_\+matcher$<$Ts$>$...$>$;        template$<$typename T$>$        using is\+\_\+matcher = std\+::is\+\_\+base\+\_\+of$<$            Catch\+::\+Matchers\+::\+Matcher\+Untyped\+Base,            std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$T$>$$>$        $>$;        template$<$std\+::size\+\_\+t N, typename Arg$>$        bool match\+\_\+all\+\_\+of(Arg\&\&, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\&, std\+::index\+\_\+sequence$<$$>$) \{            return true;        \}        template$<$typename T, typename... Matcher\+Ts, std\+::size\+\_\+t N, typename Arg, std\+::size\+\_\+t Idx, std\+::size\+\_\+t... Indices$>$        bool match\+\_\+all\+\_\+of(Arg\&\& arg, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\& matchers, std\+::index\+\_\+sequence$<$Idx, Indices...$>$) \{            return static\+\_\+cast$<$T const\texorpdfstring{$\ast$}{*}$>$(matchers\mbox{[}Idx\mbox{]})-\/$>$match(arg) \&\& match\+\_\+all\+\_\+of$<$Matcher\+Ts...$>$(arg, matchers, std\+::index\+\_\+sequence$<$Indices...$>$\{\});        \}        template$<$std\+::size\+\_\+t N, typename Arg$>$        bool match\+\_\+any\+\_\+of(Arg\&\&, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\&, std\+::index\+\_\+sequence$<$$>$) \{            return false;        \}        template$<$typename T, typename... Matcher\+Ts, std\+::size\+\_\+t N, typename Arg, std\+::size\+\_\+t Idx, std\+::size\+\_\+t... Indices$>$        bool match\+\_\+any\+\_\+of(Arg\&\& arg, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, N$>$ const\& matchers, std\+::index\+\_\+sequence$<$Idx, Indices...$>$) \{            return static\+\_\+cast$<$T const\texorpdfstring{$\ast$}{*}$>$(matchers\mbox{[}Idx\mbox{]})-\/$>$match(arg) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} match\+\_\+any\+\_\+of$<$Matcher\+Ts...$>$(arg, matchers, std\+::index\+\_\+sequence$<$Indices...$>$\{\});        \}        std\+::string describe\+\_\+multi\+\_\+matcher(String\+Ref combine, std\+::string const\texorpdfstring{$\ast$}{*} descriptions\+\_\+begin, std\+::string const\texorpdfstring{$\ast$}{*} descriptions\+\_\+end);        template$<$typename... Matcher\+Ts, std\+::size\+\_\+t... Idx$>$        std\+::string describe\+\_\+multi\+\_\+matcher(String\+Ref combine, std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...(Matcher\+Ts)$>$ const\& matchers, std\+::index\+\_\+sequence$<$Idx...$>$) \{            std\+::array$<$std\+::string, sizeof...(Matcher\+Ts)$>$ descriptions \{\{                static\+\_\+cast$<$Matcher\+Ts const\texorpdfstring{$\ast$}{*}$>$(matchers\mbox{[}Idx\mbox{]})-\/$>$to\+String()...            \}\};            return describe\+\_\+multi\+\_\+matcher(combine, \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{descriptions.\+data}}(), \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{descriptions.\+data}}() + descriptions.\+size());        \}        template$<$typename... Matcher\+Ts$>$        class Match\+All\+Of\+Generic final \+: public Matcher\+Generic\+Base \{        public\+:            Match\+All\+Of\+Generic(Match\+All\+Of\+Generic const\&) = delete;            Match\+All\+Of\+Generic\& operator=(Match\+All\+Of\+Generic const\&) = delete;            Match\+All\+Of\+Generic(Match\+All\+Of\+Generic\&\&) = default;            Match\+All\+Of\+Generic\& operator=(Match\+All\+Of\+Generic\&\&) = default;            Match\+All\+Of\+Generic(Matcher\+Ts const\&... matchers) \+: m\+\_\+matchers\{ \{std\+::addressof(matchers)...\} \} \{\}            explicit Match\+All\+Of\+Generic(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...(Matcher\+Ts)$>$ matchers) \+: m\+\_\+matchers\{matchers\} \{\}            template$<$typename Arg$>$            bool match(Arg\&\& arg) const \{                return match\+\_\+all\+\_\+of$<$Matcher\+Ts...$>$(arg, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}            std\+::string describe() const override \{                return describe\+\_\+multi\+\_\+matcher$<$Matcher\+Ts...$>$("{} and "{}\+\_\+sr, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}                                                std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...( Matcher\+Ts )$>$ m\+\_\+matchers;                        template$<$typename... Matchers\+RHS$>$            friend            Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$ operator \&\& (                    Match\+All\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Match\+All\+Of\+Generic$<$Matchers\+RHS...$>$\&\& rhs) \{                return Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}                        template$<$typename Matcher\+RHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$$>$ operator \&\& (                    Match\+All\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Matcher\+RHS const\& rhs) \{                return Match\+All\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(\&rhs))\};            \}                        template$<$typename Matcher\+LHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$$>$ operator \&\& (                    Matcher\+LHS const\& lhs,                    Match\+All\+Of\+Generic$<$Matcher\+Ts...$>$\&\& rhs) \{                return Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$\{array\+\_\+cat(static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(std\+::addressof(lhs)), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}        \};        template$<$typename... Matcher\+Ts$>$        class Match\+Any\+Of\+Generic final \+: public Matcher\+Generic\+Base \{        public\+:            Match\+Any\+Of\+Generic(Match\+Any\+Of\+Generic const\&) = delete;            Match\+Any\+Of\+Generic\& operator=(Match\+Any\+Of\+Generic const\&) = delete;            Match\+Any\+Of\+Generic(Match\+Any\+Of\+Generic\&\&) = default;            Match\+Any\+Of\+Generic\& operator=(Match\+Any\+Of\+Generic\&\&) = default;            Match\+Any\+Of\+Generic(Matcher\+Ts const\&... matchers) \+: m\+\_\+matchers\{ \{std\+::addressof(matchers)...\} \} \{\}            explicit Match\+Any\+Of\+Generic(std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...(Matcher\+Ts)$>$ matchers) \+: m\+\_\+matchers\{matchers\} \{\}            template$<$typename Arg$>$            bool match(Arg\&\& arg) const \{                return match\+\_\+any\+\_\+of$<$Matcher\+Ts...$>$(arg, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}            std\+::string describe() const override \{                return describe\+\_\+multi\+\_\+matcher$<$Matcher\+Ts...$>$("{} or "{}\+\_\+sr, m\+\_\+matchers, std\+::index\+\_\+sequence\+\_\+for$<$Matcher\+Ts...$>$\{\});            \}                                                std\+::array$<$void const\texorpdfstring{$\ast$}{*}, sizeof...( Matcher\+Ts )$>$ m\+\_\+matchers;                        template$<$typename... Matchers\+RHS$>$            friend Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$ operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (                    Match\+Any\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Match\+Any\+Of\+Generic$<$Matchers\+RHS...$>$\&\& rhs) \{                return Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matchers\+RHS...$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}                        template$<$typename Matcher\+RHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$$>$ operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (                    Match\+Any\+Of\+Generic$<$Matcher\+Ts...$>$\&\& lhs,                    Matcher\+RHS const\& rhs) \{                return Match\+Any\+Of\+Generic$<$Matcher\+Ts..., Matcher\+RHS$>$\{array\+\_\+cat(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(lhs.\+m\+\_\+matchers), static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(std\+::addressof(rhs)))\};            \}                        template$<$typename Matcher\+LHS$>$            friend std\+::enable\+\_\+if\+\_\+t$<$is\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$$>$ operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (                Matcher\+LHS const\& lhs,                Match\+Any\+Of\+Generic$<$Matcher\+Ts...$>$\&\& rhs) \{                return Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+Ts...$>$\{array\+\_\+cat(static\+\_\+cast$<$void const\texorpdfstring{$\ast$}{*}$>$(std\+::addressof(lhs)), \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(rhs.\+m\+\_\+matchers))\};            \}        \};        template$<$typename MatcherT$>$        class Match\+Not\+Of\+Generic final \+: public Matcher\+Generic\+Base \{            MatcherT const\& m\+\_\+matcher;        public\+:            Match\+Not\+Of\+Generic(Match\+Not\+Of\+Generic const\&) = delete;            Match\+Not\+Of\+Generic\& operator=(Match\+Not\+Of\+Generic const\&) = delete;            Match\+Not\+Of\+Generic(Match\+Not\+Of\+Generic\&\&) = default;            Match\+Not\+Of\+Generic\& operator=(Match\+Not\+Of\+Generic\&\&) = default;            explicit Match\+Not\+Of\+Generic(MatcherT const\& matcher) \+: m\+\_\+matcher\{matcher\} \{\}            template$<$typename Arg$>$            bool match(Arg\&\& arg) const \{                return !m\+\_\+matcher.\+match(arg);            \}            std\+::string describe() const override \{                return "{}not "{} + m\+\_\+matcher.\+to\+String();            \}                        friend MatcherT const\& operator ! (Match\+Not\+Of\+Generic$<$MatcherT$>$ const\& matcher) \{                return matcher.\+m\+\_\+matcher;            \}        \};    \}         template$<$typename Matcher\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::are\+\_\+generic\+\_\+matchers$<$Matcher\+LHS, Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+RHS$>$$>$        operator \&\& (Matcher\+LHS const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Matcher\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::are\+\_\+generic\+\_\+matchers$<$Matcher\+LHS, Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+RHS$>$$>$        operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+LHS const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}        template$<$typename MatcherT$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$MatcherT$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Not\+Of\+Generic$<$MatcherT$>$$>$        operator ! (MatcherT const\& matcher) \{        return Detail\+::\+Match\+Not\+Of\+Generic$<$MatcherT$>$\{matcher\};    \}        template$<$typename Matcher\+LHS, typename Arg\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+All\+Of\+Generic$<$Matcher\+LHS, Matcher\+Base$<$Arg\+RHS$>$$>$$>$        operator \&\& (Matcher\+LHS const\& lhs, Matcher\+Base$<$Arg\+RHS$>$ const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Arg\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+All\+Of\+Generic$<$Matcher\+Base$<$Arg\+LHS$>$, Matcher\+RHS$>$$>$        operator \&\& (Matcher\+Base$<$Arg\+LHS$>$ const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Matcher\+LHS, typename Arg\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+LHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Any\+Of\+Generic$<$Matcher\+LHS, Matcher\+Base$<$Arg\+RHS$>$$>$$>$        operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+LHS const\& lhs, Matcher\+Base$<$Arg\+RHS$>$ const\& rhs) \{        return \{ lhs, rhs \};    \}    template$<$typename Arg\+LHS, typename Matcher\+RHS$>$    std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+generic\+\_\+matcher$<$Matcher\+RHS$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, Detail\+::\+Match\+Any\+Of\+Generic$<$Matcher\+Base$<$Arg\+LHS$>$, Matcher\+RHS$>$$>$        operator \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (Matcher\+Base$<$Arg\+LHS$>$ const\& lhs, Matcher\+RHS const\& rhs) \{        return \{ lhs, rhs \};    \}\} \} \#endif namespace Catch \{    namespace Matchers \{        class Is\+Empty\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)                using Catch\+::\+Detail\+::empty;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                using std\+::empty;\#endif                return empty(rng);            \}            std\+::string describe() const override;        \};        class Has\+Size\+Matcher final \+: public Matcher\+Generic\+Base \{            std\+::size\+\_\+t m\+\_\+target\+\_\+size;        public\+:            explicit Has\+Size\+Matcher(std\+::size\+\_\+t target\+\_\+size)\+:                m\+\_\+target\+\_\+size(target\+\_\+size)            \{\}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)                using Catch\+::\+Detail\+::size;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                using std\+::size;\#endif                return size(rng) == m\+\_\+target\+\_\+size;            \}            std\+::string describe() const override;        \};        template $<$typename Matcher$>$        class Size\+Matches\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            explicit Size\+Matches\+Matcher(Matcher m)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(m))            \{\}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+POLYFILL\+\_\+\+NONMEMBER\+\_\+\+CONTAINER\+\_\+\+ACCESS)                using Catch\+::\+Detail\+::size;\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}}                using std\+::size;\#endif                return m\+\_\+matcher.\+match(size(rng));            \}            std\+::string describe() const override \{                return "{}size matches "{} + m\+\_\+matcher.\+describe();            \}        \};                Is\+Empty\+Matcher Is\+Empty();                Has\+Size\+Matcher Size\+Is(std\+::size\+\_\+t sz);        template $<$typename Matcher$>$        std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+matcher$<$Matcher$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        Size\+Matches\+Matcher$<$Matcher$>$$>$ Size\+Is(Matcher\&\& m) \{            return Size\+Matches\+Matcher$<$Matcher$>$\{\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(m)\};        \}    \} \} \#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+CONTAINS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$\#include $<$functional$>$namespace Catch \{    namespace Matchers \{                template $<$typename T, typename Equality$>$        class Contains\+Element\+Matcher final \+: public Matcher\+Generic\+Base \{            T m\+\_\+desired;            Equality m\+\_\+eq;        public\+:            template $<$typename T2, typename Equality2$>$            Contains\+Element\+Matcher(T2\&\& target, Equality2\&\& predicate)\+:                m\+\_\+desired(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(target)),                m\+\_\+eq(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(predicate))            \{\}            std\+::string describe() const override \{                return "{}contains element "{} + Catch\+::\+Detail\+::stringify(m\+\_\+desired);            \}            template $<$typename Range\+Like$>$            bool match( Range\+Like\&\& rng ) const \{                for ( auto\&\& elem \+: rng ) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+eq( elem, m\+\_\+desired ) ) \{ return true; \}                \}                return false;            \}        \};                template $<$typename Matcher$>$        class Contains\+Matcher\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:                                                Contains\+Matcher\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+matcher.\+match(elem)) \{                        return true;                    \}                \}                return false;            \}            std\+::string describe() const override \{                return "{}contains element matching "{} + m\+\_\+matcher.\+describe();            \}        \};                template $<$typename T$>$        std\+::enable\+\_\+if\+\_\+t$<$!Detail\+::is\+\_\+matcher$<$T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        Contains\+Element\+Matcher$<$T, std\+::equal\+\_\+to$<$$>$$>$$>$ Contains(T\&\& elem) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(elem), std\+::equal\+\_\+to$<$$>$\{\} \};        \}                template $<$typename Matcher$>$        std\+::enable\+\_\+if\+\_\+t$<$Detail\+::is\+\_\+matcher$<$Matcher$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},        Contains\+Matcher\+Matcher$<$Matcher$>$$>$ Contains(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}                template $<$typename T, typename Equality$>$        Contains\+Element\+Matcher$<$T, Equality$>$ Contains(T\&\& elem, Equality\&\& eq) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(elem), \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(eq) \};        \}    \}\}\#endif \#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+EXCEPTION\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+EXCEPTION\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{namespace Matchers \{class Exception\+Message\+Matcher final \+: public Matcher\+Base$<$std\+::exception$>$ \{    std\+::string m\+\_\+message;public\+:    Exception\+Message\+Matcher(std\+::string const\& message)\+:        m\+\_\+message(message)    \{\}    bool match(std\+::exception const\& ex) const override;    std\+::string describe() const override;\};Exception\+Message\+Matcher Message(std\+::string const\& message);template $<$typename String\+Matcher\+Type$>$class Exception\+Message\+Matches\+Matcher final    \+: public Matcher\+Base$<$std\+::exception$>$ \{    String\+Matcher\+Type m\+\_\+matcher;public\+:    Exception\+Message\+Matches\+Matcher( String\+Matcher\+Type matcher )\+:        m\+\_\+matcher( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}( matcher ) ) \{\}    bool match( std\+::exception const\& ex ) const override \{        return m\+\_\+matcher.\+match( ex.\+what() );    \}    std\+::string describe() const override \{        return "{} matches \textbackslash{}"{}"{} + m\+\_\+matcher.\+describe() + \textquotesingle{}"{}\textquotesingle{};    \}\};template $<$typename String\+Matcher\+Type$>$Exception\+Message\+Matches\+Matcher$<$String\+Matcher\+Type$>$Message\+Matches( String\+Matcher\+Type\&\& matcher ) \{    return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( matcher ) \};\}\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+EXCEPTION\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{namespace Matchers \{    namespace Detail \{        enum class Floating\+Point\+Kind \+: uint8\+\_\+t;    \}    class  Within\+Abs\+Matcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Within\+Abs\+Matcher(double target, double margin);        bool match(double const\& matchee) const override;        std\+::string describe() const override;    private\+:        double m\+\_\+target;        double m\+\_\+margin;    \};        Within\+Abs\+Matcher Within\+Abs( double target, double margin );    class Within\+Ulps\+Matcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Within\+Ulps\+Matcher( double target,                           uint64\+\_\+t ulps,                           Detail\+::\+Floating\+Point\+Kind base\+Type );        bool match(double const\& matchee) const override;        std\+::string describe() const override;    private\+:        double m\+\_\+target;        uint64\+\_\+t m\+\_\+ulps;        Detail\+::\+Floating\+Point\+Kind m\+\_\+type;    \};        Within\+Ulps\+Matcher Within\+ULP(double target, uint64\+\_\+t max\+Ulp\+Diff);        Within\+Ulps\+Matcher Within\+ULP(float target, uint64\+\_\+t max\+Ulp\+Diff);    // Given IEEE-\/754 format for floats and doubles, we can assume    // that float -\/$>$ double promotion is lossless. Given this, we can    // assume that \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} we do the standard relative comparison of    // \texorpdfstring{$\vert$}{|}lhs -\/ rhs\texorpdfstring{$\vert$}{|} $<$= epsilon \texorpdfstring{$\ast$}{*} max(fabs(lhs), fabs(rhs)), then we get    // the same \mbox{\hyperlink{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}{result}} \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} we do this for floats, as \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} we do this for    // doubles that were promoted from floats.    class Within\+Rel\+Matcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Within\+Rel\+Matcher( double target, double epsilon );        bool match(double const\& matchee) const override;        std\+::string describe() const override;    private\+:        double m\+\_\+target;        double m\+\_\+epsilon;    \};        Within\+Rel\+Matcher Within\+Rel(double target, double eps);        Within\+Rel\+Matcher Within\+Rel(double target);        Within\+Rel\+Matcher Within\+Rel(float target, float eps);        Within\+Rel\+Matcher Within\+Rel(float target);    class Is\+Na\+NMatcher final \+: public Matcher\+Base$<$double$>$ \{    public\+:        Is\+Na\+NMatcher() = default;        bool match( double const\& matchee ) const override;        std\+::string describe() const override;    \};    Is\+Na\+NMatcher Is\+NaN();\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+FLOATING\+\_\+\+POINT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+PREDICATE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+PREDICATE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{namespace Matchers \{namespace Detail \{    std\+::string finalize\+Description(const std\+::string\& desc);\} // namespace Detailtemplate $<$typename T, typename Predicate$>$class Predicate\+Matcher final \+: public Matcher\+Base$<$T$>$ \{    Predicate m\+\_\+predicate;    std\+::string m\+\_\+description;public\+:    Predicate\+Matcher(Predicate\&\& elem, std\+::string const\& descr)        \+:m\+\_\+predicate(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(elem)),        m\+\_\+description(Detail\+::finalize\+Description(descr))    \{\}    bool match( T const\& item ) const override \{        return m\+\_\+predicate(item);    \}    std\+::string describe() const override \{        return m\+\_\+description;    \}\};    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Creates a matcher that calls delegates \`{}match\`{} to the provided predicate.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} The user has to explicitly specify the argument type to the matcher     \texorpdfstring{$\ast$}{*}/    template$<$typename T, typename Pred$>$    Predicate\+Matcher$<$T, Pred$>$ Predicate(Pred\&\& predicate, std\+::string const\& description = "{}"{}) \{        static\+\_\+assert(is\+\_\+callable$<$Pred(T)$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Predicate not callable with argument T"{});        static\+\_\+assert(std\+::is\+\_\+same$<$bool, Function\+Return\+Type$<$Pred, T$>$$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}, "{}Predicate does not return bool"{});        return Predicate\+Matcher$<$T, Pred$>$(\mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(predicate), description);    \}\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+PREDICATE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+QUANTIFIERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+QUANTIFIERS\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    namespace Matchers \{        // Matcher for checking that all elements in range matches a given matcher.        template $<$typename Matcher$>$        class All\+Match\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            All\+Match\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            std\+::string describe() const override \{                return "{}all match "{} + m\+\_\+matcher.\+describe();            \}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!m\+\_\+matcher.\+match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range matches a given matcher.        template $<$typename Matcher$>$        class None\+Match\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            None\+Match\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            std\+::string describe() const override \{                return "{}none match "{} + m\+\_\+matcher.\+describe();            \}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+matcher.\+match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that at least one element in range matches a given matcher.        template $<$typename Matcher$>$        class Any\+Match\+Matcher final \+: public Matcher\+Generic\+Base \{            Matcher m\+\_\+matcher;        public\+:            Any\+Match\+Matcher(Matcher matcher)\+:                m\+\_\+matcher(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(matcher))            \{\}            std\+::string describe() const override \{                return "{}any match "{} + m\+\_\+matcher.\+describe();            \}            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+matcher.\+match(elem)) \{                        return true;                    \}                \}                return false;            \}        \};        // Matcher for checking that all elements in range are true.        class All\+True\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            std\+::string describe() const override;            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range is true.        class None\+True\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            std\+::string describe() const override;            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that any element in range is true.        class Any\+True\+Matcher final \+: public Matcher\+Generic\+Base \{        public\+:            std\+::string describe() const override;            template $<$typename Range\+Like$>$            bool match(Range\+Like\&\& rng) const \{                for (auto\&\& elem \+: rng) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (elem) \{                        return true;                    \}                \}                return false;            \}        \};        // Creates a matcher that checks whether all elements in a range match a matcher        template $<$typename Matcher$>$        All\+Match\+Matcher$<$Matcher$>$ All\+Match(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}        // Creates a matcher that checks whether no element in a range matches a matcher.        template $<$typename Matcher$>$        None\+Match\+Matcher$<$Matcher$>$ None\+Match(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}        // Creates a matcher that checks whether any element in a range matches a matcher.        template $<$typename Matcher$>$        Any\+Match\+Matcher$<$Matcher$>$ Any\+Match(Matcher\&\& matcher) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}(matcher) \};        \}        // Creates a matcher that checks whether all elements in a range are true        All\+True\+Matcher All\+True();        // Creates a matcher that checks whether no element in a range is true        None\+True\+Matcher None\+True();        // Creates a matcher that checks whether any element in a range is true        Any\+True\+Matcher Any\+True();    \}\}\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+QUANTIFIERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+RANGE\+\_\+\+EQUALS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+RANGE\+\_\+\+EQUALS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$\#include $<$utility$>$namespace Catch \{    namespace Matchers \{        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Matcher for checking that an element contains the same         \texorpdfstring{$\ast$}{*} elements in the same order         \texorpdfstring{$\ast$}{*}/        template $<$typename Target\+Range\+Like, typename Equality$>$        class Range\+Equals\+Matcher final \+: public Matcher\+Generic\+Base \{            Target\+Range\+Like m\+\_\+desired;            Equality m\+\_\+predicate;        public\+:            template $<$typename Target\+Range\+Like2, typename Equality2$>$            Range\+Equals\+Matcher( Target\+Range\+Like2\&\& range,                                Equality2\&\& predicate )\+:                m\+\_\+desired( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ) ),                m\+\_\+predicate( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) ) \{\}            template $<$typename Range\+Like$>$            bool match( Range\+Like\&\& rng ) const \{                auto rng\+\_\+start = begin( rng );                const auto rng\+\_\+end = end( rng );                auto target\+\_\+start = begin( m\+\_\+desired );                const auto target\+\_\+end = end( m\+\_\+desired );                while (rng\+\_\+start != rng\+\_\+end \&\& target\+\_\+start != target\+\_\+end) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!m\+\_\+predicate(\texorpdfstring{$\ast$}{*}rng\+\_\+start, \texorpdfstring{$\ast$}{*}target\+\_\+start)) \{                        return false;                    \}                    ++rng\+\_\+start;                    ++target\+\_\+start;                \}                return rng\+\_\+start == rng\+\_\+end \&\& target\+\_\+start == target\+\_\+end;            \}            std\+::string describe() const override \{                return "{}elements are "{} + Catch\+::\+Detail\+::stringify( m\+\_\+desired );            \}        \};        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Matcher for checking that an element contains the same         \texorpdfstring{$\ast$}{*} elements (but not necessarily in the same order)         \texorpdfstring{$\ast$}{*}/        template $<$typename Target\+Range\+Like, typename Equality$>$        class Unordered\+Range\+Equals\+Matcher final \+: public Matcher\+Generic\+Base \{            Target\+Range\+Like m\+\_\+desired;            Equality m\+\_\+predicate;        public\+:            template $<$typename Target\+Range\+Like2, typename Equality2$>$            Unordered\+Range\+Equals\+Matcher( Target\+Range\+Like2\&\& range,                                         Equality2\&\& predicate )\+:                m\+\_\+desired( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ) ),                m\+\_\+predicate( \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) ) \{\}            template $<$typename Range\+Like$>$            bool match( Range\+Like\&\& rng ) const \{                using std\+::begin;                using std\+::end;                return \mbox{\hyperlink{class_catch_1_1_detail_1_1unique__ptr}{Catch\+::\+Detail\+::is\+\_\+permutation}}( begin( m\+\_\+desired ),                                                      end( m\+\_\+desired ),                                                      begin( rng ),                                                      end( rng ),                                                      m\+\_\+predicate );            \}            std\+::string describe() const override \{                return "{}unordered elements are "{} +                       \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+desired );            \}        \};        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses \`{}std\+::equal\+\_\+to\`{} to do the comparison         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like$>$        std\+::enable\+\_\+if\+\_\+t$<$!Detail\+::is\+\_\+matcher$<$Range\+Like$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},                         Range\+Equals\+Matcher$<$Range\+Like, std\+::equal\+\_\+to$<$$>$$>$$>$        Range\+Equals( Range\+Like\&\& range ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), std\+::equal\+\_\+to$<$$>$\{\} \};        \}        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses to provided predicate \`{}predicate\`{} to do the comparisons         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like, typename Equality$>$        Range\+Equals\+Matcher$<$Range\+Like, Equality$>$        Range\+Equals( Range\+Like\&\& range, Equality\&\& predicate ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) \};        \}        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range, in some permutation         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses \`{}std\+::equal\+\_\+to\`{} to do the comparison         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like$>$        std\+::enable\+\_\+if\+\_\+t$<$            !Detail\+::is\+\_\+matcher$<$Range\+Like$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}},            Unordered\+Range\+Equals\+Matcher$<$Range\+Like, std\+::equal\+\_\+to$<$$>$$>$$>$        Unordered\+Range\+Equals( Range\+Like\&\& range ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), std\+::equal\+\_\+to$<$$>$\{\} \};        \}        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Creates a matcher that checks \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements in a range are equal         \texorpdfstring{$\ast$}{*} to all elements in another range, in some permutation.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Uses to provided predicate \`{}predicate\`{} to do the comparisons         \texorpdfstring{$\ast$}{*}/        template $<$typename Range\+Like, typename Equality$>$        Unordered\+Range\+Equals\+Matcher$<$Range\+Like, Equality$>$        Unordered\+Range\+Equals( Range\+Like\&\& range, Equality\&\& predicate ) \{            return \{ \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( range ), \mbox{\hyperlink{catch__amalgamated_8hpp_acedf14a4dca7fdf78bd48b59bc4d954a}{CATCH\+\_\+\+FORWARD}}( predicate ) \};        \}    \} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+RANGE\+\_\+\+EQUALS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{namespace Matchers \{    struct Cased\+String \{        Cased\+String( std\+::string const\& str, Case\+Sensitive case\+Sensitivity );        std\+::string adjust\+String( std\+::string const\& str ) const;        String\+Ref case\+Sensitivity\+Suffix() const;        Case\+Sensitive m\+\_\+case\+Sensitivity;        std\+::string m\+\_\+str;    \};    class String\+Matcher\+Base \+: public Matcher\+Base$<$std\+::string$>$ \{    protected\+:        Cased\+String m\+\_\+comparator;        String\+Ref m\+\_\+operation;    public\+:        String\+Matcher\+Base( String\+Ref operation,                           Cased\+String const\& comparator );        std\+::string describe() const override;    \};    class String\+Equals\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        String\+Equals\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class String\+Contains\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        String\+Contains\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class Starts\+With\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        Starts\+With\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class Ends\+With\+Matcher final \+: public String\+Matcher\+Base \{    public\+:        Ends\+With\+Matcher( Cased\+String const\& comparator );        bool match( std\+::string const\& source ) const override;    \};    class Regex\+Matcher final \+: public Matcher\+Base$<$std\+::string$>$ \{        std\+::string m\+\_\+regex;        Case\+Sensitive m\+\_\+case\+Sensitivity;    public\+:        Regex\+Matcher( std\+::string regex, Case\+Sensitive case\+Sensitivity );        bool match( std\+::string const\& matchee ) const override;        std\+::string describe() const override;    \};        String\+Equals\+Matcher Equals( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        String\+Contains\+Matcher Contains\+Substring( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        Ends\+With\+Matcher Ends\+With( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        Starts\+With\+Matcher Starts\+With( std\+::string const\& str, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );        Regex\+Matcher Matches( std\+::string const\& regex, Case\+Sensitive case\+Sensitivity = Case\+Sensitive\+::\+Yes );\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+STRING\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+MATCHERS\+\_\+\+VECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+MATCHERS\+\_\+\+VECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$algorithm$>$namespace Catch \{namespace Matchers \{    template$<$typename T, typename Alloc$>$    class Vector\+Contains\+Element\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc$>$$>$ \{        T const\& m\+\_\+comparator;    public\+:        Vector\+Contains\+Element\+Matcher(T const\& comparator)\+:            m\+\_\+comparator(comparator)        \{\}        bool match(std\+::vector$<$T, Alloc$>$ const\& v) const override \{            for (auto const\& el \+: v) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (el == m\+\_\+comparator) \{                    return true;                \}            \}            return false;        \}        std\+::string describe() const override \{            return "{}Contains\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Contains\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+comparator;    public\+:        Contains\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator)\+:            m\+\_\+comparator( comparator )        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& v) const override \{            // !TBD\+: see note in Equals\+Matcher            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+comparator.\+size() $>$ v.\+size())                return false;            for (auto const\& comparator \+: m\+\_\+comparator) \{                auto present = false;                for (const auto\& el \+: v) \{                    \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (el == comparator) \{                        present = true;                        break;                    \}                \}                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!present) \{                    return false;                \}            \}            return true;        \}        std\+::string describe() const override \{            return "{}Contains\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Equals\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+comparator;    public\+:        Equals\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator)\+:            m\+\_\+comparator( comparator )        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& v) const override \{            // !TBD\+: This currently works \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} all elements can be compared using !=            // -\/ a more general approach would be via a compare template that defaults            // to using !=. but could be specialised for, e.\+g. std\+::vector$<$T$>$ etc            // -\/ then just call that directly            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( m\+\_\+comparator.\+size() != v.\+size() ) \{ return false; \}            for ( std\+::size\+\_\+t i = 0; i $<$ v.\+size(); ++i ) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} ( !( m\+\_\+comparator\mbox{[}i\mbox{]} == v\mbox{[}i\mbox{]} ) ) \{ return false; \}            \}            return true;        \}        std\+::string describe() const override \{            return "{}Equals\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Approx\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+comparator;        mutable \mbox{\hyperlink{class_catch_1_1_approx}{Catch\+::\+Approx}} approx = \mbox{\hyperlink{class_catch_1_1_approx_aae48202f7bf38b6e3ebfaac7ef46b7af}{Catch\+::\+Approx\+::custom}}();    public\+:        Approx\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator)\+:            m\+\_\+comparator( comparator )        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& v) const override \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+comparator.\+size() != v.\+size())                return false;            for (std\+::size\+\_\+t i = 0; i $<$ v.\+size(); ++i)                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+comparator\mbox{[}i\mbox{]} != approx(v\mbox{[}i\mbox{]}))                    return false;            return true;        \}        std\+::string describe() const override \{            return "{}is approx\+: "{} + \+::\+Catch\+::\+Detail\+::stringify( m\+\_\+comparator );        \}        template $<$typename = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+constructible$<$double, T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Approx\+Matcher\& epsilon( T const\& new\+Epsilon ) \{            approx.\+epsilon(static\+\_\+cast$<$double$>$(new\+Epsilon));            return \texorpdfstring{$\ast$}{*}this;        \}        template $<$typename = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+constructible$<$double, T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Approx\+Matcher\& margin( T const\& new\+Margin ) \{            approx.\+margin(static\+\_\+cast$<$double$>$(new\+Margin));            return \texorpdfstring{$\ast$}{*}this;        \}        template $<$typename = std\+::enable\+\_\+if\+\_\+t$<$std\+::is\+\_\+constructible$<$double, T$>$\mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{\+::value}}$>$$>$        Approx\+Matcher\& scale( T const\& new\+Scale ) \{            approx.\+scale(static\+\_\+cast$<$double$>$(new\+Scale));            return \texorpdfstring{$\ast$}{*}this;        \}    \};    template$<$typename T, typename Alloc\+Comp, typename Alloc\+Match$>$    class Unordered\+Equals\+Matcher final \+: public Matcher\+Base$<$std\+::vector$<$T, Alloc\+Match$>$$>$ \{        std\+::vector$<$T, Alloc\+Comp$>$ const\& m\+\_\+target;    public\+:        Unordered\+Equals\+Matcher(std\+::vector$<$T, Alloc\+Comp$>$ const\& target)\+:            m\+\_\+target(target)        \{\}        bool match(std\+::vector$<$T, Alloc\+Match$>$ const\& vec) const override \{            \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (m\+\_\+target.\+size() != vec.\+size()) \{                return false;            \}            return std\+::is\+\_\+permutation(m\+\_\+target.\+begin(), m\+\_\+target.\+end(), vec.\+begin());        \}        std\+::string describe() const override \{            return "{}Unordered\+Equals\+: "{} + \+::\+Catch\+::\+Detail\+::stringify(m\+\_\+target);        \}    \};    // The following functions create the actual matcher objects.    // This allows the types to be inferred        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Contains\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Contains( std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator ) \{        return Contains\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(comparator);    \}        template$<$typename T, typename Alloc = std\+::allocator$<$T$>$$>$    Vector\+Contains\+Element\+Matcher$<$T, Alloc$>$ Vector\+Contains( T const\& comparator ) \{        return Vector\+Contains\+Element\+Matcher$<$T, Alloc$>$(comparator);    \}        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Equals( std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator ) \{        return Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(comparator);    \}        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Approx\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Approx( std\+::vector$<$T, Alloc\+Comp$>$ const\& comparator ) \{        return Approx\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(comparator);    \}        template$<$typename T, typename Alloc\+Comp = std\+::allocator$<$T$>$, typename Alloc\+Match = Alloc\+Comp$>$    Unordered\+Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$ Unordered\+Equals(std\+::vector$<$T, Alloc\+Comp$>$ const\& target) \{        return Unordered\+Equals\+Matcher$<$T, Alloc\+Comp, Alloc\+Match$>$(target);    \}\} // namespace Matchers\} // namespace Catch\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+VECTOR\+\_\+\+HPP\+\_\+\+INCLUDED\#endif // CATCH\+\_\+\+MATCHERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED/\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} \textbackslash{}file \texorpdfstring{$\ast$}{*} This is a convenience header for Catch2\textquotesingle{}s Reporter support. It includes \texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}all\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} of Catch2 headers related to reporters, including all reporters. \texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*} Generally the Catch2 users should use specific includes they need, \texorpdfstring{$\ast$}{*} but this header can be used instead for ease-\/of-\/experimentation, or \texorpdfstring{$\ast$}{*} just plain convenience, at the cost of (significantly) increased \texorpdfstring{$\ast$}{*} compilation times. \texorpdfstring{$\ast$}{*} \texorpdfstring{$\ast$}{*} When a new header (reporter) is added to either the \`{}reporter\`{} folder, \texorpdfstring{$\ast$}{*} or to the corresponding internal subfolder, it should be added here. \texorpdfstring{$\ast$}{*}/\#ifndef CATCH\+\_\+\+REPORTERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+AUTOMAKE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+AUTOMAKE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+STREAMING\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+STREAMING\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+COMMON\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+COMMON\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$map$>$\#include $<$string$>$namespace Catch \{    class Colour\+Impl;    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} This is the base class for all reporters.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} If are writing a reporter, you must derive from this type, or one     \texorpdfstring{$\ast$}{*} of the helper reporter bases that are derived from this type.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Reporter\+Base centralizes handling of various common tasks in reporters,     \texorpdfstring{$\ast$}{*} like storing the right \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} for the reporters to write to, and     \texorpdfstring{$\ast$}{*} providing the default implementation of the different listing events.     \texorpdfstring{$\ast$}{*}/    class Reporter\+Base \+: public IEvent\+Listener \{    protected\+:                Detail\+::unique\+\_\+ptr$<$IStream$>$ m\+\_\+wrapped\+\_\+stream;                        std\+::ostream\& m\+\_\+stream;                Detail\+::unique\+\_\+ptr$<$Colour\+Impl$>$ \mbox{\hyperlink{catch__amalgamated_8cpp_a4359931fc656b120d087d978af7a052c}{m\+\_\+colour}};                std\+::map$<$std\+::string, std\+::string$>$ m\+\_\+custom\+Options;    public\+:        Reporter\+Base( Reporter\+Config\&\& config );        \texorpdfstring{$\sim$}{\string~}Reporter\+Base() override; // = default;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of reporters.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Should look roughly like the reporter listing in v2 and earlier         \texorpdfstring{$\ast$}{*} versions of Catch2.         \texorpdfstring{$\ast$}{*}/        void list\+Reporters(            std\+::vector$<$Reporter\+Description$>$ const\& descriptions ) override;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of listeners         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Looks similarly to listing of reporters, but with listener type         \texorpdfstring{$\ast$}{*} instead of reporter name.         \texorpdfstring{$\ast$}{*}/        void list\+Listeners(            std\+::vector$<$Listener\+Description$>$ const\& descriptions ) override;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of tests.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Should look roughly like the test listing in v2 and earlier versions         \texorpdfstring{$\ast$}{*} of Catch2. Especially supports low-\/verbosity listing that mimics the         \texorpdfstring{$\ast$}{*} old \`{}-\/-\/list-\/test-\/names-\/only\`{} output.         \texorpdfstring{$\ast$}{*}/        void list\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& tests ) override;        /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Provides a simple default listing of tags.         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Should look roughly like the tag listing in v2 and earlier versions         \texorpdfstring{$\ast$}{*} of Catch2.         \texorpdfstring{$\ast$}{*}/        void list\+Tags( std\+::vector$<$Tag\+Info$>$ const\& tags ) override;    \};\} // namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+COMMON\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$vector$>$namespace Catch \{    class Streaming\+Reporter\+Base \+: public Reporter\+Base \{    public\+:        // GCC5 compat\+: we cannot use inherited constructor, because it        //              doesn\textquotesingle{}t implement backport of P0136        Streaming\+Reporter\+Base(Reporter\+Config\&\& \+\_\+config)\+:            Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config))        \{\}        \texorpdfstring{$\sim$}{\string~}Streaming\+Reporter\+Base() override;        void benchmark\+Preparing( String\+Ref ) override \{\}        void benchmark\+Starting( Benchmark\+Info const\& ) override \{\}        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& ) override \{\}        void benchmark\+Failed( String\+Ref ) override \{\}        void fatal\+Error\+Encountered( String\+Ref /\texorpdfstring{$\ast$}{*}error\texorpdfstring{$\ast$}{*}/ ) override \{\}        void no\+Matching\+Test\+Cases( String\+Ref /\texorpdfstring{$\ast$}{*}unmatched\+Spec\texorpdfstring{$\ast$}{*}/ ) override \{\}        void report\+Invalid\+Test\+Spec( String\+Ref /\texorpdfstring{$\ast$}{*}invalid\+Argument\texorpdfstring{$\ast$}{*}/ ) override \{\}        void test\+Run\+Starting( Test\+Run\+Info const\& \+\_\+test\+Run\+Info ) override;        void test\+Case\+Starting(Test\+Case\+Info const\& \+\_\+test\+Info) override  \{            current\+Test\+Case\+Info = \&\+\_\+test\+Info;        \}        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\&, uint64\+\_\+t ) override \{\}        void section\+Starting(Section\+Info const\& \+\_\+section\+Info) override \{            m\+\_\+section\+Stack.\+push\+\_\+back(\+\_\+section\+Info);        \}        void assertion\+Starting( Assertion\+Info const\& ) override \{\}        void assertion\+Ended( Assertion\+Stats const\& ) override \{\}        void section\+Ended(Section\+Stats const\& /\texorpdfstring{$\ast$}{*} \+\_\+section\+Stats \texorpdfstring{$\ast$}{*}/) override \{            m\+\_\+section\+Stack.\+pop\+\_\+back();        \}        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\&, uint64\+\_\+t ) override \{\}        void test\+Case\+Ended(Test\+Case\+Stats const\& /\texorpdfstring{$\ast$}{*} \+\_\+test\+Case\+Stats \texorpdfstring{$\ast$}{*}/) override \{            current\+Test\+Case\+Info = nullptr;        \}        void test\+Run\+Ended( Test\+Run\+Stats const\& /\texorpdfstring{$\ast$}{*} \+\_\+test\+Run\+Stats \texorpdfstring{$\ast$}{*}/ ) override;        void skip\+Test(Test\+Case\+Info const\&) override \{            // Don\textquotesingle{}t do anything with this by default.            // It can optionally be overridden in the derived class.        \}    protected\+:        Test\+Run\+Info current\+Test\+Run\+Info\{ "{}test run has not started yet"{}\+\_\+sr \};        Test\+Case\+Info const\texorpdfstring{$\ast$}{*} current\+Test\+Case\+Info = nullptr;                std\+::vector$<$Section\+Info$>$ m\+\_\+section\+Stack;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+STREAMING\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$namespace Catch \{    class Automake\+Reporter final \+: public Streaming\+Reporter\+Base \{    public\+:        // GCC5 compat\+: we cannot use inherited constructor, because it        //              doesn\textquotesingle{}t implement backport of P0136        Automake\+Reporter(Reporter\+Config\&\& \+\_\+config)\+:            Streaming\+Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config))        \{\}        \texorpdfstring{$\sim$}{\string~}Automake\+Reporter() override;        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results in the format of Automake .trs files"{}s;        \}        void test\+Case\+Ended(Test\+Case\+Stats const\& \+\_\+test\+Case\+Stats) override;        void skip\+Test(Test\+Case\+Info const\& test\+Info) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+AUTOMAKE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+COMPACT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+COMPACT\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Compact\+Reporter final \+: public Streaming\+Reporter\+Base \{    public\+:        using Streaming\+Reporter\+Base\+::\+Streaming\+Reporter\+Base;        \texorpdfstring{$\sim$}{\string~}Compact\+Reporter() override;        static std\+::string get\+Description();        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void test\+Run\+Starting( Test\+Run\+Info const\& \+\_\+test\+Info ) override;        void assertion\+Ended(Assertion\+Stats const\& \+\_\+assertion\+Stats) override;        void section\+Ended(Section\+Stats const\& \+\_\+section\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& \+\_\+test\+Run\+Stats) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+COMPACT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    // Fwd decls    class Table\+Printer;    class Console\+Reporter final \+: public Streaming\+Reporter\+Base \{        Detail\+::unique\+\_\+ptr$<$Table\+Printer$>$ m\+\_\+table\+Printer;    public\+:        Console\+Reporter(Reporter\+Config\&\& config);        \texorpdfstring{$\sim$}{\string~}Console\+Reporter() override;        static std\+::string get\+Description();        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void report\+Invalid\+Test\+Spec( String\+Ref arg ) override;        void assertion\+Starting(Assertion\+Info const\&) override;        void assertion\+Ended(Assertion\+Stats const\& \+\_\+assertion\+Stats) override;        void section\+Starting(Section\+Info const\& \+\_\+section\+Info) override;        void section\+Ended(Section\+Stats const\& \+\_\+section\+Stats) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting(Benchmark\+Info const\& info) override;        void benchmark\+Ended(Benchmark\+Stats$<$$>$ const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}}) override;        void benchmark\+Failed( String\+Ref error ) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& \+\_\+test\+Case\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& \+\_\+test\+Run\+Stats) override;        void test\+Run\+Starting(Test\+Run\+Info const\& \+\_\+test\+Run\+Info) override;    private\+:        void lazy\+Print();        void lazy\+Print\+Without\+Closing\+Benchmark\+Table();        void lazy\+Print\+Run\+Info();        void print\+Test\+Case\+And\+Section\+Header();        void print\+Closed\+Header(std\+::string const\& \+\_\+name);        void print\+Open\+Header(std\+::string const\& \+\_\+name);        // \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} string has a \+: in first line will set indent to follow it on        // subsequent lines        void print\+Header\+String(std\+::string const\& \+\_\+string, std\+::size\+\_\+t indent = 0);        void print\+Totals\+Divider(Totals const\& totals);        bool m\+\_\+header\+Printed = false;        bool m\+\_\+test\+Run\+Info\+Printed = false;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+CONSOLE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+CUMULATIVE\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+CUMULATIVE\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    namespace Detail \{                class Assertion\+Or\+Benchmark\+Result \{            // This should really be a variant, but this is much faster            // to write and the \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{data}} layout here is already terrible            // enough that we do not have to care about the object size.            Optional$<$Assertion\+Stats$>$ m\+\_\+assertion;            Optional$<$Benchmark\+Stats$<$$>$$>$ m\+\_\+benchmark;        public\+:            Assertion\+Or\+Benchmark\+Result(Assertion\+Stats const\& assertion);            Assertion\+Or\+Benchmark\+Result(Benchmark\+Stats$<$$>$ const\& benchmark);            bool is\+Assertion() const;            bool is\+Benchmark() const;            Assertion\+Stats const\& as\+Assertion() const;            Benchmark\+Stats$<$$>$ const\& as\+Benchmark() const;        \};    \}    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Utility base for reporters that need to handle all results at once     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} It stores tree of all test cases, sections and assertions, and after the     \texorpdfstring{$\ast$}{*} test run is finished, calls into \`{}test\+Run\+Ended\+Cumulative\`{} to pass the     \texorpdfstring{$\ast$}{*} control to the deriving class.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} If you are deriving from this class and override any testing related     \texorpdfstring{$\ast$}{*} member functions, you should first call into the base\textquotesingle{}s implementation to     \texorpdfstring{$\ast$}{*} avoid breaking the tree construction.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Due to the way this base functions, it has to expand assertions up-\/front,     \texorpdfstring{$\ast$}{*} even \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} they are later unused (e.\+g. because the deriving reporter does     \texorpdfstring{$\ast$}{*} not report successful assertions, or because the deriving reporter does     \texorpdfstring{$\ast$}{*} not use assertion expansion at all). Derived classes can use two     \texorpdfstring{$\ast$}{*} customization points, \`{}m\+\_\+should\+Store\+Succesful\+Assertions\`{} and     \texorpdfstring{$\ast$}{*} \`{}m\+\_\+should\+Store\+Failed\+Assertions\`{}, to disable the expansion and gain extra     \texorpdfstring{$\ast$}{*} performance. \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}Accessing the assertion expansions \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} it wasn\textquotesingle{}t stored is     \texorpdfstring{$\ast$}{*} UB.\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*}/    class Cumulative\+Reporter\+Base \+: public Reporter\+Base \{    public\+:        template$<$typename T, typename Child\+NodeT$>$        struct Node \{            explicit Node( T const\& \+\_\+value ) \+: \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}}( \+\_\+value ) \{\}            using Child\+Nodes = std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Child\+NodeT$>$$>$;            T \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}};            Child\+Nodes children;        \};        struct Section\+Node \{            explicit Section\+Node(Section\+Stats const\& \+\_\+stats) \+: \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}}(\+\_\+stats) \{\}            bool operator == (Section\+Node const\& other) const \{                return stats.\+section\+Info.\+line\+Info == other.\+stats.\+section\+Info.\+line\+Info;            \}            bool has\+Any\+Assertions() const;            Section\+Stats \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}};            std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Section\+Node$>$$>$ child\+Sections;            std\+::vector$<$Detail\+::\+Assertion\+Or\+Benchmark\+Result$>$ assertions\+And\+Benchmarks;            std\+::string std\+Out;            std\+::string std\+Err;        \};        using Test\+Case\+Node = Node$<$Test\+Case\+Stats, Section\+Node$>$;        using Test\+Run\+Node = Node$<$Test\+Run\+Stats, Test\+Case\+Node$>$;        // GCC5 compat\+: we cannot use inherited constructor, because it        //              doesn\textquotesingle{}t implement backport of P0136        Cumulative\+Reporter\+Base(Reporter\+Config\&\& \+\_\+config)\+:            Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config))        \{\}        \texorpdfstring{$\sim$}{\string~}Cumulative\+Reporter\+Base() override;        void benchmark\+Preparing( String\+Ref ) override \{\}        void benchmark\+Starting( Benchmark\+Info const\& ) override \{\}        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) override;        void benchmark\+Failed( String\+Ref ) override \{\}        void no\+Matching\+Test\+Cases( String\+Ref ) override \{\}        void report\+Invalid\+Test\+Spec( String\+Ref ) override \{\}        void fatal\+Error\+Encountered( String\+Ref /\texorpdfstring{$\ast$}{*}error\texorpdfstring{$\ast$}{*}/ ) override \{\}        void test\+Run\+Starting( Test\+Run\+Info const\& ) override \{\}        void test\+Case\+Starting( Test\+Case\+Info const\& ) override \{\}        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\&, uint64\+\_\+t ) override \{\}        void section\+Starting( Section\+Info const\& section\+Info ) override;        void assertion\+Starting( Assertion\+Info const\& ) override \{\}        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\&, uint64\+\_\+t ) override \{\}        void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) override;                virtual void test\+Run\+Ended\+Cumulative() = 0;        void skip\+Test(Test\+Case\+Info const\&) override \{\}    protected\+:                bool m\+\_\+should\+Store\+Succesful\+Assertions = true;                bool m\+\_\+should\+Store\+Failed\+Assertions = true;        // We need lazy construction here. We should probably refactor it        // later, after the events are redone.                Detail\+::unique\+\_\+ptr$<$Test\+Run\+Node$>$ m\+\_\+test\+Run;    private\+:        // Note\+: We rely on pointer identity being stable, which is why        //       we store pointers to the nodes rather than the values.        std\+::vector$<$Detail\+::unique\+\_\+ptr$<$Test\+Case\+Node$>$$>$ m\+\_\+test\+Cases;        // Root section of the \+\_\+current\+\_\+ test case        Detail\+::unique\+\_\+ptr$<$Section\+Node$>$ m\+\_\+root\+Section;        // Deepest section of the \+\_\+current\+\_\+ test case        Section\+Node\texorpdfstring{$\ast$}{*} m\+\_\+deepest\+Section = nullptr;        // Stack of \+\_\+active\+\_\+ sections in the \+\_\+current\+\_\+ test case        std\+::vector$<$Section\+Node\texorpdfstring{$\ast$}{*}$>$ m\+\_\+section\+Stack;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+CUMULATIVE\+\_\+\+BASE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+EVENT\+\_\+\+LISTENER\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+EVENT\+\_\+\+LISTENER\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Base class to simplify implementing listeners.     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Provides empty default implementation for all IEvent\+Listener member     \texorpdfstring{$\ast$}{*} functions, so that a listener implementation can pick which     \texorpdfstring{$\ast$}{*} member functions it actually cares about.     \texorpdfstring{$\ast$}{*}/    class Event\+Listener\+Base \+: public IEvent\+Listener \{    public\+:        using IEvent\+Listener\+::\+IEvent\+Listener;        void report\+Invalid\+Test\+Spec( String\+Ref unmatched\+Spec ) override;        void fatal\+Error\+Encountered( String\+Ref error ) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& benchmark\+Info ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) override;        void benchmark\+Failed( String\+Ref error ) override;        void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) override;        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        void list\+Reporters(            std\+::vector$<$Reporter\+Description$>$ const\& descriptions ) override;        void list\+Listeners(            std\+::vector$<$Listener\+Description$>$ const\& descriptions ) override;        void list\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& tests ) override;        void list\+Tags( std\+::vector$<$Tag\+Info$>$ const\& tag\+Infos ) override;        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) override;        void test\+Case\+Starting( Test\+Case\+Info const\& test\+Info ) override;        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\& test\+Info,                                      uint64\+\_\+t part\+Number ) override;        void section\+Starting( Section\+Info const\& section\+Info ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats,                                   uint64\+\_\+t part\+Number ) override;        void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) override;        void skip\+Test( Test\+Case\+Info const\& test\+Info ) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+EVENT\+\_\+\+LISTENER\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$iosfwd$>$\#include $<$string$>$\#include $<$vector$>$namespace Catch \{    class IConfig;    class Test\+Case\+Handle;    class Colour\+Impl;    // Returns double formatted as \%.\+3f (format expected on output)    std\+::string get\+Formatted\+Duration( double duration );        bool should\+Show\+Duration( IConfig const\& config, double duration );    std\+::string serialize\+Filters( std\+::vector$<$std\+::string$>$ const\& filters );    struct line\+Of\+Chars \{        char c;        constexpr line\+Of\+Chars( char c\+\_\+ )\+: c( c\+\_\+ ) \{\}        friend std\+::ostream\& operator$<$$<$( std\+::ostream\& out, line\+Of\+Chars \mbox{\hyperlink{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}{value}} );    \};    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists reporter descriptions to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly     \texorpdfstring{$\ast$}{*} format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used as the default listing implementation by the first party reporter     \texorpdfstring{$\ast$}{*} bases. The output should be backwards compatible with the output of     \texorpdfstring{$\ast$}{*} Catch2 v2 binaries.     \texorpdfstring{$\ast$}{*}/    void    default\+List\+Reporters( std\+::ostream\& out,                          std\+::vector$<$Reporter\+Description$>$ const\& descriptions,                          Verbosity verbosity );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists listeners descriptions to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly     \texorpdfstring{$\ast$}{*} format     \texorpdfstring{$\ast$}{*}/    void default\+List\+Listeners( std\+::ostream\& out,                               std\+::vector$<$Listener\+Description$>$ const\& descriptions );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists tag information to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used as the default listing implementation by the first party reporter     \texorpdfstring{$\ast$}{*} bases. The output should be backwards compatible with the output of     \texorpdfstring{$\ast$}{*} Catch2 v2 binaries.     \texorpdfstring{$\ast$}{*}/    void default\+List\+Tags( std\+::ostream\& out, std\+::vector$<$Tag\+Info$>$ const\& tags, bool is\+Filtered );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Lists test case information to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly     \texorpdfstring{$\ast$}{*} format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used as the default listing implementation by the first party reporter     \texorpdfstring{$\ast$}{*} bases. The output is backwards compatible with the output of Catch2     \texorpdfstring{$\ast$}{*} v2 binaries, and also supports the format specific to the old     \texorpdfstring{$\ast$}{*} \`{}-\/-\/list-\/test-\/names-\/only\`{} option, for people who used it in integrations.     \texorpdfstring{$\ast$}{*}/    void default\+List\+Tests( std\+::ostream\& out,                           Colour\+Impl\texorpdfstring{$\ast$}{*} stream\+Colour,                           std\+::vector$<$Test\+Case\+Handle$>$ const\& tests,                           bool is\+Filtered,                           Verbosity verbosity );    /\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Prints test run totals to the provided \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}} in user-\/friendly format     \texorpdfstring{$\ast$}{*}     \texorpdfstring{$\ast$}{*} Used by the console and compact reporters.     \texorpdfstring{$\ast$}{*}/    void print\+Test\+Run\+Totals( std\+::ostream\& \mbox{\hyperlink{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}{stream}},                      Colour\+Impl\& stream\+Colour,                      Totals const\& totals );\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+HELPERS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+JSON\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+JSON\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$stack$>$namespace Catch \{    class Json\+Reporter \+: public Streaming\+Reporter\+Base \{    public\+:        Json\+Reporter( Reporter\+Config\&\& config );        \texorpdfstring{$\sim$}{\string~}Json\+Reporter() override;        static std\+::string get\+Description();    public\+: // Streaming\+Reporter\+Base        void test\+Run\+Starting( Test\+Run\+Info const\& run\+Info ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& run\+Stats ) override;        void test\+Case\+Starting( Test\+Case\+Info const\& tc\+Info ) override;        void test\+Case\+Ended( Test\+Case\+Stats const\& tc\+Stats ) override;        void test\+Case\+Partial\+Starting( Test\+Case\+Info const\& tc\+Info,                                      uint64\+\_\+t index ) override;        void test\+Case\+Partial\+Ended( Test\+Case\+Stats const\& tc\+Stats,                                   uint64\+\_\+t index ) override;        void section\+Starting( Section\+Info const\& section\+Info ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) override;        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        //void test\+Run\+Ended\+Cumulative() override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& ) override;        void benchmark\+Failed( String\+Ref error ) override;        void list\+Reporters(            std\+::vector$<$Reporter\+Description$>$ const\& descriptions ) override;        void list\+Listeners(            std\+::vector$<$Listener\+Description$>$ const\& descriptions ) override;        void list\+Tests( std\+::vector$<$Test\+Case\+Handle$>$ const\& tests ) override;        void list\+Tags( std\+::vector$<$Tag\+Info$>$ const\& tags ) override;    private\+:        Timer m\+\_\+test\+Case\+Timer;        enum class Writer \{            Object,            Array        \};        Json\+Array\+Writer\& start\+Array();        Json\+Array\+Writer\& start\+Array( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}{key}} );        Json\+Object\+Writer\& start\+Object();        Json\+Object\+Writer\& start\+Object( String\+Ref \mbox{\hyperlink{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}{key}} );        void end\+Object();        void end\+Array();        bool is\+Inside( Writer writer );        void start\+Listing();        void end\+Listing();        // Invariant\+:        // When m\+\_\+writers is not empty and its top element is        // -\/ Writer\+::\+Object, then m\+\_\+object\+Writers is not be empty        // -\/ Writer\+::\+Array,  then m\+\_\+array\+Writers shall not be empty        std\+::stack$<$Json\+Object\+Writer$>$ m\+\_\+object\+Writers\{\};        std\+::stack$<$Json\+Array\+Writer$>$ m\+\_\+array\+Writers\{\};        std\+::stack$<$Writer$>$ m\+\_\+writers\{\};        bool m\+\_\+started\+Listing = false;        // std\+::size\+\_\+t m\+\_\+section\+Depth = 0;        // std\+::size\+\_\+t m\+\_\+section\+Started = 0;    \};\} // namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+JSON\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+JUNIT\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+JUNIT\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Junit\+Reporter final \+: public Cumulative\+Reporter\+Base \{    public\+:        Junit\+Reporter(Reporter\+Config\&\& \+\_\+config);        static std\+::string get\+Description();        void test\+Run\+Starting(Test\+Run\+Info const\& run\+Info) override;        void test\+Case\+Starting(Test\+Case\+Info const\& test\+Case\+Info) override;        void assertion\+Ended(Assertion\+Stats const\& assertion\+Stats) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats) override;        void test\+Run\+Ended\+Cumulative() override;    private\+:        void write\+Run(Test\+Run\+Node const\& test\+Run\+Node, double suite\+Time);        void write\+Test\+Case(Test\+Case\+Node const\& test\+Case\+Node);        void write\+Section( std\+::string const\& class\+Name,                           std\+::string const\& root\+Name,                           Section\+Node const\& section\+Node,                           bool test\+Ok\+To\+Fail );        void write\+Assertions(Section\+Node const\& section\+Node);        void write\+Assertion(Assertion\+Stats const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}});        Xml\+Writer xml;        Timer suite\+Timer;        std\+::string std\+Out\+For\+Suite;        std\+::string std\+Err\+For\+Suite;        unsigned int unexpected\+Exceptions = 0;        bool m\+\_\+ok\+To\+Fail = false;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+JUNIT\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+MULTI\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+MULTI\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Multi\+Reporter final \+: public IEvent\+Listener \{        /\texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} Stores all added reporters and listeners         \texorpdfstring{$\ast$}{*}         \texorpdfstring{$\ast$}{*} All Listeners are stored before all reporters, and individual         \texorpdfstring{$\ast$}{*} listeners/reporters are stored in order of insertion.         \texorpdfstring{$\ast$}{*}/        std\+::vector$<$IEvent\+Listener\+Ptr$>$ m\+\_\+reporter\+Likes;        bool m\+\_\+have\+Noncapturing\+Reporters = false;        // Keep track of how many listeners we have already inserted,        // so that we can insert them into the \mbox{\hyperlink{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}} vector at the right place        size\+\_\+t m\+\_\+inserted\+Listeners = 0;        void update\+Preferences(IEvent\+Listener const\& reporterish);    public\+:        using IEvent\+Listener\+::\+IEvent\+Listener;        void add\+Listener( IEvent\+Listener\+Ptr\&\& listener );        void add\+Reporter( IEvent\+Listener\+Ptr\&\& reporter );    public\+: // IEvent\+Listener        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void fatal\+Error\+Encountered( String\+Ref error ) override;        void report\+Invalid\+Test\+Spec( String\+Ref arg ) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting( Benchmark\+Info const\& benchmark\+Info ) override;        void benchmark\+Ended( Benchmark\+Stats$<$$>$ const\& benchmark\+Stats ) override;        void benchmark\+Failed( String\+Ref error ) override;        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) override;        void test\+Case\+Starting( Test\+Case\+Info const\& test\+Info ) override;        void test\+Case\+Partial\+Starting(Test\+Case\+Info const\& test\+Info, uint64\+\_\+t part\+Number) override;        void section\+Starting( Section\+Info const\& section\+Info ) override;        void assertion\+Starting( Assertion\+Info const\& assertion\+Info ) override;        void assertion\+Ended( Assertion\+Stats const\& assertion\+Stats ) override;        void section\+Ended( Section\+Stats const\& section\+Stats ) override;        void test\+Case\+Partial\+Ended(Test\+Case\+Stats const\& test\+Stats, uint64\+\_\+t part\+Number) override;        void test\+Case\+Ended( Test\+Case\+Stats const\& test\+Case\+Stats ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& test\+Run\+Stats ) override;        void skip\+Test( Test\+Case\+Info const\& test\+Info ) override;        void list\+Reporters(std\+::vector$<$Reporter\+Description$>$ const\& descriptions) override;        void list\+Listeners(std\+::vector$<$Listener\+Description$>$ const\& descriptions) override;        void list\+Tests(std\+::vector$<$Test\+Case\+Handle$>$ const\& tests) override;        void list\+Tags(std\+::vector$<$Tag\+Info$>$ const\& tags) override;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+MULTI\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRARS\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRARS\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$type\+\_\+traits$>$namespace Catch \{    namespace Detail \{        template $<$typename T, typename = void$>$        struct has\+\_\+description \+: std\+::false\+\_\+type \{\};        template $<$typename T$>$        struct has\+\_\+description$<$            T,            void\+\_\+t$<$decltype( T\+::get\+Description() )$>$$>$            \+: std\+::true\+\_\+type \{\};                        void register\+Reporter\+Impl( std\+::string const\& name,                                   IReporter\+Factory\+Ptr reporter\+Ptr );                void register\+Listener\+Impl( Detail\+::unique\+\_\+ptr$<$Event\+Listener\+Factory$>$ listener\+Factory );    \} // namespace Detail    class IEvent\+Listener;    using IEvent\+Listener\+Ptr = Detail\+::unique\+\_\+ptr$<$IEvent\+Listener$>$;    template $<$typename T$>$    class Reporter\+Factory \+: public IReporter\+Factory \{        IEvent\+Listener\+Ptr create( Reporter\+Config\&\& config ) const override \{            return Detail\+::make\+\_\+unique$<$T$>$( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(config) );        \}        std\+::string get\+Description() const override \{            return T\+::get\+Description();        \}    \};    template$<$typename T$>$    class Reporter\+Registrar \{    public\+:        explicit Reporter\+Registrar( std\+::string const\& name ) \{            register\+Reporter\+Impl( name,                                  Detail\+::make\+\_\+unique$<$Reporter\+Factory$<$T$>$$>$() );        \}    \};    template$<$typename T$>$    class Listener\+Registrar \{        class Typed\+Listener\+Factory \+: public Event\+Listener\+Factory \{            String\+Ref m\+\_\+listener\+Name;            std\+::string get\+Description\+Impl( std\+::true\+\_\+type ) const \{                return T\+::get\+Description();            \}            std\+::string get\+Description\+Impl( std\+::false\+\_\+type ) const \{                return "{}(No description provided)"{};            \}        public\+:            Typed\+Listener\+Factory( String\+Ref listener\+Name )\+:                m\+\_\+listener\+Name( listener\+Name ) \{\}            IEvent\+Listener\+Ptr create( IConfig const\texorpdfstring{$\ast$}{*} config ) const override \{                return Detail\+::make\+\_\+unique$<$T$>$( config );            \}            String\+Ref get\+Name() const override \{                return m\+\_\+listener\+Name;            \}            std\+::string get\+Description() const override \{                return get\+Description\+Impl( Detail\+::has\+\_\+description$<$T$>$\{\} );            \}        \};    public\+:        Listener\+Registrar(String\+Ref listener\+Name) \{            register\+Listener\+Impl( Detail\+::make\+\_\+unique$<$Typed\+Listener\+Factory$>$(listener\+Name) );        \}    \};\}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE)\#    define CATCH\+\_\+\+REGISTER\+\_\+\+REPORTER( name, reporter\+Type )                      \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a1500dca9a578a0bd2f85771cfa3fd35d}{CATCH\+\_\+\+INTERNAL\+\_\+\+START\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}                              \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_aa0200c23b35ba2bd8ebed69a8f3c1c66}{CATCH\+\_\+\+INTERNAL\+\_\+\+SUPPRESS\+\_\+\+GLOBALS\+\_\+\+WARNINGS}}                               \textbackslash{}        namespace \{                                                            \textbackslash{}            Catch\+::\+Reporter\+Registrar$<$reporter\+Type$>$ \mbox{\hyperlink{catch__amalgamated_8hpp_afe320ceec108fc8c160f9ac3938f1bc8}{INTERNAL\+\_\+\+CATCH\+\_\+\+UNIQUE\+\_\+\+NAME}}( \textbackslash{}                catch\+\_\+internal\+\_\+\+Registrar\+For )( name );                         \textbackslash{}        \}                                                                      \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_ad9594e9891b032f0dd0279960dc861a5}{CATCH\+\_\+\+INTERNAL\+\_\+\+STOP\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}\#    define CATCH\+\_\+\+REGISTER\+\_\+\+LISTENER( listener\+Type )                            \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_a1500dca9a578a0bd2f85771cfa3fd35d}{CATCH\+\_\+\+INTERNAL\+\_\+\+START\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}                              \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_aa0200c23b35ba2bd8ebed69a8f3c1c66}{CATCH\+\_\+\+INTERNAL\+\_\+\+SUPPRESS\+\_\+\+GLOBALS\+\_\+\+WARNINGS}}                               \textbackslash{}        namespace \{                                                            \textbackslash{}            Catch\+::\+Listener\+Registrar$<$listener\+Type$>$ \mbox{\hyperlink{catch__amalgamated_8hpp_afe320ceec108fc8c160f9ac3938f1bc8}{INTERNAL\+\_\+\+CATCH\+\_\+\+UNIQUE\+\_\+\+NAME}}( \textbackslash{}                catch\+\_\+internal\+\_\+\+Registrar\+For )( \#listener\+Type\#\#\+\_\+catch\+\_\+sr );     \textbackslash{}        \}                                                                      \textbackslash{}        \mbox{\hyperlink{catch__amalgamated_8hpp_ad9594e9891b032f0dd0279960dc861a5}{CATCH\+\_\+\+INTERNAL\+\_\+\+STOP\+\_\+\+WARNINGS\+\_\+\+SUPPRESSION}}\#\mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} // CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\#define CATCH\+\_\+\+REGISTER\+\_\+\+REPORTER(name, reporter\+Type)\#define CATCH\+\_\+\+REGISTER\+\_\+\+LISTENER(listener\+Type)\#endif // CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+REGISTRARS\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+SONARQUBE\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+SONARQUBE\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Sonar\+Qube\+Reporter final \+: public Cumulative\+Reporter\+Base \{    public\+:        Sonar\+Qube\+Reporter(Reporter\+Config\&\& config)        \+: Cumulative\+Reporter\+Base(\mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(config))        , xml(m\+\_\+stream) \{            m\+\_\+preferences.\+should\+Redirect\+Std\+Out = true;            m\+\_\+preferences.\+should\+Report\+All\+Assertions = true;            m\+\_\+should\+Store\+Succesful\+Assertions = false;        \}        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results in the Generic Test Data Sonar\+Qube XML format"{}s;        \}        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Run\+Info ) override;        void test\+Run\+Ended\+Cumulative() override \{            write\+Run( \texorpdfstring{$\ast$}{*}m\+\_\+test\+Run );            xml.\+end\+Element();        \}        void write\+Run( Test\+Run\+Node const\& run\+Node );        void write\+Test\+File(String\+Ref filename, std\+::vector$<$Test\+Case\+Node const\texorpdfstring{$\ast$}{*}$>$ const\& test\+Case\+Nodes);        void write\+Test\+Case(Test\+Case\+Node const\& test\+Case\+Node);        void write\+Section(std\+::string const\& root\+Name, Section\+Node const\& section\+Node, bool ok\+To\+Fail);        void write\+Assertions(Section\+Node const\& section\+Node, bool ok\+To\+Fail);        void write\+Assertion(Assertion\+Stats const\& \mbox{\hyperlink{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}{stats}}, bool ok\+To\+Fail);    private\+:        Xml\+Writer xml;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+SONARQUBE\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+TAP\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+TAP\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class TAPReporter final \+: public Streaming\+Reporter\+Base \{    public\+:        TAPReporter( Reporter\+Config\&\& config )\+:            Streaming\+Reporter\+Base( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(config) ) \{            m\+\_\+preferences.\+should\+Report\+All\+Assertions = true;        \}        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results in TAP format, suitable for test harnesses"{}s;        \}        void test\+Run\+Starting( Test\+Run\+Info const\& test\+Info ) override;        void no\+Matching\+Test\+Cases( String\+Ref unmatched\+Spec ) override;        void assertion\+Ended(Assertion\+Stats const\& \+\_\+assertion\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& \+\_\+test\+Run\+Stats) override;    private\+:        std\+::size\+\_\+t \mbox{\hyperlink{catch__amalgamated_8cpp_ac449e05964ab2319a33c1718c5ad485b}{counter}} = 0;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+TAP\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+TEAMCITY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+TEAMCITY\+\_\+\+HPP\+\_\+\+INCLUDED\#include $<$cstring$>$\#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#   pragma clang diagnostic push\#   pragma clang diagnostic ignored "{}-\/Wpadded"{}\#endifnamespace Catch \{    class Team\+City\+Reporter final \+: public Streaming\+Reporter\+Base \{    public\+:        Team\+City\+Reporter( Reporter\+Config\&\& \+\_\+config )        \+:   Streaming\+Reporter\+Base( \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(\+\_\+config) )        \{            m\+\_\+preferences.\+should\+Redirect\+Std\+Out = true;        \}        \texorpdfstring{$\sim$}{\string~}Team\+City\+Reporter() override;        static std\+::string get\+Description() \{            using namespace std\+::string\+\_\+literals;            return "{}Reports test results as Team\+City service messages"{}s;        \}        void test\+Run\+Starting( Test\+Run\+Info const\& run\+Info ) override;        void test\+Run\+Ended( Test\+Run\+Stats const\& run\+Stats ) override;        void assertion\+Ended(Assertion\+Stats const\& assertion\+Stats) override;        void section\+Starting(Section\+Info const\& section\+Info) override \{            m\+\_\+header\+Printed\+For\+This\+Section = false;            Streaming\+Reporter\+Base\+::section\+Starting( section\+Info );        \}        void test\+Case\+Starting(Test\+Case\+Info const\& test\+Info) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats) override;    private\+:        void print\+Section\+Header(std\+::ostream\& os);        bool m\+\_\+header\+Printed\+For\+This\+Section = false;        Timer m\+\_\+test\+Timer;    \};\} // end namespace Catch\#ifdef \+\_\+\+\_\+clang\+\_\+\+\_\+\#   pragma clang diagnostic pop\#endif\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+TEAMCITY\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+REPORTER\+\_\+\+XML\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+REPORTER\+\_\+\+XML\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    class Xml\+Reporter \+: public Streaming\+Reporter\+Base \{    public\+:        Xml\+Reporter(Reporter\+Config\&\& \+\_\+config);        \texorpdfstring{$\sim$}{\string~}Xml\+Reporter() override;        static std\+::string get\+Description();        virtual std\+::string get\+Stylesheet\+Ref() const;        void write\+Source\+Info(Source\+Line\+Info const\& source\+Info);    public\+: // Streaming\+Reporter\+Base        void test\+Run\+Starting(Test\+Run\+Info const\& test\+Info) override;        void test\+Case\+Starting(Test\+Case\+Info const\& test\+Info) override;        void section\+Starting(Section\+Info const\& section\+Info) override;        void assertion\+Starting(Assertion\+Info const\&) override;        void assertion\+Ended(Assertion\+Stats const\& assertion\+Stats) override;        void section\+Ended(Section\+Stats const\& section\+Stats) override;        void test\+Case\+Ended(Test\+Case\+Stats const\& test\+Case\+Stats) override;        void test\+Run\+Ended(Test\+Run\+Stats const\& test\+Run\+Stats) override;        void benchmark\+Preparing( String\+Ref name ) override;        void benchmark\+Starting(Benchmark\+Info const\&) override;        void benchmark\+Ended(Benchmark\+Stats$<$$>$ const\&) override;        void benchmark\+Failed( String\+Ref error ) override;        void list\+Reporters(std\+::vector$<$Reporter\+Description$>$ const\& descriptions) override;        void list\+Listeners(std\+::vector$<$Listener\+Description$>$ const\& descriptions) override;        void list\+Tests(std\+::vector$<$Test\+Case\+Handle$>$ const\& tests) override;        void list\+Tags(std\+::vector$<$Tag\+Info$>$ const\& tags) override;    private\+:        Timer m\+\_\+test\+Case\+Timer;        Xml\+Writer m\+\_\+xml;        int m\+\_\+section\+Depth = 0;    \};\} // end namespace Catch\#endif // CATCH\+\_\+\+REPORTER\+\_\+\+XML\+\_\+\+HPP\+\_\+\+INCLUDED\#endif // CATCH\+\_\+\+REPORTERS\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED\#endif // \mbox{\hyperlink{catch__amalgamated_8hpp_a46e230da206ed7d95ccf9f8c57f39f99}{CATCH\+\_\+\+ALL\+\_\+\+HPP\+\_\+\+INCLUDED}}\#endif // CATCH\+\_\+\+AMALGAMATED\+\_\+\+HPP\+\_\+\+INCLUDED\#ifndef CATCH\+\_\+\+WINDOWS\+\_\+\+H\+\_\+\+PROXY\+\_\+\+HPP\+\_\+\+INCLUDED\#define CATCH\+\_\+\+WINDOWS\+\_\+\+H\+\_\+\+PROXY\+\_\+\+HPP\+\_\+\+INCLUDED\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+PLATFORM\+\_\+\+WINDOWS)// We might end up with the define made globally through the compiler,// and we don\textquotesingle{}t want to trigger warnings for this\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(NOMINMAX)\#  define NOMINMAX\#endif\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} !defined(WIN32\+\_\+\+LEAN\+\_\+\+AND\+\_\+\+MEAN)\#  define WIN32\+\_\+\+LEAN\+\_\+\+AND\+\_\+\+MEAN\#endif\#include $<$windows.\+h$>$\#endif // defined(CATCH\+\_\+\+PLATFORM\+\_\+\+WINDOWS)\#endif // CATCH\+\_\+\+WINDOWS\+\_\+\+H\+\_\+\+PROXY\+\_\+\+HPP\+\_\+\+INCLUDEDnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            Chronometer\+Concept\+::\texorpdfstring{$\sim$}{\string~}\+Chronometer\+Concept() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.\#include $<$vector$>$namespace Catch \{    namespace Benchmark \{        namespace Detail \{            Sample\+Analysis analyse(const IConfig \&cfg, FDuration\texorpdfstring{$\ast$}{*} first, FDuration\texorpdfstring{$\ast$}{*} last) \{                \mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} (!cfg.\+benchmark\+No\+Analysis()) \{                    std\+::vector$<$double$>$ samples;                    samples.\+reserve(static\+\_\+cast$<$size\+\_\+t$>$(last -\/ first));                    for (auto current = first; current != last; ++current) \{                        samples.\+push\+\_\+back( current-\/$>$count() );                    \}                    auto analysis = \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a1a4ae7ccc7fa8c996bc6e4ada5a7004b}{Catch\+::\+Benchmark\+::\+Detail\+::analyse\+\_\+samples}}(                        cfg.\+benchmark\+Confidence\+Interval(),                        cfg.\+benchmark\+Resamples(),                        \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}(),                        \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}() + samples.\+size() );                    auto outliers = \mbox{\hyperlink{namespace_catch_1_1_benchmark_1_1_detail_a523468c0e7dbf99ffb1801aad78e352d}{Catch\+::\+Benchmark\+::\+Detail\+::classify\+\_\+outliers}}(                        \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}(), \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{samples.\+data}}() + samples.\+size() );                    auto wrap\+\_\+estimate = \mbox{[}$\,$\mbox{]}(Estimate$<$double$>$ e) \{                        return Estimate$<$FDuration$>$ \{                            FDuration(e.\+point),                                FDuration(e.\+lower\+\_\+bound),                                FDuration(e.\+upper\+\_\+bound),                                e.\+confidence\+\_\+interval,                        \};                    \};                    std\+::vector$<$FDuration$>$ samples2;                    samples2.\+reserve(samples.\+size());                    for (auto s \+: samples) \{                        samples2.\+push\+\_\+back( FDuration( s ) );                    \}                    return \{                        \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(samples2),                        wrap\+\_\+estimate(analysis.\+mean),                        wrap\+\_\+estimate(analysis.\+standard\+\_\+deviation),                        outliers,                        analysis.\+outlier\+\_\+variance,                    \};                \} \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} \{                    std\+::vector$<$FDuration$>$ samples;                    samples.\+reserve(static\+\_\+cast$<$size\+\_\+t$>$(last -\/ first));                    FDuration mean = FDuration(0);                    int i = 0;                    for (auto it = first; it $<$ last; ++it, ++i) \{                        samples.\+push\+\_\+back(\texorpdfstring{$\ast$}{*}it);                        mean += \texorpdfstring{$\ast$}{*}it;                    \}                    mean /= i;                    return Sample\+Analysis\{                        \mbox{\hyperlink{catch__amalgamated_8hpp_a62516a9b52be8207f277f4adc2999207}{CATCH\+\_\+\+MOVE}}(samples),                        Estimate$<$FDuration$>$\{ mean, mean, mean, 0.\+0 \},                        Estimate$<$FDuration$>$\{ FDuration( 0 ),                                             FDuration( 0 ),                                             FDuration( 0 ),                                             0.\+0 \},                        Outlier\+Classification\{\},                        0.\+0                    \};                \}            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catchnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            Benchmark\+Function\+::callable\+::\texorpdfstring{$\sim$}{\string~}callable() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch\#include $<$exception$>$namespace Catch \{    namespace Benchmark \{        namespace Detail \{            struct optimized\+\_\+away\+\_\+error \+: std\+::exception \{                const char\texorpdfstring{$\ast$}{*} what() const noexcept override;            \};            const char\texorpdfstring{$\ast$}{*} optimized\+\_\+away\+\_\+error\+::what() const noexcept \{                return "{}could not measure benchmark, maybe it was optimized away"{};            \}            void throw\+\_\+optimized\+\_\+away\+\_\+error() \{                \mbox{\hyperlink{namespace_catch_a3cbceeab9252d1b752f66a2826e92548}{Catch\+::throw\+\_\+exception}}(optimized\+\_\+away\+\_\+error\{\});            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.\#include $<$algorithm$>$\#include $<$cassert$>$\#include $<$cmath$>$\#include $<$cstddef$>$\#include $<$numeric$>$\#include $<$random$>$\#\mbox{\hyperlink{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}{if}} defined(CATCH\+\_\+\+CONFIG\+\_\+\+USE\+\_\+\+ASYNC)\#include $<$future$>$\#endifnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            namespace \{                template $<$typename URng, typename Estimator$>$                static sample                resample( URng\& rng,                          unsigned int resamples,                          double const\texorpdfstring{$\ast$}{*} first,                          double const\texorpdfstring{$\ast$}{*} last,                          Estimator\& estimator ) \{                    auto n = static\+\_\+cast$<$size\+\_\+t$>$( last -\/ first );                    Catch\+::uniform\+\_\+integer\+\_\+distribution$<$size\+\_\+t$>$ dist( 0, n -\/ 1 );                    sample out;                    out.\+reserve( resamples );                    std\+::vector$<$double$>$ resampled;                    resampled.\+reserve( n );                    for ( size\+\_\+t i = 0; i $<$ resamples; ++i ) \{                        resampled.\+clear();                        for ( size\+\_\+t s = 0; s $<$ n; ++s ) \{                            resampled.\+push\+\_\+back( first\mbox{[}dist( rng )\mbox{]} );                        \}                        const auto estimate =                            estimator( \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{resampled.\+data}}(), \mbox{\hyperlink{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}{resampled.\+data}}() + resampled.\+size() );                        out.\+push\+\_\+back( estimate );                    \}                    std\+::sort( out.\+begin(), out.\+end() );                    return out;                \}                static double outlier\+\_\+variance( Estimate$<$double$>$ mean,                                                Estimate$<$double$>$ stddev,                                                int n ) \{                    double sb = stddev.\+point;                    double mn = mean.\+point / n;                    double mg\+\_\+min = mn / 2.;                    double sg = (std\+::min)( mg\+\_\+min / 4., sb / std\+::sqrt( n ) );                    double sg2 = sg \texorpdfstring{$\ast$}{*} sg;                    double sb2 = sb \texorpdfstring{$\ast$}{*} sb;                    auto c\+\_\+max = \mbox{[}n, mn, sb2, sg2\mbox{]}( double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) -\/$>$ double \{                        double k = mn -\/ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}};                        double d = k \texorpdfstring{$\ast$}{*} k;                        double nd = n \texorpdfstring{$\ast$}{*} d;                        double k0 = -\/n \texorpdfstring{$\ast$}{*} nd;                        double k1 = sb2 -\/ n \texorpdfstring{$\ast$}{*} sg2 + nd;                        double det = k1 \texorpdfstring{$\ast$}{*} k1 -\/ 4 \texorpdfstring{$\ast$}{*} sg2 \texorpdfstring{$\ast$}{*} k0;                        return static\+\_\+cast$<$int$>$( -\/2. \texorpdfstring{$\ast$}{*} k0 /                                                 ( k1 + std\+::sqrt( det ) ) );                    \};                    auto var\+\_\+out = \mbox{[}n, sb2, sg2\mbox{]}( double c ) \{                        double nc = n -\/ c;                        return ( nc / n ) \texorpdfstring{$\ast$}{*} ( sb2 -\/ nc \texorpdfstring{$\ast$}{*} sg2 );                    \};                    return (std\+::min)( var\+\_\+out( 1 ),                                       var\+\_\+out(                                           (std\+::min)( c\+\_\+max( 0. ),                                                       c\+\_\+max( mg\+\_\+min ) ) ) ) /                           sb2;                \}                static double erf\+\_\+inv( double \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) \{                    // Code accompanying the article "{}Approximating the erfinv}



\doxysubsection{Function Documentation}
\Hypertarget{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed}\label{catch__amalgamated_8cpp_a62bf6e1353fde8e95644d156c4a8b3ed} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!if@{if}}
\index{if@{if}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{if()}{if()}}
{\footnotesize\ttfamily \mbox{\hyperlink{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}{else}} if (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\Hypertarget{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97}\label{catch__amalgamated_8cpp_a0ddf1224851353fc92bfbff6f499fa97} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!main@{main}}
\index{main@{main}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char \texorpdfstring{$\ast$}{*}}]{argv\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})}



\doxysubsection{Variable Documentation}
\Hypertarget{catch__amalgamated_8cpp_a5f5de53ffd2c7aad35b1140210ffe6cf}\label{catch__amalgamated_8cpp_a5f5de53ffd2c7aad35b1140210ffe6cf} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!colour@{colour}}
\index{colour@{colour}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{colour}{colour}}
{\footnotesize\ttfamily Colour\+::\+Code colour\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_abf522b0ef8c8b3a16c40fff2a0b69ebf}\label{catch__amalgamated_8cpp_abf522b0ef8c8b3a16c40fff2a0b69ebf} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!colourImpl@{colourImpl}}
\index{colourImpl@{colourImpl}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{colourImpl}{colourImpl}}
{\footnotesize\ttfamily Colour\+Impl\texorpdfstring{$\ast$}{*} colour\+Impl\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ac449e05964ab2319a33c1718c5ad485b}\label{catch__amalgamated_8cpp_ac449e05964ab2319a33c1718c5ad485b} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!counter@{counter}}
\index{counter@{counter}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{counter}{counter}}
{\footnotesize\ttfamily std\+::size\+\_\+t counter\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7}\label{catch__amalgamated_8cpp_a21efc0fe469545138ab82d6041ed2ad7} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!data@{data}}
\index{data@{data}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{data}{data}}
{\footnotesize\ttfamily char data\mbox{[}buffer\+Size\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba}\label{catch__amalgamated_8cpp_a0544c3fe466e421738dae463968b70ba} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!else@{else}}
\index{else@{else}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{else}{else}}
{\footnotesize\ttfamily else}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}}\ =\ sqrt(\ \mbox{\hyperlink{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}{w}}\ )\ -\/\ 5.000000}

\end{DoxyCode}
\Hypertarget{catch__amalgamated_8cpp_a6f6290adaf501ac228b6a8d18cbab742}\label{catch__amalgamated_8cpp_a6f6290adaf501ac228b6a8d18cbab742} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!itMessage@{itMessage}}
\index{itMessage@{itMessage}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{itMessage}{itMessage}}
{\footnotesize\ttfamily std\+::vector$<$Message\+Info$>$\+::const\+\_\+iterator it\+Message\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6}\label{catch__amalgamated_8cpp_ab44666b6e91e2bbae6bcf104d48726d6} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!key@{key}}
\index{key@{key}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{key}{key}}
{\footnotesize\ttfamily String\+Ref key}

\Hypertarget{catch__amalgamated_8cpp_a4359931fc656b120d087d978af7a052c}\label{catch__amalgamated_8cpp_a4359931fc656b120d087d978af7a052c} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_colour@{m\_colour}}
\index{m\_colour@{m\_colour}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_colour}{m\_colour}}
{\footnotesize\ttfamily Colour\+::\+Code m\+\_\+colour\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6}\label{catch__amalgamated_8cpp_af0f105146a96441f9605b6daeae0fcc6} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_config@{m\_config}}
\index{m\_config@{m\_config}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_config}{m\_config}}
{\footnotesize\ttfamily Config const\texorpdfstring{$\ast$}{*} m\+\_\+config\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a5941e5c22a1a6fe824e9e0a3c7359ff6}\label{catch__amalgamated_8cpp_a5941e5c22a1a6fe824e9e0a3c7359ff6} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_context@{m\_context}}
\index{m\_context@{m\_context}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_context}{m\_context}}
{\footnotesize\ttfamily Run\+Context m\+\_\+context\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ad5900e7ccb0e3f2815a8971b89cbc6ed}\label{catch__amalgamated_8cpp_ad5900e7ccb0e3f2815a8971b89cbc6ed} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_enumValuesRegistry@{m\_enumValuesRegistry}}
\index{m\_enumValuesRegistry@{m\_enumValuesRegistry}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_enumValuesRegistry}{m\_enumValuesRegistry}}
{\footnotesize\ttfamily Detail\+::\+Enum\+Values\+Registry m\+\_\+enum\+Values\+Registry\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a0b4593bdd0488253936b22b633e2cd42}\label{catch__amalgamated_8cpp_a0b4593bdd0488253936b22b633e2cd42} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_exceptionRegistry@{m\_exceptionRegistry}}
\index{m\_exceptionRegistry@{m\_exceptionRegistry}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_exceptionRegistry}{m\_exceptionRegistry}}
{\footnotesize\ttfamily Startup\+Exception\+Registry m\+\_\+exception\+Registry\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_aa1c2ae2e626d6e6e27542ab82fe65976}\label{catch__amalgamated_8cpp_aa1c2ae2e626d6e6e27542ab82fe65976} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_exceptionTranslatorRegistry@{m\_exceptionTranslatorRegistry}}
\index{m\_exceptionTranslatorRegistry@{m\_exceptionTranslatorRegistry}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_exceptionTranslatorRegistry}{m\_exceptionTranslatorRegistry}}
{\footnotesize\ttfamily Exception\+Translator\+Registry m\+\_\+exception\+Translator\+Registry\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a655e4136c819ebe8f07327e681da8639}\label{catch__amalgamated_8cpp_a655e4136c819ebe8f07327e681da8639} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_generator@{m\_generator}}
\index{m\_generator@{m\_generator}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_generator}{m\_generator}}
{\footnotesize\ttfamily Generator\+Base\+Ptr m\+\_\+generator}

\Hypertarget{catch__amalgamated_8cpp_a622ac834e3db891a83299fa29fc348b9}\label{catch__amalgamated_8cpp_a622ac834e3db891a83299fa29fc348b9} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_inNanoseconds@{m\_inNanoseconds}}
\index{m\_inNanoseconds@{m\_inNanoseconds}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_inNanoseconds}{m\_inNanoseconds}}
{\footnotesize\ttfamily double m\+\_\+in\+Nanoseconds\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a19778771fb6ddb51e324aa20a9858084}\label{catch__amalgamated_8cpp_a19778771fb6ddb51e324aa20a9858084} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_matches@{m\_matches}}
\index{m\_matches@{m\_matches}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_matches}{m\_matches}}
{\footnotesize\ttfamily Test\+Spec\+::\+Matches m\+\_\+matches\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a79fc1ebece5f907d6706d8e4fa77d62c}\label{catch__amalgamated_8cpp_a79fc1ebece5f907d6706d8e4fa77d62c} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_ofs@{m\_ofs}}
\index{m\_ofs@{m\_ofs}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_ofs}{m\_ofs}}
{\footnotesize\ttfamily std\+::ofstream m\+\_\+ofs\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db}\label{catch__amalgamated_8cpp_a0a2800973a691365a9cc107e095689db} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_os@{m\_os}}
\index{m\_os@{m\_os}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_os}{m\_os}}
{\footnotesize\ttfamily std\+::ostream m\+\_\+os\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_acdc454c31672a1374dbb56c983b056f5}\label{catch__amalgamated_8cpp_acdc454c31672a1374dbb56c983b056f5} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_other@{m\_other}}
\index{m\_other@{m\_other}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_other}{m\_other}}
{\footnotesize\ttfamily Section\+Info const\& m\+\_\+other\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_aee7954c057251292dd81c24e2931c774}\label{catch__amalgamated_8cpp_aee7954c057251292dd81c24e2931c774} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_reporter@{m\_reporter}}
\index{m\_reporter@{m\_reporter}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_reporter}{m\_reporter}}
{\footnotesize\ttfamily IEvent\+Listener\texorpdfstring{$\ast$}{*} m\+\_\+reporter\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a47916ef2e43a9e2d8ef114661caef5e3}\label{catch__amalgamated_8cpp_a47916ef2e43a9e2d8ef114661caef5e3} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_reporterRegistry@{m\_reporterRegistry}}
\index{m\_reporterRegistry@{m\_reporterRegistry}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_reporterRegistry}{m\_reporterRegistry}}
{\footnotesize\ttfamily Reporter\+Registry m\+\_\+reporter\+Registry\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a56c8a1c5f0f539710021c2f224de8bc0}\label{catch__amalgamated_8cpp_a56c8a1c5f0f539710021c2f224de8bc0} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_rows@{m\_rows}}
\index{m\_rows@{m\_rows}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_rows}{m\_rows}}
{\footnotesize\ttfamily std\+::vector$<$std\+::string$>$ m\+\_\+rows\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a0267ab1dafcf9a4c5a1a618c4c8218ce}\label{catch__amalgamated_8cpp_a0267ab1dafcf9a4c5a1a618c4c8218ce} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_streamBuf@{m\_streamBuf}}
\index{m\_streamBuf@{m\_streamBuf}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_streamBuf}{m\_streamBuf}}
{\footnotesize\ttfamily Detail\+::unique\+\_\+ptr$<$Stream\+Buf\+Impl$<$Output\+Debug\+Writer$>$ $>$ m\+\_\+stream\+Buf\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a7552247dcef6ed5747fbbcef0695ce8b}\label{catch__amalgamated_8cpp_a7552247dcef6ed5747fbbcef0695ce8b} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_suffix@{m\_suffix}}
\index{m\_suffix@{m\_suffix}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_suffix}{m\_suffix}}
{\footnotesize\ttfamily std\+::string m\+\_\+suffix\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a1adfd007ed382a215b665211aa8781ab}\label{catch__amalgamated_8cpp_a1adfd007ed382a215b665211aa8781ab} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_tagAliasRegistry@{m\_tagAliasRegistry}}
\index{m\_tagAliasRegistry@{m\_tagAliasRegistry}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_tagAliasRegistry}{m\_tagAliasRegistry}}
{\footnotesize\ttfamily Tag\+Alias\+Registry m\+\_\+tag\+Alias\+Registry\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a2c2108be938581d60dbf79425c3c7ead}\label{catch__amalgamated_8cpp_a2c2108be938581d60dbf79425c3c7ead} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_testAsFunction@{m\_testAsFunction}}
\index{m\_testAsFunction@{m\_testAsFunction}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_testAsFunction}{m\_testAsFunction}}
{\footnotesize\ttfamily Test\+Type m\+\_\+test\+As\+Function\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ab6f69a986720160660d1b3deb5926eb1}\label{catch__amalgamated_8cpp_ab6f69a986720160660d1b3deb5926eb1} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_testCaseRegistry@{m\_testCaseRegistry}}
\index{m\_testCaseRegistry@{m\_testCaseRegistry}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_testCaseRegistry}{m\_testCaseRegistry}}
{\footnotesize\ttfamily Test\+Registry m\+\_\+test\+Case\+Registry\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ab140a783769b2c4469581814e384bcf9}\label{catch__amalgamated_8cpp_ab140a783769b2c4469581814e384bcf9} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_tests@{m\_tests}}
\index{m\_tests@{m\_tests}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_tests}{m\_tests}}
{\footnotesize\ttfamily std\+::set$<$Test\+Case\+Handle const\texorpdfstring{$\ast$}{*}$>$ m\+\_\+tests\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_acce2d5c13f4e130d52426e2a8e9410e6}\label{catch__amalgamated_8cpp_acce2d5c13f4e130d52426e2a8e9410e6} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_units@{m\_units}}
\index{m\_units@{m\_units}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_units}{m\_units}}
{\footnotesize\ttfamily Unit m\+\_\+units\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a2823c67a327ec49e387727bbbe3aa803}\label{catch__amalgamated_8cpp_a2823c67a327ec49e387727bbbe3aa803} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_unmatchedTestSpecs@{m\_unmatchedTestSpecs}}
\index{m\_unmatchedTestSpecs@{m\_unmatchedTestSpecs}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_unmatchedTestSpecs}{m\_unmatchedTestSpecs}}
{\footnotesize\ttfamily bool m\+\_\+unmatched\+Test\+Specs = false\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436}\label{catch__amalgamated_8cpp_a382d64176fb800207ab8ca6d9c567436} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_width@{m\_width}}
\index{m\_width@{m\_width}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_width}{m\_width}}
{\footnotesize\ttfamily std\+::size\+\_\+t m\+\_\+width = 0\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ab448bd968db5f560dde343c3bee4df2b}\label{catch__amalgamated_8cpp_ab448bd968db5f560dde343c3bee4df2b} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!m\_writer@{m\_writer}}
\index{m\_writer@{m\_writer}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{m\_writer}{m\_writer}}
{\footnotesize\ttfamily WriterF m\+\_\+writer\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ad99fd0031ba3d525e3a839a46b16aefc}\label{catch__amalgamated_8cpp_ad99fd0031ba3d525e3a839a46b16aefc} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!messageLabel@{messageLabel}}
\index{messageLabel@{messageLabel}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{messageLabel}{messageLabel}}
{\footnotesize\ttfamily String\+Ref message\+Label\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ac3e57434baa29e157611033aa03e47d1}\label{catch__amalgamated_8cpp_ac3e57434baa29e157611033aa03e47d1} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!messages@{messages}}
\index{messages@{messages}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{messages}{messages}}
{\footnotesize\ttfamily std\+::vector$<$Message\+Info$>$ const\& messages\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}\label{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!p@{p}}
\index{p@{p}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{p}{p}}
{\footnotesize\ttfamily p = -\/2.\+7109920616438573243e-\/11}

\Hypertarget{catch__amalgamated_8cpp_a0787fbf1f60cf79cca7bea0e0789e23c}\label{catch__amalgamated_8cpp_a0787fbf1f60cf79cca7bea0e0789e23c} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!passOrFail@{passOrFail}}
\index{passOrFail@{passOrFail}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{passOrFail}{passOrFail}}
{\footnotesize\ttfamily String\+Ref pass\+Or\+Fail\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_acc0e0fbc97f20dbeb947f767f56be1e0}\label{catch__amalgamated_8cpp_acc0e0fbc97f20dbeb947f767f56be1e0} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!printInfoMessages@{printInfoMessages}}
\index{printInfoMessages@{printInfoMessages}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{printInfoMessages}{printInfoMessages}}
{\footnotesize\ttfamily bool print\+Info\+Messages\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b}\label{catch__amalgamated_8cpp_aee0ddf0328c0096691e52be8dfd1556b} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!result@{result}}
\index{result@{result}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{result}{result}}
{\footnotesize\ttfamily Assertion\+Result const\& result\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc}\label{catch__amalgamated_8cpp_a6040d4b263b354ef25f1d0c8960746cc} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!shardCount@{shardCount}}
\index{shardCount@{shardCount}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{shardCount}{shardCount}}
{\footnotesize\ttfamily unsigned int shard\+Count}

\Hypertarget{catch__amalgamated_8cpp_af3b75cb40dedcefde013e6ad56b37ead}\label{catch__amalgamated_8cpp_af3b75cb40dedcefde013e6ad56b37ead} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!shardFilePath@{shardFilePath}}
\index{shardFilePath@{shardFilePath}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{shardFilePath}{shardFilePath}}
{\footnotesize\ttfamily std\+::string shard\+File\+Path}

\Hypertarget{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47}\label{catch__amalgamated_8cpp_aa2fb9d653a584377fce81b9f3335ff47} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!shardIndex@{shardIndex}}
\index{shardIndex@{shardIndex}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{shardIndex}{shardIndex}}
{\footnotesize\ttfamily unsigned int shard\+Index}

\Hypertarget{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519}\label{catch__amalgamated_8cpp_a16312a4b00705b5846062dcc71581519} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!stats@{stats}}
\index{stats@{stats}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{stats}{stats}}
{\footnotesize\ttfamily Assertion\+Stats const\& stats\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb}\label{catch__amalgamated_8cpp_aeacb68b8c7e9ae9b97ab9c6ab41940cb} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!stream@{stream}}
\index{stream@{stream}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{stream}{stream}}
{\footnotesize\ttfamily std\+::ostream\& stream\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1}\label{catch__amalgamated_8cpp_a5dcc1560b74135e065519bc3986c14b1} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!value@{value}}
\index{value@{value}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{value}{value}}
{\footnotesize\ttfamily String\+Ref value}

\Hypertarget{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3}\label{catch__amalgamated_8cpp_aad57484016654da87125db86f4227ea3} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!w@{w}}
\index{w@{w}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{w}{w}}
{\footnotesize\ttfamily w = -\/log( ( 1.\+0 -\/ \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) \texorpdfstring{$\ast$}{*} ( 1.\+0 + \mbox{\hyperlink{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}{x}} ) )}

\Hypertarget{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265}\label{catch__amalgamated_8cpp_a6abfb3eb1e8098e09b8a4d1fc295b265} 
\index{catch\_amalgamated.cpp@{catch\_amalgamated.cpp}!x@{x}}
\index{x@{x}!catch\_amalgamated.cpp@{catch\_amalgamated.cpp}}
\doxysubsubsection{\texorpdfstring{x}{x}}
{\footnotesize\ttfamily return \mbox{\hyperlink{catch__amalgamated_8cpp_ac483f6ce851c9ecd9fb835ff7551737c}{p}}\texorpdfstring{$\ast$}{*} x}

